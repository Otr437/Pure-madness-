import { google, createGoogleGenerativeAI } from '@ai-sdk/google';
import { generateText, streamText, generateObject, streamObject, embed, embedMany } from 'ai';
import { experimental_generateImage as generateImage } from 'ai';
import { GoogleAICacheManager } from '@google/generative-ai/server';
import { z } from 'zod';
import * as fs from 'fs';

// ============================================================
// TYPES AND INTERFACES
// ============================================================

interface AgentConfig {
  name: string;
  model: string;
  systemPrompt: string;
  tools?: any[];
  capabilities: string[];
  memory?: ConversationMemory;
  thinkingBudget?: number;
  safetySettings?: Array<{
    category: string;
    threshold: string;
  }>;
  responseModalities?: string[];
  imageConfig?: {
    aspectRatio: string;
  };
}

interface ConversationMemory {
  messages: Array<{ 
    role: string; 
    content: string; 
    timestamp: number;
    metadata?: any;
  }>;
  context: Map<string, any>;
  summary?: string;
}

interface AgentInput {
  type: 'text' | 'image' | 'file' | 'url' | 'video' | 'multi';
  data: any;
  metadata?: {
    prompt?: string;
    mediaType?: string;
    parameters?: Record<string, any>;
  };
}

interface AgentOutput {
  response: string;
  reasoning?: string;
  toolCalls?: any[];
  sources?: any[];
  metadata?: any;
  files?: any[];
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    cachedTokens?: number;
  };
}

interface ToolDefinition {
  name: string;
  description: string;
  parameters: z.ZodObject<any>;
  execute: (params: any) => Promise<any>;
}

// ============================================================
// UTILITY FUNCTIONS
// ============================================================

function extractUsageMetadata(providerMetadata: any): any {
  const googleMetadata = providerMetadata?.google;
  if (!googleMetadata) return null;
  
  return {
    promptTokens: googleMetadata.usageMetadata?.promptTokenCount || 0,
    completionTokens: googleMetadata.usageMetadata?.candidatesTokenCount || 0,
    totalTokens: googleMetadata.usageMetadata?.totalTokenCount || 0,
    cachedTokens: googleMetadata.usageMetadata?.cachedContentTokenCount || 0,
    thinkingTokens: googleMetadata.usageMetadata?.thoughtsTokenCount || 0,
  };
}

function sanitizeToolName(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9_]/g, '_');
}

async function handleFileInput(input: AgentInput): Promise<Buffer | string> {
  if (typeof input.data === 'string' && input.data.startsWith('http')) {
    // URL input - let Google API handle it
    return input.data;
  }
  
  if (Buffer.isBuffer(input.data)) {
    return input.data;
  }
  
  if (typeof input.data === 'string' && fs.existsSync(input.data)) {
    return fs.readFileSync(input.data);
  }
  
  return input.data;
}

// ============================================================
// BASE AGENT CLASS
// ============================================================
class BaseAgent {
  protected config: AgentConfig;
  protected provider: ReturnType<typeof createGoogleGenerativeAI>;
  protected memory: ConversationMemory;
  
  constructor(config: AgentConfig, apiKey: string) {
    this.config = config;
    this.provider = createGoogleGenerativeAI({
      apiKey: apiKey || process.env.GOOGLE_GENERATIVE_AI_API_KEY,
    });
    this.memory = config.memory || {
      messages: [],
      context: new Map(),
    };
  }
  
  async process(input: AgentInput): Promise<AgentOutput> {
    const messages = this.buildMessages(input);
    
    const result = await generateText({
      model: google(this.config.model),
      messages,
      tools: this.buildTools(),
      providerOptions: {
        google: {
          thinkingConfig: this.config.thinkingBudget ? {
            thinkingBudget: this.config.thinkingBudget,
            includeThoughts: true,
          } : undefined,
          safetySettings: this.config.safetySettings,
        },
      },
    });
    
    this.updateMemory(input, result);
    
    return {
      response: result.text,
      reasoning: result.reasoning,
      toolCalls: result.toolCalls,
      sources: result.sources,
      metadata: result.providerMetadata,
      files: result.files,
    };
  }
  
  protected buildMessages(input: AgentInput): any[] {
    const messages: any[] = [];
    
    if (this.config.systemPrompt) {
      messages.push({
        role: 'system',
        content: this.config.systemPrompt,
      });
    }
    
    for (const msg of this.memory.messages) {
      messages.push({
        role: msg.role,
        content: msg.content,
      });
    }
    
    messages.push(this.formatInput(input));
    
    return messages;
  }
  
  protected async formatInput(input: AgentInput): Promise<any> {
    switch (input.type) {
      case 'text':
        return {
          role: 'user',
          content: input.data,
        };
      
      case 'image':
        const imageData = await handleFileInput(input);
        return {
          role: 'user',
          content: [
            { type: 'text', text: input.metadata?.prompt || 'Analyze this image' },
            { type: 'image', image: imageData },
          ],
        };
      
      case 'file':
        const fileData = await handleFileInput(input);
        return {
          role: 'user',
          content: [
            { type: 'text', text: input.metadata?.prompt || 'Analyze this file' },
            {
              type: 'file',
              data: fileData,
              mediaType: input.metadata?.mediaType || 'application/pdf',
            },
          ],
        };
      
      case 'url':
      case 'video':
        return {
          role: 'user',
          content: [
            { type: 'text', text: input.metadata?.prompt || 'Analyze this content' },
            {
              type: 'file',
              data: input.data, // URL string
              mediaType: input.metadata?.mediaType || 'video/mp4',
            },
          ],
        };
      
      case 'multi':
        return {
          role: 'user',
          content: input.data, // Already formatted array of content blocks
        };
      
      default:
        return {
          role: 'user',
          content: input.data,
        };
    }
  }
  
  protected buildTools(): any {
    const tools: any = {};
    
    if (this.config.capabilities.includes('search')) {
      tools.google_search = google.tools.googleSearch({});
    }
    
    if (this.config.capabilities.includes('code_execution')) {
      tools.code_execution = google.tools.codeExecution({});
    }
    
    if (this.config.capabilities.includes('url_context')) {
      tools.url_context = google.tools.urlContext({});
    }
    
    if (this.config.tools) {
      this.config.tools.forEach(tool => {
        tools[tool.name] = tool;
      });
    }
    
    return Object.keys(tools).length > 0 ? tools : undefined;
  }
  
  protected updateMemory(input: AgentInput, result: any) {
    this.memory.messages.push({
      role: 'user',
      content: typeof input.data === 'string' ? input.data : JSON.stringify(input.data),
      timestamp: Date.now(),
    });
    
    this.memory.messages.push({
      role: 'assistant',
      content: result.text,
      timestamp: Date.now(),
    });
    
    if (this.memory.messages.length > 50) {
      this.memory.messages = this.memory.messages.slice(-50);
    }
  }
  
  getMemory(): ConversationMemory {
    return this.memory;
  }
  
  clearMemory() {
    this.memory.messages = [];
    this.memory.context.clear();
  }
}

// ============================================================
// OSINT AGENT
// ============================================================
class OSINTAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'OSINT Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an advanced OSINT (Open Source Intelligence) agent. Your capabilities include:
- Deep web research and information gathering
- Social media analysis and pattern recognition
- Public records analysis
- Threat intelligence gathering
- Digital footprint analysis
- Cross-referencing multiple sources
- Timeline reconstruction
- Entity relationship mapping
- Geolocation analysis from images and data
- Data breach monitoring
- Dark web intelligence (ethical only)
- WHOIS and domain research
- IP address tracking and analysis
- Metadata extraction and analysis
- EXIF data analysis from images

Always provide sources, verify information across multiple channels, and maintain ethical boundaries.`,
      capabilities: ['search', 'url_context', 'code_execution'],
      thinkingBudget: 16384,
      tools: [
        {
          name: 'reverse_image_search',
          description: 'Perform reverse image search to find image origins',
          parameters: z.object({
            imageUrl: z.string(),
          }),
          execute: async ({ imageUrl }) => {
            return { found: true, sources: [], metadata: {} };
          },
        },
        {
          name: 'whois_lookup',
          description: 'Perform WHOIS lookup on domains',
          parameters: z.object({
            domain: z.string(),
          }),
          execute: async ({ domain }) => {
            return { domain, registrar: '', creation_date: '', expiry_date: '' };
          },
        },
        {
          name: 'ip_geolocation',
          description: 'Get geolocation data for IP addresses',
          parameters: z.object({
            ip: z.string(),
          }),
          execute: async ({ ip }) => {
            return { ip, country: '', city: '', coordinates: {} };
          },
        },
      ],
    }, apiKey, isRootAgent);
  }
  
  async investigate(target: string, investigationType: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Conduct a comprehensive ${investigationType} investigation on: ${target}. Provide detailed findings with sources.`,
    });
  }
  
  async analyzeImage(imagePath: string, analysisType: string): Promise<AgentOutput> {
    const imageData = fs.readFileSync(imagePath);
    return await this.process({
      type: 'image',
      data: imageData,
      metadata: {
        prompt: `Perform ${analysisType} analysis on this image. Extract all metadata, identify locations, objects, people (without naming), text, and any other relevant OSINT data.`,
      },
    });
  }
  
  async crossReference(sources: string[]): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Cross-reference these sources and identify patterns, contradictions, and verified facts: ${sources.join(', ')}`,
    });
  }
}

// ============================================================
// CRYPTO AGENT
// ============================================================
class CryptoAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Crypto Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an advanced cryptocurrency and blockchain analysis agent. Your capabilities include:
- Real-time crypto market analysis
- Blockchain transaction analysis
- Smart contract auditing
- DeFi protocol analysis
- NFT market research
- Tokenomics analysis
- On-chain analytics
- Wallet tracking (ethical only)
- Price prediction modeling
- Technical analysis (RSI, MACD, Bollinger Bands, etc.)
- Fundamental analysis
- Risk assessment
- Portfolio optimization
- Market sentiment analysis
- Regulatory compliance analysis
- Security audit recommendations

Provide data-driven insights with risk disclaimers. Never provide financial advice, only analysis.`,
      capabilities: ['search', 'url_context', 'code_execution'],
      thinkingBudget: 16384,
      tools: [
        {
          name: 'get_crypto_price',
          description: 'Get current cryptocurrency prices',
          parameters: z.object({
            symbol: z.string(),
            currency: z.string().default('USD'),
          }),
          execute: async ({ symbol, currency }) => {
            return { symbol, price: 0, change24h: 0, volume: 0 };
          },
        },
        {
          name: 'analyze_blockchain',
          description: 'Analyze blockchain transactions and addresses',
          parameters: z.object({
            blockchain: z.string(),
            address: z.string(),
          }),
          execute: async ({ blockchain, address }) => {
            return { transactions: [], balance: 0, activity: [] };
          },
        },
        {
          name: 'smart_contract_analysis',
          description: 'Analyze smart contract code for vulnerabilities',
          parameters: z.object({
            contractAddress: z.string(),
            blockchain: z.string(),
          }),
          execute: async ({ contractAddress, blockchain }) => {
            return { vulnerabilities: [], gasOptimization: [], security_score: 0 };
          },
        },
      ],
    }, apiKey, isRootAgent);
  }
  
  async analyzeMarket(crypto: string, timeframe: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Perform comprehensive market analysis for ${crypto} over ${timeframe}. Include technical indicators, on-chain metrics, sentiment analysis, and risk factors.`,
    });
  }
  
  async auditSmartContract(contractCode: string, blockchain: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Audit this smart contract on ${blockchain}:\n\n${contractCode}\n\nIdentify vulnerabilities, gas inefficiencies, and security risks.`,
    });
  }
  
  async portfolioOptimization(holdings: any[]): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Analyze this crypto portfolio and provide optimization recommendations: ${JSON.stringify(holdings)}`,
    });
  }
}

// ============================================================
// BUILDER AGENT
// ============================================================
class BuilderAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Builder Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an advanced software development and building agent. Your capabilities include:
- Full-stack application development
- Architecture design and system design
- Code generation in any language
- API design and implementation
- Database schema design
- DevOps and CI/CD pipeline setup
- Testing strategy and test generation
- Code review and optimization
- Security best practices
- Performance optimization
- Microservices architecture
- Cloud infrastructure design (AWS, GCP, Azure)
- Mobile app development
- Web3 and blockchain development
- AI/ML model integration
- Real-time systems
- Documentation generation

Generate production-ready, tested, and optimized code. Follow best practices and industry standards.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async buildApplication(requirements: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Build a complete application based on these requirements:\n\n${requirements}\n\nProvide full code, architecture, and deployment instructions.`,
    });
  }
  
  async reviewCode(code: string, language: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Review this ${language} code for bugs, security issues, performance problems, and best practices:\n\n${code}`,
    });
  }
  
  async designSystem(description: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Design a complete system architecture for: ${description}. Include diagrams, technology stack, scalability considerations, and implementation plan.`,
    });
  }
  
  async generateTests(code: string, framework: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Generate comprehensive unit, integration, and e2e tests for this code using ${framework}:\n\n${code}`,
    });
  }
}

// ============================================================
// RESEARCH AGENT
// ============================================================
class ResearchAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Research Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an advanced research agent capable of:
- Academic research and literature review
- Scientific paper analysis
- Market research and competitive analysis
- Data collection and analysis
- Statistical analysis
- Trend identification
- Citation and reference management
- Research methodology design
- Hypothesis testing
- Meta-analysis
- Systematic reviews
- Data visualization recommendations
- Research report generation

Provide thorough, well-sourced research with proper citations and methodology.`,
      capabilities: ['search', 'url_context', 'code_execution'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async conductResearch(topic: string, depth: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Conduct ${depth} research on: ${topic}. Include latest findings, key papers, methodologies, and comprehensive analysis.`,
    });
  }
  
  async analyzePaper(paperUrl: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Analyze this research paper: ${paperUrl}. Summarize methodology, findings, limitations, and implications.`,
    });
  }
}

// ============================================================
// DATA ANALYST AGENT
// ============================================================
class DataAnalystAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Data Analyst Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an advanced data analysis agent specializing in:
- Statistical analysis
- Data visualization
- Predictive modeling
- Machine learning
- Time series analysis
- A/B testing
- Data cleaning and preprocessing
- Feature engineering
- Anomaly detection
- Clustering and segmentation
- Regression analysis
- Classification
- Natural language processing
- Recommendation systems

Generate insights, visualizations, and actionable recommendations from data.`,
      capabilities: ['code_execution', 'search'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async analyzeData(data: any, analysisType: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Perform ${analysisType} on this dataset:\n\n${JSON.stringify(data)}\n\nProvide insights, visualizations code, and recommendations.`,
    });
  }
  
  async buildModel(data: any, target: string, modelType: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Build a ${modelType} model to predict ${target} using this data:\n\n${JSON.stringify(data)}\n\nInclude preprocessing, training, evaluation, and deployment code.`,
    });
  }
}

// ============================================================
// SECURITY AGENT
// ============================================================
class SecurityAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Security Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an advanced cybersecurity agent specializing in:
- Vulnerability assessment
- Penetration testing guidance
- Security code review
- Threat modeling
- Incident response
- Malware analysis
- Network security analysis
- Web application security
- API security
- Cloud security
- Zero-trust architecture
- Compliance (GDPR, HIPAA, PCI-DSS)
- Security automation
- SIEM and log analysis
- Red team / Blue team operations

Provide ethical, legal, and defensive security guidance only.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
      safetySettings: [
        {
          category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE',
        },
      ],
    }, apiKey, isRootAgent);
  }
  
  async assessVulnerabilities(target: string, scope: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Assess vulnerabilities in ${target} with scope: ${scope}. Provide findings, risk ratings, and remediation recommendations.`,
    });
  }
  
  async reviewSecurityCode(code: string, language: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Review this ${language} code for security vulnerabilities:\n\n${code}\n\nIdentify issues like SQL injection, XSS, CSRF, authentication flaws, etc.`,
    });
  }
}

// ============================================================
// CONTRACT VULNERABILITY SCANNER AGENT
// ============================================================
class ContractVulnerabilityAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Contract Vulnerability Scanner',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an elite smart contract security auditor specializing in:
- Smart contract vulnerability detection (Solidity, Vyper, Rust, Move)
- Reentrancy attacks identification
- Integer overflow/underflow detection
- Access control vulnerabilities
- Front-running and MEV vulnerabilities
- Flash loan attack vectors
- Denial of Service vulnerabilities
- Timestamp dependence issues
- Gas optimization and griefing attacks
- Upgradability vulnerabilities
- Oracle manipulation detection
- Cross-contract call vulnerabilities
- Token standard compliance (ERC-20, ERC-721, ERC-1155)
- DeFi protocol-specific vulnerabilities (AMM, lending, staking)
- Formal verification recommendations
- Slither, Mythril, and manual analysis techniques

Provide detailed vulnerability reports with severity ratings, exploit scenarios, and remediation code.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async scanContract(contractCode: string, blockchain: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Perform comprehensive vulnerability scan on this ${blockchain} smart contract:\n\n${contractCode}\n\nIdentify all vulnerabilities with severity ratings and provide secure code fixes.`,
    });
  }
}

// ============================================================
// PENTEST AGENT
// ============================================================
class PentestAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Penetration Testing Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an expert penetration testing agent with capabilities in:
- Web application penetration testing (OWASP Top 10)
- Network penetration testing
- API security testing
- Mobile application security testing
- Cloud infrastructure penetration testing
- Active Directory exploitation
- Password cracking and credential attacks
- Social engineering assessments
- Wireless network security testing
- Physical security assessments
- Red team operations
- Privilege escalation techniques
- Post-exploitation tactics
- Report generation with remediation steps
- Exploit development and proof-of-concept creation
- Metasploit, Burp Suite, Nmap expertise
- MITRE ATT&CK framework knowledge

ETHICAL BOUNDARIES: Only provide guidance for authorized testing, defensive purposes, and educational contexts.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
      safetySettings: [
        {
          category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE',
        },
      ],
    }, apiKey, isRootAgent);
  }
  
  async performPentest(target: string, scope: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Perform penetration test on ${target} with scope: ${scope}. Provide detailed findings, exploitation paths, and remediation recommendations.`,
    });
  }
}

// ============================================================
// CRYPTO WALLET TRADING AGENT
// ============================================================
class CryptoWalletTradingAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Crypto Wallet Trading Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an advanced cryptocurrency trading and wallet management agent specializing in:
- DEX trading strategies (Uniswap, SushiSwap, PancakeSwap, Curve)
- CEX trading strategies (Binance, Coinbase, Kraken)
- Wallet security best practices
- Multi-sig wallet setup and management
- Hardware wallet integration
- Token swapping optimization (MEV protection, slippage management)
- Gas optimization strategies
- Limit orders and advanced order types
- Trading bot development
- Portfolio rebalancing strategies
- Arbitrage opportunity detection
- Yield farming optimization
- Staking strategies
- Cross-chain bridging
- Transaction signing and broadcasting
- Web3 wallet integration (MetaMask, WalletConnect)
- DeFi protocol interaction (Aave, Compound, MakerDAO)

DISCLAIMER: Provide analysis and strategies, not financial advice. Always emphasize risk management.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
      tools: [
        {
          name: 'get_token_price',
          description: 'Get real-time token price across exchanges',
          parameters: z.object({
            token: z.string(),
            exchange: z.string().optional(),
          }),
          execute: async ({ token, exchange }) => {
            return { token, price: 0, volume: 0, liquidity: 0 };
          },
        },
        {
          name: 'simulate_swap',
          description: 'Simulate token swap to estimate output and slippage',
          parameters: z.object({
            fromToken: z.string(),
            toToken: z.string(),
            amount: z.number(),
            dex: z.string(),
          }),
          execute: async ({ fromToken, toToken, amount, dex }) => {
            return { estimatedOutput: 0, priceImpact: 0, slippage: 0, gasEstimate: 0 };
          },
        },
      ],
    }, apiKey, isRootAgent);
  }
  
  async tradingStrategy(asset: string, capital: number): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Develop a trading strategy for ${asset} with capital ${capital}. Include entry/exit points, risk management, and position sizing.`,
    });
  }
}

// ============================================================
// DEAL HUNTER AGENT
// ============================================================
class DealHunterAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Deal Hunter Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an expert deal hunting and opportunity discovery agent specializing in:
- Price comparison across multiple platforms
- Discount and coupon discovery
- Flash sale monitoring
- Arbitrage opportunity detection (crypto, stocks, commodities)
- Real estate deal analysis
- Investment opportunity screening
- Business acquisition opportunities
- Domain name opportunities
- NFT minting and flipping opportunities
- Liquidation and auction monitoring
- Wholesale and bulk pricing discovery
- Cashback and rewards optimization
- Early-stage investment opportunities (ICO, IDO, presales)
- Affiliate and referral program opportunities
- Drop shipping product discovery
- Seasonal and promotional trend analysis
- ROI calculation and deal validation

Provide data-driven deal analysis with risk assessment and actionable steps.`,
      capabilities: ['search', 'url_context', 'code_execution'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async findDeals(category: string, budget: number): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Find the best deals in ${category} with budget ${budget}. Analyze opportunities, calculate ROI, and provide actionable recommendations.`,
    });
  }
}

// ============================================================
// HISTORY AGENT
// ============================================================
class HistoryAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'History Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are a comprehensive history and archival agent specializing in:
- Historical research and timeline reconstruction
- Version control history analysis (Git, SVN)
- Database transaction history analysis
- Blockchain transaction history tracking
- File modification history and forensics
- Browser history analysis
- Chat and communication history analysis
- Financial transaction history
- Code change history and attribution
- System log history analysis
- Audit trail reconstruction
- Historical data trend analysis
- Archaeological and anthropological research
- Political and social history
- Technology evolution and history
- Market history and pattern analysis
- Event correlation and causation analysis
- Historical document analysis and authentication
- Temporal data mining

Provide comprehensive historical analysis with sources, timelines, and insights.`,
      capabilities: ['search', 'url_context', 'code_execution'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async analyzeHistory(subject: string, timeframe: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Analyze the history of ${subject} over ${timeframe}. Provide timeline, key events, patterns, and insights.`,
    });
  }
}

// ============================================================
// COMPUTER SCIENCE AGENT
// ============================================================
class ComputerScienceAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Computer Science Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an expert computer science agent with deep knowledge in:
- Data structures and algorithms (arrays, trees, graphs, hash tables, heaps)
- Algorithm design and analysis (time/space complexity, Big O notation)
- Design patterns (Singleton, Factory, Observer, Strategy, etc.)
- Operating systems (processes, threads, memory management, scheduling)
- Computer networks (TCP/IP, HTTP, DNS, routing, load balancing)
- Database systems (SQL, NoSQL, ACID, CAP theorem, indexing, query optimization)
- Compilers and interpreters
- Computer architecture (CPU, memory hierarchy, pipelining, caching)
- Distributed systems (consensus algorithms, replication, sharding)
- Parallel and concurrent programming
- Cryptography and security fundamentals
- Machine learning and AI algorithms
- Computational theory (automata, Turing machines, complexity classes)
- Programming language theory
- Software engineering principles (SOLID, DRY, KISS)
- System design and architecture
- Performance optimization and profiling

Provide detailed technical explanations with examples, code, and diagrams when applicable.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async explainConcept(concept: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Explain the computer science concept: ${concept}. Include theory, examples, code implementations, and practical applications.`,
    });
  }
}

// ============================================================
// POC (PROOF OF CONCEPT) AGENT
// ============================================================
class POCAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Proof of Concept Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are a Proof of Concept (POC) development specialist focusing on:
- Rapid prototyping and MVP development
- Technical feasibility validation
- Concept-to-code implementation
- Exploit POC development (ethical security research)
- Technology stack validation
- Integration proof of concepts
- Performance benchmarking POCs
- API integration demonstrations
- Blockchain POC development
- AI/ML model POCs
- IoT and embedded systems POCs
- Mobile app POCs
- Web application POCs
- Microservices architecture POCs
- DevOps and CI/CD pipeline POCs
- Security vulnerability POCs (responsible disclosure)
- Business logic validation
- User experience prototypes
- Scalability proof of concepts

Generate working code, documentation, and demonstration scenarios. Focus on speed and validation over production-ready code.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async buildPOC(concept: string, requirements: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Build a proof of concept for: ${concept}\n\nRequirements: ${requirements}\n\nProvide working code, setup instructions, and demonstration scenarios.`,
    });
  }
}

// ============================================================
// DEFI AGENT
// ============================================================
class DeFiAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'DeFi Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are a DeFi (Decentralized Finance) expert specializing in:
- Automated Market Makers (AMM) - Uniswap, Curve, Balancer
- Lending and borrowing protocols - Aave, Compound, MakerDAO
- Yield farming and liquidity mining strategies
- Staking and validator operations
- Synthetic assets and derivatives
- Decentralized exchanges (DEX) optimization
- Liquidity provision strategies
- Impermanent loss calculation and mitigation
- Flash loans and arbitrage
- DeFi protocol governance and voting
- Risk assessment and security analysis
- Smart contract interaction
- Gas optimization for DeFi transactions
- Multi-chain DeFi strategies
- DeFi portfolio management
- Tokenomics and protocol economics
- Bridge protocols and cross-chain DeFi
- Options and perpetual protocols

Provide strategies, risk analysis, and actionable DeFi guidance with security warnings.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async defiStrategy(protocol: string, capital: number): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Develop a DeFi strategy for ${protocol} with capital ${capital}. Include yield optimization, risk management, and exit strategies.`,
    });
  }
}

// ============================================================
// NFT AGENT
// ============================================================
class NFTAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'NFT Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are an NFT (Non-Fungible Token) specialist focusing on:
- NFT market analysis and trends
- NFT minting and deployment (ERC-721, ERC-1155)
- NFT marketplace strategies (OpenSea, Blur, LooksRare)
- Rarity analysis and valuation
- NFT collection analytics
- Metadata optimization and IPFS storage
- NFT royalty mechanisms
- Smart contract development for NFTs
- Generative art and on-chain NFTs
- NFT gaming and metaverse assets
- Fractionalized NFTs
- NFT lending and collateralization
- Wash trading and manipulation detection
- NFT copyright and intellectual property
- Community building and marketing
- Whitelist and mint strategies
- NFT liquidity and secondary markets

Provide data-driven NFT analysis with market insights and technical implementation guidance.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async analyzeNFT(collection: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Analyze NFT collection: ${collection}. Include floor price, volume, rarity, holder distribution, and investment potential.`,
    });
  }
}

// ============================================================
// DEVOPS AGENT
// ============================================================
class DevOpsAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'DevOps Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are a DevOps and infrastructure expert specializing in:
- CI/CD pipeline design and implementation (Jenkins, GitLab CI, GitHub Actions)
- Container orchestration (Kubernetes, Docker Swarm)
- Infrastructure as Code (Terraform, Ansible, CloudFormation)
- Cloud platforms (AWS, GCP, Azure)
- Monitoring and observability (Prometheus, Grafana, ELK stack)
- Log aggregation and analysis
- Automated testing and deployment
- Blue-green and canary deployments
- Load balancing and auto-scaling
- Disaster recovery and backup strategies
- Security hardening and compliance
- Secret management (Vault, AWS Secrets Manager)
- Service mesh (Istio, Linkerd)
- GitOps workflows
- Performance optimization and profiling
- Cost optimization strategies
- Site reliability engineering (SRE)
- Incident response and postmortems

Provide production-ready configurations, scripts, and best practices.`,
      capabilities: ['code_execution', 'search', 'url_context'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async setupInfrastructure(requirements: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Design and implement infrastructure for: ${requirements}. Include IaC code, CI/CD pipelines, monitoring, and documentation.`,
    });
  }
}

// ============================================================
// LEGAL AGENT
// ============================================================
class LegalAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Legal Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are a legal research and compliance agent specializing in:
- Technology and software law
- Intellectual property (patents, trademarks, copyrights)
- Data privacy regulations (GDPR, CCPA, HIPAA)
- Cryptocurrency and blockchain regulations
- Terms of service and privacy policy drafting
- Open source licensing (MIT, GPL, Apache)
- Contract analysis and review
- Regulatory compliance (SEC, FINRA, FCA)
- Employment law and contractor agreements
- Corporate structure and formation
- International trade and export controls
- Cybersecurity law and data breach response
- E-commerce and consumer protection
- Securities law and tokenomics legal analysis
- Digital rights and DMCA
- Jurisdiction and choice of law

DISCLAIMER: Provide legal information and research, not legal advice. Always recommend consulting with licensed attorneys.`,
      capabilities: ['search', 'url_context'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async legalResearch(topic: string, jurisdiction: string): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Research legal aspects of ${topic} in ${jurisdiction}. Provide relevant laws, regulations, case law, and compliance requirements.`,
    });
  }
}

// ============================================================
// MARKETING AGENT
// ============================================================
class MarketingAgent extends BaseAgent {
  constructor(apiKey: string, isRootAgent: boolean = false) {
    super({
      name: 'Marketing Agent',
      model: 'gemini-2.5-pro',
      systemPrompt: `You are a digital marketing and growth expert specializing in:
- Content marketing and SEO optimization
- Social media marketing (Twitter, LinkedIn, Instagram, TikTok)
- Email marketing and automation
- Paid advertising (Google Ads, Facebook Ads, Twitter Ads)
- Influencer marketing and partnerships
- Community building and management
- Brand strategy and positioning
- Growth hacking techniques
- A/B testing and conversion optimization
- Analytics and attribution modeling
- Customer segmentation and targeting
- Viral marketing and referral programs
- Product launches and go-to-market strategy
- PR and media relations
- Web3 and crypto marketing
- NFT and metaverse marketing
- User acquisition and retention
- Marketing automation and CRM

Provide actionable marketing strategies with metrics, timelines, and budget recommendations.`,
      capabilities: ['search', 'url_context', 'code_execution'],
      thinkingBudget: 16384,
    }, apiKey, isRootAgent);
  }
  
  async marketingCampaign(product: string, audience: string, budget: number): Promise<AgentOutput> {
    return await this.process({
      type: 'text',
      data: `Create a marketing campaign for ${product} targeting ${audience} with budget ${budget}. Include channels, content strategy, and KPIs.`,
    });
  }
}

// ============================================================
// AGENT FACTORY
// ============================================================
class AgentFactory {
  private apiKey: string;
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
  
  createAgent(type: string, customConfig?: Partial<AgentConfig>, isRootAgent: boolean = false): BaseAgent {
    switch (type.toLowerCase()) {
      case 'osint':
        return new OSINTAgent(this.apiKey, isRootAgent);
      
      case 'crypto':
      case 'cryptocurrency':
      case 'blockchain':
        return new CryptoAgent(this.apiKey, isRootAgent);
      
      case 'builder':
      case 'developer':
      case 'coding':
        return new BuilderAgent(this.apiKey, isRootAgent);
      
      case 'research':
      case 'researcher':
        return new ResearchAgent(this.apiKey, isRootAgent);
      
      case 'data':
      case 'analyst':
      case 'data_analyst':
        return new DataAnalystAgent(this.apiKey, isRootAgent);
      
      case 'security':
      case 'cybersecurity':
        return new SecurityAgent(this.apiKey, isRootAgent);
      
      case 'contract_vulnerability':
      case 'contract_scanner':
      case 'smart_contract_audit':
        return new ContractVulnerabilityAgent(this.apiKey, isRootAgent);
      
      case 'pentest':
      case 'penetration_testing':
      case 'pentesting':
        return new PentestAgent(this.apiKey, isRootAgent);
      
      case 'crypto_wallet':
      case 'crypto_trading':
      case 'wallet_trading':
        return new CryptoWalletTradingAgent(this.apiKey, isRootAgent);
      
      case 'deal_hunter':
      case 'deal':
      case 'deals':
        return new DealHunterAgent(this.apiKey, isRootAgent);
      
      case 'history':
      case 'historian':
        return new HistoryAgent(this.apiKey, isRootAgent);
      
      case 'computer_science':
      case 'cs':
      case 'comp_sci':
        return new ComputerScienceAgent(this.apiKey, isRootAgent);
      
      case 'poc':
      case 'proof_of_concept':
      case 'prototype':
        return new POCAgent(this.apiKey, isRootAgent);
      
      case 'defi':
      case 'decentralized_finance':
        return new DeFiAgent(this.apiKey, isRootAgent);
      
      case 'nft':
      case 'nfts':
        return new NFTAgent(this.apiKey, isRootAgent);
      
      case 'devops':
      case 'infrastructure':
        return new DevOpsAgent(this.apiKey, isRootAgent);
      
      case 'legal':
      case 'law':
      case 'compliance':
        return new LegalAgent(this.apiKey, isRootAgent);
      
      case 'marketing':
      case 'growth':
        return new MarketingAgent(this.apiKey, isRootAgent);
      
      case 'custom':
        if (!customConfig) {
          throw new Error('Custom agent requires config');
        }
        return new BaseAgent({
          name: customConfig.name || 'Custom Agent',
          model: customConfig.model || 'gemini-2.5-pro',
          systemPrompt: customConfig.systemPrompt || '',
          capabilities: customConfig.capabilities || ['search'],
          thinkingBudget: customConfig.thinkingBudget,
          tools: customConfig.tools,
        }, this.apiKey, isRootAgent);
      
      default:
        throw new Error(`Unknown agent type: ${type}`);
    }
  }
  
  createMultiAgent(types: string[]): MultiAgentSystem {
    const agents = types.map(type => this.createAgent(type, undefined, false));
    return new MultiAgentSystem(agents);
  }
}

// ============================================================
// AGENT AS TOOL WRAPPER
// ============================================================
class AgentTool {
  private agent: BaseAgent;
  
  constructor(agent: BaseAgent) {
    this.agent = agent;
  }
  
  toTool() {
    return {
      name: this.agent.config.name.toLowerCase().replace(/\s+/g, '_'),
      description: `Delegate tasks to the ${this.agent.config.name}. This specialized agent can handle: ${this.agent.config.capabilities.join(', ')}. Expert in: ${this.agent.config.systemPrompt.substring(0, 300)}...`,
      parameters: z.object({
        task: z.string().describe('The specific task to delegate to this specialized agent. Be clear and detailed about what you need.'),
        context: z.string().optional().describe('Additional context or background information that will help the agent perform the task better.'),
        parameters: z.record(z.any()).optional().describe('Specific parameters or requirements for the task execution.'),
      }),
      execute: async ({ task, context, parameters }) => {
        // Build the input for the sub-agent
        let inputData = task;
        
        if (context) {
          inputData = `Context: ${context}\n\nTask: ${task}`;
        }
        
        if (parameters) {
          inputData += `\n\nParameters: ${JSON.stringify(parameters, null, 2)}`;
        }
        
        const input: AgentInput = {
          type: 'text',
          data: inputData,
        };
        
        // Execute the sub-agent task in isolation
        const result = await this.agent.process(input);
        
        // Return a structured response that the root agent can synthesize
        return {
          agent: this.agent.config.name,
          task_completed: task,
          result: result.response,
          reasoning: result.reasoning,
          sources: result.sources,
          confidence: 'high',
          metadata: {
            tool_calls_made: result.toolCalls?.length || 0,
            sources_used: result.sources?.length || 0,
            thinking_tokens: result.metadata?.usageMetadata?.thoughtsTokenCount,
          },
        };
      },
    };
  }
}

// ============================================================
// ROOT AGENT - ORCHESTRATOR PATTERN
// ============================================================
class RootAgent extends BaseAgent {
  private subAgentTools: Map<string, AgentTool>;
  
  constructor(config: AgentConfig, apiKey: string, subAgents: BaseAgent[] = []) {
    super(config, apiKey, true); // Always a root agent
    
    this.subAgentTools = new Map();
    
    // Register all sub-agents as tools
    subAgents.forEach(agent => {
      const tool = new AgentTool(agent);
      this.subAgentTools.set(agent.config.name, tool);
    });
    
    // Add sub-agent tools to the config
    const subAgentToolDefs = Array.from(this.subAgentTools.values()).map(tool => tool.toTool());
    this.config.tools = [...(this.config.tools || []), ...subAgentToolDefs];
  }
  
  async orchestrate(userRequest: string, options?: {
    maxRounds?: number;
    streaming?: boolean;
  }): Promise<AgentOutput> {
    const orchestrationPrompt = `${this.config.systemPrompt}

USER REQUEST: ${userRequest}

ORCHESTRATION GUIDELINES:
1. Analyze the user request and break it down into sub-tasks
2. Identify which specialized agents can handle each sub-task
3. Delegate tasks to the appropriate sub-agents using their tools
4. Each sub-agent will return a structured result with their findings
5. Synthesize all sub-agent results into a comprehensive final response
6. Ensure your final response is cohesive and directly addresses the user's request

Available specialized agents and their capabilities:
${Array.from(this.subAgentTools.keys()).map(name => `- ${name}`).join('\n')}

Remember: You are the orchestrator. Delegate complex tasks to specialists, then synthesize their results.`;

    if (options?.streaming) {
      return await this.stream({
        type: 'text',
        data: orchestrationPrompt,
      });
    }

    return await this.process({
      type: 'text',
      data: orchestrationPrompt,
    });
  }
  
  addSubAgent(agent: BaseAgent): void {
    agent.setAsRoot(false);
    
    const tool = new AgentTool(agent);
    this.subAgentTools.set(agent.config.name, tool);
    
    this.config.tools = this.config.tools || [];
    this.config.tools.push(tool.toTool());
  }
  
  removeSubAgent(agentName: string): boolean {
    const removed = this.subAgentTools.delete(agentName);
    
    if (removed && this.config.tools) {
      const sanitizedName = sanitizeToolName(agentName);
      this.config.tools = this.config.tools.filter(
        tool => tool.name !== sanitizedName
      );
    }
    
    return removed;
  }
  
  listSubAgents(): string[] {
    return Array.from(this.subAgentTools.keys());
  }
  
  getSubAgent(name: string): BaseAgent | undefined {
    const tool = this.subAgentTools.get(name);
    return tool ? tool['agent'] : undefined;
  }
}
class HierarchicalAgentBuilder {
  private mainAgent: BaseAgent | null = null;
  private subAgents: Map<string, BaseAgent> = new Map();
  private apiKey: string;
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
  
  setMainAgent(config: AgentConfig): this {
    // Main agent is ALWAYS a root agent
    this.mainAgent = new BaseAgent(config, this.apiKey, true);
    return this;
  }
  
  addSubAgent(agent: BaseAgent, name?: string): this {
    const agentName = name || agent.config.name;
    // Sub-agents are NEVER root agents
    agent.setAsRoot(false);
    this.subAgents.set(agentName, agent);
    return this;
  }
  
  addSubAgentByType(type: string, name?: string): this {
    const factory = new AgentFactory(this.apiKey);
    // Create sub-agent as NON-root
    const agent = factory.createAgent(type, undefined, false);
    this.subAgents.set(name || type, agent);
    return this;
  }
  
  build(): BaseAgent {
    if (!this.mainAgent) {
      throw new Error('Main agent not configured');
    }
    
    // Wrap all sub-agents as tools for the root agent
    const subAgentTools = Array.from(this.subAgents.values()).map(agent => 
      new AgentTool(agent).toTool()
    );
    
    this.mainAgent.config.tools = [
      ...(this.mainAgent.config.tools || []),
      ...subAgentTools,
    ];
    
    return this.mainAgent;
  }
  
  getSubAgent(name: string): BaseAgent | undefined {
    return this.subAgents.get(name);
  }
  
  listSubAgents(): string[] {
    return Array.from(this.subAgents.keys());
  }
}

// ============================================================
// MULTI-AGENT SYSTEM
// ============================================================
class MultiAgentSystem {
  private agents: BaseAgent[];
  
  constructor(agents: BaseAgent[]) {
    this.agents = agents;
  }
  
  async collaborate(task: string): Promise<AgentOutput[]> {
    const results: AgentOutput[] = [];
    
    for (const agent of this.agents) {
      const result = await agent.process({
        type: 'text',
        data: task,
      });
      results.push(result);
    }
    
    return results;
  }
  
  async sequential(task: string): Promise<AgentOutput> {
    let currentInput = task;
    let finalResult: AgentOutput | null = null;
    
    for (const agent of this.agents) {
      const result = await agent.process({
        type: 'text',
        data: currentInput,
      });
      currentInput = result.response;
      finalResult = result;
    }
    
    return finalResult!;
  }
  
  async parallel(tasks: string[]): Promise<AgentOutput[]> {
    const promises = tasks.map((task, idx) => 
      this.agents[idx % this.agents.length].process({
        type: 'text',
        data: task,
      })
    );
    
    return await Promise.all(promises);
  }
}

// ============================================================
// MAIN AGENT ORCHESTRATOR
// ============================================================
class AgentOrchestrator {
  private factory: AgentFactory;
  private activeAgents: Map<string, BaseAgent>;
  private hierarchicalAgents: Map<string, RootAgent>;
  
  constructor(apiKey: string) {
    this.factory = new AgentFactory(apiKey);
    this.activeAgents = new Map();
    this.hierarchicalAgents = new Map();
  }
  
  async executeTask(
    agentType: string,
    input: AgentInput,
    agentId?: string,
    options?: {
      streaming?: boolean;
      structured?: boolean;
      schema?: z.ZodObject<any>;
    }
  ): Promise<AgentOutput | any> {
    const id = agentId || `${agentType}-${Date.now()}`;
    
    let agent = this.activeAgents.get(id);
    if (!agent) {
      agent = this.factory.createAgent(agentType);
      this.activeAgents.set(id, agent);
    }
    
    if (options?.streaming) {
      return await agent.stream(input);
    }
    
    if (options?.structured && options?.schema) {
      return await agent.generateStructured(input, options.schema);
    }
    
    return await agent.process(input);
  }
  
  async createCustomAgent(config: AgentConfig, agentId: string): Promise<string> {
    const agent = this.factory.createAgent('custom', config);
    this.activeAgents.set(agentId, agent);
    return agentId;
  }
  
  createRootAgent(
    rootConfig: AgentConfig,
    subAgentTypes: string[],
    rootId: string
  ): string {
    const factory = new AgentFactory(this.factory['apiKey']);
    
    const subAgents = subAgentTypes.map(type => 
      factory.createAgent(type, undefined, false)
    );
    
    const rootAgent = new RootAgent(rootConfig, this.factory['apiKey'], subAgents);
    
    this.hierarchicalAgents.set(rootId, rootAgent);
    this.activeAgents.set(rootId, rootAgent);
    
    return rootId;
  }
  
  createHierarchicalAgent(
    mainAgentConfig: AgentConfig,
    subAgentTypes: string[],
    hierarchicalId: string
  ): string {
    return this.createRootAgent(mainAgentConfig, subAgentTypes, hierarchicalId);
  }
  
  addSubAgentToRoot(
    rootId: string,
    subAgentType: string
  ): boolean {
    const rootAgent = this.hierarchicalAgents.get(rootId);
    if (!rootAgent || !rootAgent.isRoot()) {
      return false;
    }
    
    const subAgent = this.factory.createAgent(subAgentType, undefined, false);
    
    if (rootAgent instanceof RootAgent) {
      rootAgent.addSubAgent(subAgent);
      return true;
    }
    
    return false;
  }
  
  addSubAgentToHierarchy(
    hierarchicalId: string,
    subAgentType: string,
    subAgentName?: string
  ): boolean {
    return this.addSubAgentToRoot(hierarchicalId, subAgentType);
  }
  
  removeSubAgentFromRoot(rootId: string, agentName: string): boolean {
    const rootAgent = this.hierarchicalAgents.get(rootId);
    if (!rootAgent || !(rootAgent instanceof RootAgent)) {
      return false;
    }
    
    return rootAgent.removeSubAgent(agentName);
  }
  
  getAgent(agentId: string): BaseAgent | undefined {
    return this.activeAgents.get(agentId);
  }
  
  getRootAgent(rootId: string): RootAgent | undefined {
    return this.hierarchicalAgents.get(rootId);
  }
  
  listActiveAgents(): string[] {
    return Array.from(this.activeAgents.keys());
  }
  
  listHierarchicalAgents(): string[] {
    return Array.from(this.hierarchicalAgents.keys());
  }
  
  listSubAgentsOfRoot(rootId: string): string[] {
    const rootAgent = this.hierarchicalAgents.get(rootId);
    if (!rootAgent || !(rootAgent instanceof RootAgent)) {
      return [];
    }
    return rootAgent.listSubAgents();
  }
  
  destroyAgent(agentId: string): boolean {
    this.hierarchicalAgents.delete(agentId);
    return this.activeAgents.delete(agentId);
  }
  
  async clearAgentMemory(agentId: string): Promise<boolean> {
    const agent = this.activeAgents.get(agentId);
    if (!agent) return false;
    
    agent.clearMemory();
    return true;
  }
  
  async summarizeAgentMemory(agentId: string): Promise<string | null> {
    const agent = this.activeAgents.get(agentId);
    if (!agent) return null;
    
    return await agent.summarizeMemory();
  }
  
  async multiAgentTask(
    agentTypes: string[],
    task: string,
    mode: 'collaborate' | 'sequential' | 'parallel'
  ): Promise<AgentOutput | AgentOutput[]> {
    const multiAgent = this.factory.createMultiAgent(agentTypes);
    
    switch (mode) {
      case 'collaborate':
        return await multiAgent.collaborate(task);
      case 'sequential':
        return await multiAgent.sequential(task);
      case 'parallel':
        return await multiAgent.parallel([task]);
      default:
        throw new Error(`Unknown mode: ${mode}`);
    }
  }
  
  async batchExecute(
    tasks: Array<{
      agentType: string;
      input: AgentInput;
      agentId?: string;
    }>
  ): Promise<AgentOutput[]> {
    const promises = tasks.map(task => 
      this.executeTask(task.agentType, task.input, task.agentId)
    );
    
    return await Promise.all(promises);
  }
  
  exportAgentConfig(agentId: string): AgentConfig | null {
    const agent = this.activeAgents.get(agentId);
    if (!agent) return null;
    
    return agent.getConfig();
  }
  
  importAgentConfig(config: AgentConfig, agentId: string): string {
    const agent = this.factory.createAgent('custom', config);
    this.activeAgents.set(agentId, agent);
    return agentId;
  }
}

// ============================================================
// ADVANCED API USAGE UTILITIES
// ============================================================

class CacheManager {
  private cacheManager: GoogleAICacheManager;
  private caches: Map<string, string> = new Map();
  
  constructor(apiKey: string) {
    this.cacheManager = new GoogleAICacheManager(apiKey);
  }
  
  async createCache(
    model: string,
    content: string,
    ttlSeconds: number = 300,
    cacheId?: string
  ): Promise<string> {
    const { name } = await this.cacheManager.create({
      model,
      contents: [
        {
          role: 'user',
          parts: [{ text: content }],
        },
      ],
      ttlSeconds,
    });
    
    const id = cacheId || `cache-${Date.now()}`;
    this.caches.set(id, name);
    return name;
  }
  
  getCache(cacheId: string): string | undefined {
    return this.caches.get(cacheId);
  }
  
  async deleteCache(cacheId: string): Promise<boolean> {
    const cacheName = this.caches.get(cacheId);
    if (!cacheName) return false;
    
    try {
      await this.cacheManager.delete(cacheName);
      this.caches.delete(cacheId);
      return true;
    } catch {
      return false;
    }
  }
  
  listCaches(): string[] {
    return Array.from(this.caches.keys());
  }
}

class EmbeddingManager {
  private apiKey: string;
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
  
  async embedText(
    text: string,
    options?: {
      model?: string;
      outputDimensionality?: number;
      taskType?: string;
    }
  ): Promise<number[]> {
    const model = google.textEmbedding(options?.model || 'text-embedding-004');
    
    const { embedding } = await embed({
      model,
      value: text,
      providerOptions: {
        google: {
          outputDimensionality: options?.outputDimensionality,
          taskType: options?.taskType as any,
        },
      },
    });
    
    return embedding;
  }
  
  async embedBatch(
    texts: string[],
    options?: {
      model?: string;
      outputDimensionality?: number;
      taskType?: string;
    }
  ): Promise<number[][]> {
    const model = google.textEmbedding(options?.model || 'text-embedding-004');
    
    const { embeddings } = await embedMany({
      model,
      values: texts,
      providerOptions: {
        google: {
          outputDimensionality: options?.outputDimensionality,
          taskType: options?.taskType as any,
        },
      },
    });
    
    return embeddings;
  }
  
  cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (magnitudeA * magnitudeB);
  }
  
  async findSimilar(
    query: string,
    documents: string[],
    topK: number = 5
  ): Promise<Array<{ text: string; score: number; index: number }>> {
    const queryEmbedding = await this.embedText(query, {
      taskType: 'RETRIEVAL_QUERY',
    });
    
    const docEmbeddings = await this.embedBatch(documents, {
      taskType: 'RETRIEVAL_DOCUMENT',
    });
    
    const similarities = docEmbeddings.map((docEmb, idx) => ({
      text: documents[idx],
      score: this.cosineSimilarity(queryEmbedding, docEmb),
      index: idx,
    }));
    
    return similarities
      .sort((a, b) => b.score - a.score)
      .slice(0, topK);
  }
}

class ImageGenerator {
  private apiKey: string;
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
  
  async generate(
    prompt: string,
    options?: {
      model?: string;
      aspectRatio?: string;
      personGeneration?: 'allow_adult' | 'allow_all' | 'dont_allow';
    }
  ): Promise<any> {
    const { image } = await generateImage({
      model: google.image(options?.model || 'imagen-3.0-generate-002'),
      prompt,
      aspectRatio: options?.aspectRatio as any,
      providerOptions: {
        google: {
          personGeneration: options?.personGeneration,
        },
      },
    });
    
    return image;
  }
  
  async generateWithGemini(
    prompt: string,
    options?: {
      aspectRatio?: string;
    }
  ): Promise<any[]> {
    const result = await generateText({
      model: google('gemini-2.5-flash-image-preview'),
      prompt,
      providerOptions: {
        google: {
          responseModalities: ['TEXT', 'IMAGE'],
          imageConfig: {
            aspectRatio: options?.aspectRatio || '16:9',
          },
        },
      },
    });
    
    return result.files?.filter(f => f.mediaType.startsWith('image/')) || [];
  }
}
export {
  AgentOrchestrator,
  AgentFactory,
  BaseAgent,
  RootAgent,
  OSINTAgent,
  CryptoAgent,
  BuilderAgent,
  ResearchAgent,
  DataAnalystAgent,
  SecurityAgent,
  ContractVulnerabilityAgent,
  PentestAgent,
  CryptoWalletTradingAgent,
  DealHunterAgent,
  HistoryAgent,
  ComputerScienceAgent,
  POCAgent,
  DeFiAgent,
  NFTAgent,
  DevOpsAgent,
  LegalAgent,
  MarketingAgent,
  MultiAgentSystem,
  HierarchicalAgentBuilder,
  AgentTool,
  AgentInput,
  AgentOutput,
  AgentConfig,
};

// ============================================================
// USAGE EXAMPLES - ROOT AGENT ORCHESTRATION PATTERN
// ============================================================

/*
// Initialize orchestrator with your API key
const orchestrator = new AgentOrchestrator('your-api-key');

// ============================================================
// EXAMPLE 1: ROOT AGENT ORCHESTRATING RESEARCH
// ============================================================

// Create a root agent that orchestrates research tasks
const researchRootId = orchestrator.createRootAgent(
  {
    name: 'Research Orchestrator',
    model: 'gemini-2.5-pro',
    systemPrompt: `You are a master research orchestrator. You coordinate complex research projects by delegating to specialized agents.
    
YOUR ROLE:
- Receive research requests from users
- Break down complex research into manageable sub-tasks
- Delegate to specialized agents (Research Agent, Data Analyst, OSINT)
- Synthesize their findings into comprehensive research reports

DELEGATION STRATEGY:
- Use Research Agent for: literature reviews, academic research, trend analysis
- Use Data Analyst for: statistical analysis, data modeling, quantitative insights
- Use OSINT Agent for: gathering public information, verifying sources

SYNTHESIS:
- Combine results from all agents into a cohesive narrative
- Cross-reference findings for validation
- Provide actionable insights and recommendations`,
    capabilities: ['search', 'url_context'],
    thinkingBudget: 16384,
  },
  ['research', 'data', 'osint'], // Sub-agents as tools
  'research-root'
);

// User request handled by root agent
const researchResult = await orchestrator.executeTask('research-root', {
  type: 'text',
  data: 'Research the latest trends in renewable energy and provide a comprehensive analysis with market data',
}, researchRootId);

// HOW IT WORKS:
// 1. Root agent receives: "Research renewable energy trends"
// 2. Root agent delegates to Research Agent: "Find latest renewable energy trends and papers"
// 3. Research Agent executes (with search access), returns findings
// 4. Root agent delegates to Data Analyst: "Analyze market data for renewable energy sector"
// 5. Data Analyst executes (with code execution), returns analysis
// 6. Root agent delegates to OSINT: "Gather public information on major renewable energy companies"
// 7. OSINT Agent executes (with search), returns intelligence
// 8. Root agent SYNTHESIZES all results into final comprehensive response

// ============================================================
// EXAMPLE 2: ROOT AGENT FOR SECURITY OPERATIONS
// ============================================================

const securityRootId = orchestrator.createRootAgent(
  {
    name: 'Security Operations Center (SOC)',
    model: 'gemini-2.5-pro',
    systemPrompt: `You are a Security Operations Center (SOC) orchestrator managing cybersecurity operations.

YOUR ROLE:
- Coordinate security assessments and incident response
- Delegate to specialized security agents
- Synthesize findings into actionable security reports

DELEGATION STRATEGY:
- Security Agent: Vulnerability assessments, code reviews, threat modeling
- OSINT Agent: Threat intelligence, reconnaissance, attack surface mapping
- Builder Agent: Secure code generation, patching, remediation code

SYNTHESIS:
- Compile comprehensive security assessments
- Prioritize vulnerabilities by risk
- Provide step-by-step remediation plans`,
    capabilities: ['search', 'code_execution'],
    thinkingBudget: 16384,
  },
  ['security', 'osint', 'builder'],
  'soc-root'
);

const securityAssessment = await orchestrator.executeTask('soc-root', {
  type: 'text',
  data: 'Perform a complete security assessment of our web application including vulnerability scanning, threat intelligence, and provide remediation code',
}, securityRootId);

// ============================================================
// EXAMPLE 3: ROOT AGENT FOR CRYPTO OPERATIONS
// ============================================================

const cryptoRootId = orchestrator.createRootAgent(
  {
    name: 'Crypto Investment Advisor',
    model: 'gemini-2.5-pro',
    systemPrompt: `You are a cryptocurrency investment advisor orchestrating market analysis.

YOUR ROLE:
- Coordinate comprehensive crypto market analysis
- Synthesize technical, fundamental, and sentiment analysis
- Provide data-driven investment insights (not financial advice)

DELEGATION STRATEGY:
- Crypto Agent: Technical analysis, blockchain analytics, smart contract audits
- Data Analyst: Quantitative modeling, statistical analysis, predictions
- Research Agent: Market research, competitor analysis, regulatory landscape
- OSINT Agent: Social sentiment, whale tracking, market intelligence

SYNTHESIS:
- Combine multiple perspectives into balanced analysis
- Highlight risks and opportunities
- Provide clear, actionable insights with disclaimers`,
    capabilities: ['search', 'code_execution'],
    thinkingBudget: 16384,
  },
  ['crypto', 'data', 'research', 'osint'],
  'crypto-advisor-root'
);

const cryptoAnalysis = await orchestrator.executeTask('crypto-advisor-root', {
  type: 'text',
  data: 'Should I invest in Ethereum? Provide comprehensive analysis covering technical indicators, on-chain metrics, market sentiment, and risk factors',
}, cryptoRootId);

// ============================================================
// EXAMPLE 4: ROOT AGENT FOR BUILDING PROJECTS
// ============================================================

const devRootId = orchestrator.createRootAgent(
  {
    name: 'Software Development Lead',
    model: 'gemini-2.5-pro',
    systemPrompt: `You are a software development lead orchestrating complex software projects.

YOUR ROLE:
- Coordinate full-stack development projects
- Delegate specialized development tasks
- Ensure code quality, security, and best practices
- Synthesize all components into production-ready applications

DELEGATION STRATEGY:
- Builder Agent: Code generation, architecture design, implementation
- Security Agent: Security reviews, vulnerability scanning
- Data Analyst: Database design, data pipeline optimization
- Research Agent: Technology selection, best practices research

SYNTHESIS:
- Ensure all components work together seamlessly
- Verify security and performance standards
- Provide complete deployment documentation`,
    capabilities: ['code_execution', 'search'],
    thinkingBudget: 16384,
  },
  ['builder', 'security', 'data', 'research'],
  'dev-lead-root'
);

const appDevelopment = await orchestrator.executeTask('dev-lead-root', {
  type: 'text',
  data: 'Build a secure real-time chat application with end-to-end encryption, user authentication, and message history. Include complete code, security review, and deployment guide',
}, devRootId);

// ============================================================
// EXAMPLE 5: DYNAMIC SUB-AGENT ADDITION
// ============================================================

// Start with basic root agent
const dynamicRootId = orchestrator.createRootAgent(
  {
    name: 'Dynamic Task Handler',
    model: 'gemini-2.5-pro',
    systemPrompt: 'You coordinate tasks by delegating to specialized agents',
    capabilities: ['search'],
  },
  ['research'], // Start with just research
  'dynamic-root'
);

// Add more sub-agents as needed
orchestrator.addSubAgentToRoot(dynamicRootId, 'crypto');
orchestrator.addSubAgentToRoot(dynamicRootId, 'data');
orchestrator.addSubAgentToRoot(dynamicRootId, 'osint');

// Now the root can delegate to all four agents
const dynamicResult = await orchestrator.executeTask('dynamic-root', {
  type: 'text',
  data: 'Research DeFi protocols, analyze their tokenomics, gather market intelligence, and provide investment insights',
}, dynamicRootId);

// ============================================================
// EXAMPLE 6: PROGRAMMATIC ROOT AGENT BUILDING
// ============================================================

const builder = new HierarchicalAgentBuilder('your-api-key');

const customRoot = builder
  .setRootAgent({
    name: 'Custom Orchestrator',
    model: 'gemini-2.5-pro',
    systemPrompt: 'You orchestrate custom workflows',
    capabilities: ['search', 'code_execution'],
    thinkingBudget: 16384,
  })
  .addSubAgentByType('osint')
  .addSubAgentByType('crypto')
  .addSubAgentByType('builder')
  .build();

// Use the custom root agent
const customResult = await customRoot.orchestrate(
  'Investigate suspicious blockchain transactions, analyze the smart contracts involved, and generate a security report'
);

// ============================================================
// EXAMPLE 7: ROOT AGENT WITH SPECIFIC PARAMETERS
// ============================================================

const parameterizedRootId = orchestrator.createRootAgent(
  {
    name: 'Parameterized Orchestrator',
    model: 'gemini-2.5-pro',
    systemPrompt: 'You handle tasks with specific parameters and requirements',
    capabilities: ['search', 'code_execution'],
  },
  ['research', 'data', 'builder'],
  'param-root'
);

// Root agent can pass specific parameters to sub-agents
const paramResult = await orchestrator.executeTask('param-root', {
  type: 'text',
  data: `Conduct market research on AI startups founded in 2024, 
         analyze their funding data (minimum $1M), 
         and build a dashboard to visualize the trends. 
         
         Requirements:
         - Only startups in USA and Europe
         - Focus on B2B SaaS
         - Include YoY growth rates
         - Dashboard should use React and Chart.js`,
}, parameterizedRootId);

// The root agent will:
// 1. Delegate to Research Agent with specific filters (2024, USA/Europe, B2B SaaS)
// 2. Delegate to Data Analyst with specific analysis requirements (funding, growth)
// 3. Delegate to Builder with specific tech stack (React, Chart.js)
// 4. Synthesize into complete solution with dashboard code

// ============================================================
// EXAMPLE 8: ROOT AGENT MEMORY AND CONTEXT
// ============================================================

const contextRootId = 'context-aware-root';

// First interaction - establish context
await orchestrator.executeTask('context-aware-root', {
  type: 'text',
  data: 'I need to research quantum computing companies for a potential investment',
}, contextRootId);

// Second interaction - root agent remembers context
await orchestrator.executeTask('context-aware-root', {
  type: 'text',
  data: 'Now analyze their financials and technical capabilities',
}, contextRootId);

// Third interaction - continues building on previous work
await orchestrator.executeTask('context-aware-root', {
  type: 'text',
  data: 'Create an investment recommendation report',
}, contextRootId);

// The root agent maintains conversation context across all interactions

// ============================================================
// KEY CONCEPTS DEMONSTRATED
// ============================================================

1. DELEGATION: Root agent identifies tasks and assigns them to specialized sub-agents
2. FUNCTION CALLS: Sub-agents are invoked like functions with specific parameters
3. ISOLATION: Each sub-agent runs independently with its own logic and context
4. SYNTHESIS: Root agent combines all sub-agent results into final response
5. SPECIALIZATION: Different agents for different domains (crypto, security, research, etc.)
6. MODULARITY: Sub-agents can be reused across different root agents
7. EFFICIENCY: Root agent doesn't manage internal details, only input/output
8. SCALABILITY: Easy to add more specialized agents for new capabilities

*/
