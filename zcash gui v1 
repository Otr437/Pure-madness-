#!/usr/bin/env python3
"""
Production Zcash Node Manager with Real-Time Blockchain Monitoring
Based on Official Zcash Documentation
"""
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog, simpledialog
import json
import requests
import threading
import time
import subprocess
import shutil
from pathlib import Path
import platform
from datetime import datetime
from collections import deque
import secrets

class ProductionZcashNodeManager:
    # Official Zcash Brand Colors
    ZCASH_GOLD = "#F4B728"
    ZCASH_BLACK = "#231F20"
    ZCASH_DARK_GRAY = "#3A3A3A"
    ZCASH_GREEN = "#40C64D"
    ZCASH_RED = "#E74C3C"
    
    def __init__(self, root):
        self.root = root
        self.root.title("ğŸ›¡ï¸ Zcash Production Node Manager - LIVE BLOCKCHAIN MONITOR")
        self.root.geometry("1600x1000")
        self.root.configure(bg=self.ZCASH_BLACK)
        
        # Official Zcash paths per documentation
        self.zcash_dir = Path.home() / 'zcash'
        self.zcash_conf_dir = Path.home() / '.zcash'
        self.zcash_conf_file = self.zcash_conf_dir / 'zcash.conf'
        self.wallet_file = self.zcash_conf_dir / 'wallet.dat'
        self.zcashd_path = self.zcash_dir / 'src' / 'zcashd'
        self.zcash_cli_path = self.zcash_dir / 'src' / 'zcash-cli'
        
        # RPC Configuration
        self.rpc_url = "http://127.0.0.1:8232"
        self.rpc_user = "zcashgui"
        self.rpc_password = ""
        
        # Real-time monitoring state
        self.monitoring_active = False
        self.monitor_thread = None
        self.last_block_height = 0
        self.last_block_hash = ""
        self.connection_status = "Disconnected"
        self.sync_progress = 0.0
        self.current_peers = 0
        self.mempool_count = 0
        self.network_hashrate = 0
        
        # Performance metrics history
        self.metrics_history = {
            'blocks': deque(maxlen=100),
            'peers': deque(maxlen=100),
            'mempool_size': deque(maxlen=100),
            'timestamps': deque(maxlen=100)
        }
        
        # Recent blocks for visual display
        self.recent_blocks = deque(maxlen=20)
        self.node_process = None
        
        self.setup_styles()
        self.setup_gui()
        self.detect_system()
        self.load_rpc_config()
    
    def setup_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
        style.configure('Zcash.TFrame', background=self.ZCASH_BLACK)
        style.configure('ZcashGold.TLabel', background=self.ZCASH_BLACK, foreground=self.ZCASH_GOLD, font=('Arial', 10, 'bold'))
        style.configure('ZcashWhite.TLabel', background=self.ZCASH_BLACK, foreground='white', font=('Arial', 9))
        style.configure('ZcashGold.TButton', background=self.ZCASH_GOLD, foreground=self.ZCASH_BLACK, font=('Arial', 9, 'bold'))
    
    def setup_gui(self):
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.setup_installation_tab()
        self.setup_dashboard_tab()
        self.setup_blockchain_monitor_tab()
        self.setup_block_explorer_tab()
        self.setup_wallet_tab()
        self.setup_transactions_tab()
        self.setup_network_tab()
        self.setup_mining_tab()
        self.setup_address_tab()
        self.setup_control_tab()
        self.setup_config_tab()
        
        # Status bar
        self.status_bar = tk.Frame(self.root, bg=self.ZCASH_DARK_GRAY, height=30)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.status_label = tk.Label(self.status_bar, text="Ready", bg=self.ZCASH_DARK_GRAY, fg=self.ZCASH_GOLD, font=('Arial', 9), anchor=tk.W)
        self.status_label.pack(side=tk.LEFT, padx=10)
        
        self.connection_indicator = tk.Label(self.status_bar, text="â— Offline", bg=self.ZCASH_DARK_GRAY, fg=self.ZCASH_RED, font=('Arial', 9, 'bold'))
        self.connection_indicator.pack(side=tk.RIGHT, padx=10)
    
    def detect_system(self):
        self.system = platform.system().lower()
        self.arch = platform.machine().lower()
        self.status_label.config(text=f"System: {self.system} {self.arch}")
    
    def load_rpc_config(self):
        """Load RPC credentials from zcash.conf"""
        if self.zcash_conf_file.exists():
            try:
                with open(self.zcash_conf_file, 'r') as f:
                    for line in f:
                        if line.startswith('rpcpassword='):
                            self.rpc_password = line.split('=', 1)[1].strip()
                        elif line.startswith('rpcuser='):
                            self.rpc_user = line.split('=', 1)[1].strip()
                        elif line.startswith('rpcport='):
                            port = line.split('=', 1)[1].strip()
                            self.rpc_url = f"http://127.0.0.1:{port}"
            except Exception as e:
                print(f"Error loading RPC config: {e}")
    
    # ==================== INSTALLATION TAB ====================
    def setup_installation_tab(self):
        tab = ttk.Frame(self.notebook, style='Zcash.TFrame')
        self.notebook.add(tab, text="ğŸš€ Installation")
        
        install_frame = ttk.LabelFrame(tab, text="Automatic Zcash Installation (Official Method)", padding=15)
        install_frame.pack(fill='x', padx=10, pady=10)
        
        info_frame = ttk.Frame(install_frame)
        info_frame.pack(fill='x', pady=5)
        ttk.Label(info_frame, text="Detected System:", style='ZcashGold.TLabel').pack(side='left')
        self.system_label = ttk.Label(info_frame, text="Checking...", style='ZcashWhite.TLabel')
        self.system_label.pack(side='left', padx=5)
        
        steps_frame = ttk.Frame(install_frame)
        steps_frame.pack(fill='x', pady=10)
        
        self.step1_var = tk.StringVar(value="â¬œ Install Dependencies")
        self.step2_var = tk.StringVar(value="â¬œ Clone Zcash Repository")
        self.step3_var = tk.StringVar(value="â¬œ Fetch Zcash Parameters")
        self.step4_var = tk.StringVar(value="â¬œ Build Zcash (./zcutil/build.sh)")
        self.step5_var = tk.StringVar(value="â¬œ Configure Node (zcash.conf)")
        
        for var in [self.step1_var, self.step2_var, self.step3_var, self.step4_var, self.step5_var]:
            ttk.Label(steps_frame, textvariable=var, style='ZcashWhite.TLabel').pack(anchor='w')
        
        btn_frame = ttk.Frame(install_frame)
        btn_frame.pack(fill='x', pady=10)
        
        ttk.Button(btn_frame, text="FULL AUTOMATIC INSTALL", command=self.full_automatic_install, style='ZcashGold.TButton').pack(side='left', padx=5)
        ttk.Button(btn_frame, text="Install Dependencies", command=self.install_dependencies).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="Build Zcash", command=self.build_zcash).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="Check Installation", command=self.check_installation).pack(side='left', padx=5)
        
        self.install_progress = ttk.Progressbar(install_frame, mode='indeterminate')
        self.install_progress.pack(fill='x', pady=5)
        
        output_frame = ttk.LabelFrame(tab, text="Installation Output (Real-Time)", padding=10)
        output_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        self.install_output = scrolledtext.ScrolledText(output_frame, height=20, bg=self.ZCASH_BLACK, fg=self.ZCASH_GOLD, insertbackground=self.ZCASH_GOLD, font=('Courier', 9))
        self.install_output.pack(fill='both', expand=True)
    
    # ==================== DASHBOARD TAB ====================
    def setup_dashboard_tab(self):
        tab = ttk.Frame(self.notebook, style='Zcash.TFrame')
        self.notebook.add(tab, text="ğŸ“Š Dashboard")
        
        control_frame = ttk.LabelFrame(tab, text="Node Controls", padding=10)
        control_frame.pack(fill='x', padx=10, pady=5)
        
        ttk.Button(control_frame, text="â–¶ Start Node (./src/zcashd)", command=self.start_node, style='ZcashGold.TButton').pack(side='left', padx=5)
        ttk.Button(control_frame, text="â¹ Stop Node", command=self.stop_node).pack(side='left', padx=5)
        ttk.Button(control_frame, text="ğŸ”„ Refresh Status", command=self.refresh_dashboard).pack(side='left', padx=5)
        ttk.Button(control_frame, text="ğŸ” Start Real-Time Monitor", command=self.start_monitoring, style='ZcashGold.TButton').pack(side='left', padx=5)
        ttk.Button(control_frame, text="â¸ Stop Monitor", command=self.stop_monitoring).pack(side='left', padx=5)
        
        stats_frame = ttk.LabelFrame(tab, text="Live Node Statistics", padding=10)
        stats_frame.pack(fill='x', padx=10, pady=5)
        
        self.stats_text = tk.Text(stats_frame, height=8, bg=self.ZCASH_BLACK, fg=self.ZCASH_GOLD, font=('Courier', 10, 'bold'), relief=tk.FLAT)
        self.stats_text.pack(fill='x')
        
        output_frame = ttk.LabelFrame(tab, text="Node Status (getinfo, getblockchaininfo)", padding=10)
        output_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.dashboard_text = scrolledtext.ScrolledText(output_frame, height=25, bg=self.ZCASH_BLACK, fg='white', insertbackground=self.ZCASH_GOLD, font=('Courier', 9))
        self.dashboard_text.pack(fill='both', expand=True)
    
    # ==================== BLOCKCHAIN MONITOR TAB ====================
    def setup_blockchain_monitor_tab(self):
        tab = ttk.Frame(self.notebook, style='Zcash.TFrame')
        self.notebook.add(tab, text="â›“ï¸ Blockchain Monitor")
        
        stats_panel = ttk.LabelFrame(tab, text="LIVE Blockchain Statistics", padding=10)
        stats_panel.pack(fill='x', padx=10, pady=5)
        
        self.blockchain_stats = tk.Text(stats_panel, height=6, bg=self.ZCASH_BLACK, fg=self.ZCASH_GOLD, font=('Courier', 11, 'bold'))
        self.blockchain_stats.pack(fill='x')
        
        blocks_frame = ttk.LabelFrame(tab, text="Recent Blocks - Real-Time Visual (Zcash Colors)", padding=10)
        blocks_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.blocks_canvas = tk.Canvas(blocks_frame, bg=self.ZCASH_BLACK, highlightthickness=0)
        self.blocks_canvas.pack(fill='both', expand=True)
        
        mempool_frame = ttk.LabelFrame(tab, text="Mempool Activity (getmempoolinfo)", padding=10)
        mempool_frame.pack(fill='x', padx=10, pady=5)
        
        self.mempool_text = tk.Text(mempool_frame, height=8, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.mempool_text.pack(fill='both', expand=True)
    
    # ==================== BLOCK EXPLORER TAB ====================
    def setup_block_explorer_tab(self):
        tab = ttk.Frame(self.notebook, style='Zcash.TFrame')
        self.notebook.add(tab, text="ğŸ” Block Explorer")
        
        search_frame = ttk.LabelFrame(tab, text="Block Search (getblock, getblockhash)", padding=10)
        search_frame.pack(fill='x', padx=10, pady=5)
        
        search_row = ttk.Frame(search_frame)
        search_row.pack(fill='x', pady=5)
        
        ttk.Label(search_row, text="Block Height or Hash:", style='ZcashGold.TLabel').pack(side='left', padx=5)
        self.block_search_entry = ttk.Entry(search_row, width=70)
        self.block_search_entry.pack(side='left', padx=5)
        ttk.Button(search_row, text="Get Block Details", command=self.get_block_details, style='ZcashGold.TButton').pack(side='left', padx=5)
        ttk.Button(search_row, text="Get Best Block", command=self.get_best_block).pack(side='left', padx=5)
        ttk.Button(search_row, text="Get Block Count", command=self.get_block_count).pack(side='left', padx=5)
        
        details_frame = ttk.LabelFrame(tab, text="Block Details", padding=10)
        details_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.block_details_text = scrolledtext.ScrolledText(details_frame, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.block_details_text.pack(fill='both', expand=True)
    
    # ==================== WALLET TAB ====================
    def setup_wallet_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="ğŸ’° Wallet")
        
        wallet_frame = ttk.LabelFrame(tab, text="Wallet Operations (~/.zcash/wallet.dat)", padding=10)
        wallet_frame.pack(fill='x', padx=10, pady=5)
        
        btn_frame1 = ttk.Frame(wallet_frame)
        btn_frame1.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame1, text="z_gettotalbalance", command=lambda: self.execute_rpc_command("z_gettotalbalance", self.wallet_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame1, text="getwalletinfo", command=lambda: self.execute_rpc_command("getwalletinfo", self.wallet_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame1, text="listunspent", command=lambda: self.execute_rpc_command("listunspent", self.wallet_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame1, text="getbalance", command=lambda: self.execute_rpc_command("getbalance", self.wallet_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame1, text="z_listunspent", command=lambda: self.execute_rpc_command("z_listunspent", self.wallet_output)).pack(side='left', padx=2)
        
        btn_frame2 = ttk.Frame(wallet_frame)
        btn_frame2.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame2, text="z_getbalance", command=self.z_getbalance).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="z_getbalanceforaccount", command=lambda: self.execute_rpc_command("z_getbalanceforaccount", self.wallet_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="z_listaccounts", command=lambda: self.execute_rpc_command("z_listaccounts", self.wallet_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="z_getnewaccount", command=self.z_getnewaccount).pack(side='left', padx=2)
        
        btn_frame3 = ttk.Frame(wallet_frame)
        btn_frame3.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame3, text="Backup Wallet", command=self.backup_wallet, style='ZcashGold.TButton').pack(side='left', padx=2)
        ttk.Button(btn_frame3, text="Restore Wallet", command=self.restore_wallet).pack(side='left', padx=2)
        ttk.Button(btn_frame3, text="encryptwallet", command=self.encrypt_wallet).pack(side='left', padx=2)
        ttk.Button(btn_frame3, text="walletpassphrase", command=self.wallet_passphrase).pack(side='left', padx=2)
        ttk.Button(btn_frame3, text="walletlock", command=lambda: self.execute_rpc_command("walletlock", self.wallet_output)).pack(side='left', padx=2)
        
        btn_frame4 = ttk.Frame(wallet_frame)
        btn_frame4.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame4, text="z_exportkey", command=self.z_exportkey).pack(side='left', padx=2)
        ttk.Button(btn_frame4, text="z_importkey", command=self.z_importkey).pack(side='left', padx=2)
        ttk.Button(btn_frame4, text="z_exportwallet", command=self.z_exportwallet).pack(side='left', padx=2)
        ttk.Button(btn_frame4, text="z_importwallet", command=self.z_importwallet).pack(side='left', padx=2)
        
        output_frame = ttk.LabelFrame(tab, text="Wallet Information", padding=10)
        output_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.wallet_output = scrolledtext.ScrolledText(output_frame, height=20, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.wallet_output.pack(fill='both', expand=True)
    
    # ==================== TRANSACTIONS TAB ====================
    def setup_transactions_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="ğŸ“„ Transactions")
        
        tx_frame = ttk.LabelFrame(tab, text="Send Transaction", padding=10)
        tx_frame.pack(fill='x', padx=10, pady=5)
        
        row1 = ttk.Frame(tx_frame)
        row1.pack(fill='x', pady=2)
        ttk.Label(row1, text="From Address:").pack(side='left')
        self.from_addr = ttk.Entry(row1, width=60)
        self.from_addr.pack(side='left', padx=5)
        
        row2 = ttk.Frame(tx_frame)
        row2.pack(fill='x', pady=2)
        ttk.Label(row2, text="To Address:").pack(side='left', padx=(0,5))
        self.to_addr = ttk.Entry(row2, width=60)
        self.to_addr.pack(side='left', padx=5)
        
        row3 = ttk.Frame(tx_frame)
        row3.pack(fill='x', pady=2)
        ttk.Label(row3, text="Amount (ZEC):").pack(side='left')
        self.amount = ttk.Entry(row3, width=20)
        self.amount.pack(side='left', padx=5)
        
        row4 = ttk.Frame(tx_frame)
        row4.pack(fill='x', pady=2)
        ttk.Label(row4, text="Memo (optional):").pack(side='left')
        self.memo = ttk.Entry(row4, width=60)
        self.memo.pack(side='left', padx=5)
        
        btn_frame = ttk.Frame(tx_frame)
        btn_frame.pack(fill='x', pady=5)
        
        ttk.Button(btn_frame, text="z_sendmany (Shielded)", command=self.send_shielded_tx, style='ZcashGold.TButton').pack(side='left', padx=2)
        ttk.Button(btn_frame, text="sendtoaddress (Transparent)", command=self.send_transparent_tx).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="z_shieldcoinbase", command=self.z_shieldcoinbase).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="z_mergetoaddress", command=self.z_mergetoaddress).pack(side='left', padx=2)
        
        btn_frame2 = ttk.Frame(tx_frame)
        btn_frame2.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame2, text="listtransactions", command=lambda: self.execute_rpc_command("listtransactions", self.tx_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="z_listreceivedbyaddress", command=self.z_listreceivedbyaddress).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="gettransaction", command=self.gettransaction).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="z_viewtransaction", command=self.z_viewtransaction).pack(side='left', padx=2)
        
        btn_frame3 = ttk.Frame(tx_frame)
        btn_frame3.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame3, text="z_getoperationstatus", command=lambda: self.execute_rpc_command("z_getoperationstatus", self.tx_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame3, text="z_getoperationresult", command=lambda: self.execute_rpc_command("z_getoperationresult", self.tx_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame3, text="z_listoperationids", command=lambda: self.execute_rpc_command("z_listoperationids", self.tx_output)).pack(side='left', padx=2)
        
        output_frame = ttk.LabelFrame(tab, text="Transaction Output", padding=10)
        output_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.tx_output = scrolledtext.ScrolledText(output_frame, height=20, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.tx_output.pack(fill='both', expand=True)
    
    # ==================== NETWORK TAB ====================
    def setup_network_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="ğŸŒ Network")
        
        net_frame = ttk.LabelFrame(tab, text="Network RPC Commands", padding=10)
        net_frame.pack(fill='x', padx=10, pady=5)
        
        btn_frame = ttk.Frame(net_frame)
        btn_frame.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame, text="getnetworkinfo", command=lambda: self.execute_rpc_command("getnetworkinfo", self.network_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getpeerinfo", command=lambda: self.execute_rpc_command("getpeerinfo", self.network_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getconnectioncount", command=lambda: self.execute_rpc_command("getconnectioncount", self.network_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getnettotals", command=lambda: self.execute_rpc_command("getnettotals", self.network_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getdeprecationinfo", command=lambda: self.execute_rpc_command("getdeprecationinfo", self.network_output)).pack(side='left', padx=2)
        
        output_frame = ttk.LabelFrame(tab, text="Network Information", padding=10)
        output_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.network_output = scrolledtext.ScrolledText(output_frame, height=20, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.network_output.pack(fill='both', expand=True)
    
    # ==================== MINING TAB ====================
    def setup_mining_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="â›ï¸ Mining")
        
        mining_frame = ttk.LabelFrame(tab, text="Mining Operations (Testnet)", padding=10)
        mining_frame.pack(fill='x', padx=10, pady=5)
        
        btn_frame = ttk.Frame(mining_frame)
        btn_frame.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame, text="getmininginfo", command=lambda: self.execute_rpc_command("getmininginfo", self.mining_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="generate 1 block", command=self.generate_blocks, style='ZcashGold.TButton').pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getblocktemplate", command=lambda: self.execute_rpc_command("getblocktemplate", self.mining_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getnetworkhashps", command=lambda: self.execute_rpc_command("getnetworkhashps", self.mining_output)).pack(side='left', padx=2)
        
        output_frame = ttk.LabelFrame(tab, text="Mining Information", padding=10)
        output_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.mining_output = scrolledtext.ScrolledText(output_frame, height=20, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.mining_output.pack(fill='both', expand=True)
    
    # ==================== ADDRESS TAB ====================
    def setup_address_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="ğŸ“« Addresses")
        
        addr_frame = ttk.LabelFrame(tab, text="Address Operations", padding=10)
        addr_frame.pack(fill='x', padx=10, pady=5)
        
        btn_frame = ttk.Frame(addr_frame)
        btn_frame.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame, text="z_getnewaddress (Shielded)", command=lambda: self.execute_rpc_command("z_getnewaddress", self.address_output), style='ZcashGold.TButton').pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getnewaddress (Transparent)", command=lambda: self.execute_rpc_command("getnewaddress", self.address_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="z_listaddresses", command=lambda: self.execute_rpc_command("z_listaddresses", self.address_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="listaddresses", command=lambda: self.execute_rpc_command("listaddresses", self.address_output)).pack(side='left', padx=2)
        
        btn_frame2 = ttk.Frame(addr_frame)
        btn_frame2.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame2, text="validateaddress", command=self.validate_address).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="z_validateaddress", command=self.z_validate_address).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="z_getaddressforaccount", command=self.z_getaddressforaccount).pack(side='left', padx=2)
        ttk.Button(btn_frame2, text="z_listunifiedreceivers", command=self.z_listunifiedreceivers).pack(side='left', padx=2)
        
        btn_frame3 = ttk.Frame(addr_frame)
        btn_frame3.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame3, text="z_exportviewingkey", command=self.z_exportviewingkey).pack(side='left', padx=2)
        ttk.Button(btn_frame3, text="z_importviewingkey", command=self.z_importviewingkey).pack(side='left', padx=2)
        ttk.Button(btn_frame3, text="z_getbalanceforviewingkey", command=self.z_getbalanceforviewingkey).pack(side='left', padx=2)
        
        output_frame = ttk.LabelFrame(tab, text="Address Information", padding=10)
        output_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.address_output = scrolledtext.ScrolledText(output_frame, height=20, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.address_output.pack(fill='both', expand=True)
    
    # ==================== CONTROL TAB ====================
    def setup_control_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="âš™ï¸ Control")
        
        control_frame = ttk.LabelFrame(tab, text="Node Control Commands", padding=10)
        control_frame.pack(fill='x', padx=10, pady=5)
        
        btn_frame = ttk.Frame(control_frame)
        btn_frame.pack(fill='x', pady=2)
        
        ttk.Button(btn_frame, text="getinfo", command=lambda: self.execute_rpc_command("getinfo", self.control_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getblockchaininfo", command=lambda: self.execute_rpc_command("getblockchaininfo", self.control_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="getmempoolinfo", command=lambda: self.execute_rpc_command("getmempoolinfo", self.control_output)).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="stop", command=self.stop_node, style='ZcashGold.TButton').pack(side='left', padx=2)
        ttk.Button(btn_frame, text="Restart Node", command=self.restart_node).pack(side='left', padx=2)
        
        output_frame = ttk.LabelFrame(tab, text="Control Information", padding=10)
        output_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.control_output = scrolledtext.ScrolledText(output_frame, height=20, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.control_output.pack(fill='both', expand=True)
    
    # ==================== CONFIG TAB ====================
    def setup_config_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="ğŸ”§ Configuration")
        
        config_frame = ttk.LabelFrame(tab, text="zcash.conf Editor (~/.zcash/zcash.conf)", padding=10)
        config_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        btn_frame = ttk.Frame(config_frame)
        btn_frame.pack(fill='x', pady=5)
        
        ttk.Button(btn_frame, text="Load Config", command=self.load_config).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="Save Config", command=self.save_config, style='ZcashGold.TButton').pack(side='left', padx=2)
        ttk.Button(btn_frame, text="Generate Default Config", command=self.generate_default_config).pack(side='left', padx=2)
        ttk.Button(btn_frame, text="Restart with New Config", command=self.restart_with_new_config).pack(side='left', padx=2)
        
        self.config_text = scrolledtext.ScrolledText(config_frame, height=25, bg=self.ZCASH_BLACK, fg='white', font=('Courier', 9))
        self.config_text.pack(fill='both', expand=True)
        
        if self.zcash_conf_file.exists():
            self.load_config()
    
    # ==================== INSTALLATION METHODS ====================
    def full_automatic_install(self):
        threading.Thread(target=self._full_install_thread, daemon=True).start()
    
    def _full_install_thread(self):
        try:
            self.install_progress.start()
            self.log_install("ğŸš€ Starting FULL Zcash installation per official documentation...\n")
            
            self.step1_var.set("ğŸ”„ Installing Dependencies...")
            self.install_dependencies_sync()
            self.step1_var.set("âœ… Install Dependencies")
            
            self.step2_var.set("ğŸ”„ Cloning Zcash Repository...")
            self.download_zcash_sync()
            self.step2_var.set("âœ… Clone Zcash Repository")
            
            self.step3_var.set("ğŸ”„ Fetching Parameters...")
            self.fetch_params_sync()
            self.step3_var.set("âœ… Fetch Parameters")
            
            self.step4_var.set("ğŸ”„ Building Zcash (30-60 mins)...")
            self.build_zcash_sync()
            self.step4_var.set("âœ… Build Zcash")
            
            self.step5_var.set("ğŸ”„ Configuring Node...")
            self.configure_node_sync()
            self.step5_var.set("âœ… Configure Node")
            
            self.install_progress.stop()
            self.log_install("\nğŸ‰ INSTALLATION COMPLETE! Start node from Dashboard tab.\n")
            messagebox.showinfo("Success", "Zcash installed successfully! Start the node from Dashboard.")
            
        except Exception as e:
            self.install_progress.stop()
            self.log_install(f"\nâŒ Installation failed: {str(e)}\n")
            messagebox.showerror("Error", f"Installation failed: {str(e)}")
    
    def install_dependencies(self):
        threading.Thread(target=self.install_dependencies_sync, daemon=True).start()
    
    def install_dependencies_sync(self):
        self.log_install("ğŸ“¦ Installing system dependencies...\n")
        
        if "linux" in self.system:
            commands = [
                "sudo apt-get update",
                "sudo apt-get install -y build-essential pkg-config libc6-dev m4 g++-multilib autoconf libtool libncurses5-dev unzip git python3 zlib1g-dev wget bsdmainutils automake curl"
            ]
        elif self.system == "darwin":
            commands = [
                "brew update",
                "brew install autoconf automake libtool pkg-config wget"
            ]
        else:
            self.log_install("âŒ Unsupported OS. Please install manually.\n")
            return
        
        for cmd in commands:
            self.log_install(f"Running: {cmd}\n")
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if result.stdout:
                self.log_install(result.stdout[:500] + "\n")
            if result.stderr and result.returncode != 0:
                self.log_install(f"Error: {result.stderr[:500]}\n")
    
    def download_zcash_sync(self):
        self.log_install("ğŸ“¥ Cloning Zcash from GitHub...\n")
        
        if not self.zcash_dir.exists():
            cmd = "git clone https://github.com/zcash/zcash.git"
            self.log_install(f"Running: {cmd}\n")
            result = subprocess.run(cmd, shell=True, cwd=Path.home(), capture_output=True, text=True)
            self.log_install(result.stdout[:500] + "\n")
            if result.returncode != 0:
                self.log_install(f"Error: {result.stderr[:500]}\n")
        else:
            self.log_install("Directory exists, pulling latest changes...\n")
            result = subprocess.run("git pull", shell=True, cwd=self.zcash_dir, capture_output=True, text=True)
            self.log_install(result.stdout + "\n")
    
    def fetch_params_sync(self):
        self.log_install("ğŸ” Fetching Zcash parameters (./zcutil/fetch-params.sh)...\n")
        
        fetch_script = self.zcash_dir / "zcutil" / "fetch-params.sh"
        if fetch_script.exists():
            result = subprocess.run(str(fetch_script), shell=True, cwd=self.zcash_dir, capture_output=True, text=True)
            self.log_install(result.stdout[:1000] + "\n")
            if result.returncode != 0:
                self.log_install(f"Error: {result.stderr[:500]}\n")
        else:
            self.log_install("âŒ fetch-params.sh not found!\n")
    
    def build_zcash(self):
        threading.Thread(target=self.build_zcash_sync, daemon=True).start()
    
    def build_zcash_sync(self):
        self.log_install("ğŸ”¨ Building Zcash (./zcutil/build.sh)...\n")
        self.log_install("This will take 30-60 minutes. Please be patient.\n")
        
        # Clean first
        clean_script = self.zcash_dir / "zcutil" / "clean.sh"
        if clean_script.exists():
            self.log_install("Cleaning previous build...\n")
            subprocess.run(str(clean_script), shell=True, cwd=self.zcash_dir, capture_output=True, text=True)
        
        # Build
        build_script = self.zcash_dir / "zcutil" / "build.sh"
        if build_script.exists():
            # Determine number of cores
            if self.system == "darwin":
                nproc_cmd = "sysctl -n hw.ncpu"
            else:
                nproc_cmd = "nproc"
            
            nproc_result = subprocess.run(nproc_cmd, shell=True, capture_output=True, text=True)
            cores = nproc_result.stdout.strip() if nproc_result.returncode == 0 else "1"
            
            build_cmd = f"{build_script} -j{cores}"
            self.log_install(f"Running: {build_cmd}\n")
            
            result = subprocess.run(build_cmd, shell=True, cwd=self.zcash_dir, capture_output=True, text=True)
            
            # Show last 2000 chars of output
            if result.stdout:
                self.log_install("Build output (last part):\n" + result.stdout[-2000:] + "\n")
            
            if result.returncode == 0:
                self.log_install("âœ… Build completed successfully!\n")
            else:
                self.log_install(f"âŒ Build failed! Error:\n{result.stderr[-1000:]}\n")
        else:
            self.log_install("âŒ build.sh not found!\n")
    
    def configure_node_sync(self):
        self.log_install("âš™ï¸ Configuring Zcash node...\n")
        
        # Create config directory
        self.zcash_conf_dir.mkdir(exist_ok=True)
        self.log_install(f"Config directory: {self.zcash_conf_dir}\n")
        
        # Generate secure RPC password
        self.rpc_password = secrets.token_hex(32)
        
        # Create config file per official documentation
        config_content = f"""# Zcash Configuration File
# Generated by Zcash Production Node Manager

# RPC Settings
server=1
rpcuser={self.rpc_user}
rpcpassword={self.rpc_password}
rpcallowip=127.0.0.1
rpcport=8232

# Network (use testnet=1 for testing, comment out for mainnet)
testnet=1

# Indexing (enables full blockchain queries)
txindex=1
addressindex=1
timestampindex=1
spentindex=1

# Performance
dbcache=2000
maxconnections=50

# Privacy
listen=1
bind=127.0.0.1

# Logging
debug=1
logtimestamps=1
logips=1

# Mining (for testnet only)
gen=0
"""
        
        with open(self.zcash_conf_file, 'w') as f:
            f.write(config_content)
        
        self.log_install(f"âœ… Configuration saved to {self.zcash_conf_file}\n")
        self.log_install(f"RPC User: {self.rpc_user}\n")
        self.log_install(f"RPC Password: {self.rpc_password}\n")
        
        # Reload RPC config
        self.load_rpc_config()
    
    def check_installation(self):
        """Check if Zcash is properly installed"""
        def check():
            output = "ğŸ” Checking Zcash Installation...\n\n"
            
            # Check zcashd
            if self.zcashd_path.exists():
                output += f"âœ… zcashd found at: {self.zcashd_path}\n"
                result = subprocess.run(f"{self.zcashd_path} --version", shell=True, capture_output=True, text=True)
                output += f"   Version: {result.stdout.strip()}\n"
            else:
                output += f"âŒ zcashd NOT found at: {self.zcashd_path}\n"
            
            # Check zcash-cli
            if self.zcash_cli_path.exists():
                output += f"âœ… zcash-cli found at: {self.zcash_cli_path}\n"
            else:
                output += f"âŒ zcash-cli NOT found at: {self.zcash_cli_path}\n"
            
            # Check config
            if self.zcash_conf_file.exists():
                output += f"âœ… zcash.conf found at: {self.zcash_conf_file}\n"
            else:
                output += f"âŒ zcash.conf NOT found at: {self.zcash_conf_file}\n"
            
            # Check wallet
            if self.wallet_file.exists():
                output += f"âœ… wallet.dat found at: {self.wallet_file}\n"
            else:
                output += f"âš ï¸  wallet.dat not yet created (will be created on first run)\n"
            
            self.log_install(output)
        
        threading.Thread(target=check, daemon=True).start()
    
    # ==================== NODE CONTROL METHODS ====================
    def start_node(self):
        """Start zcashd node"""
        def start():
            if not self.zcashd_path.exists():
                messagebox.showerror("Error", f"zcashd not found at {self.zcashd_path}. Please complete installation first.")
                return
            
            self.log_install(f"â–¶ Starting zcashd from {self.zcashd_path}...\n")
            
            try:
                # Start zcashd in background
                self.node_process = subprocess.Popen(
                    [str(self.zcashd_path)],
                    cwd=self.zcashd_path.parent,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                
                time.sleep(5)  # Wait for node to initialize
                
                self.log_install("âœ… Node started! Waiting for RPC to be ready...\n")
                self.connection_indicator.config(text="â— Starting...", fg=self.ZCASH_GOLD)
                
                # Wait for RPC to be ready
                for i in range(30):
                    try:
                        result = self.rpc_call("getinfo")
                        if "error" not in result or result.get("result"):
                            self.log_install("âœ… Node is ready!\n")
                            self.connection_indicator.config(text="â— Online", fg=self.ZCASH_GREEN)
                            self.refresh_dashboard()
                            return
                    except:
                        pass
                    time.sleep(2)
                
                self.log_install("âš ï¸  Node started but RPC not responding yet. Keep waiting...\n")
                
            except Exception as e:
                self.log_install(f"âŒ Failed to start node: {str(e)}\n")
                messagebox.showerror("Error", f"Failed to start node: {str(e)}")
        
        threading.Thread(target=start, daemon=True).start()
    
    def stop_node(self):
        """Stop zcashd node using RPC"""
        def stop():
            if not self.zcash_cli_path.exists():
                messagebox.showerror("Error", "zcash-cli not found")
                return
            
            self.log_install("â¹ Stopping zcashd...\n")
            
            try:
                result = self.rpc_call("stop")
                self.log_install(f"Stop command sent: {json.dumps(result, indent=2)}\n")
                
                time.sleep(2)
                self.connection_indicator.config(text="â— Offline", fg=self.ZCASH_RED)
                self.log_install("âœ… Node stopped\n")
                
            except Exception as e:
                self.log_install(f"Error stopping node: {str(e)}\n")
        
        threading.Thread(target=stop, daemon=True).start()
    
    def restart_node(self):
        """Restart the node"""
        self.stop_node()
        time.sleep(5)
        self.start_node()
    
    def restart_with_new_config(self):
        """Save config and restart node"""
        self.save_config()
        self.restart_node()
    
    # ==================== RPC METHODS ====================
    def rpc_call(self, method, params=None):
        """Make RPC call to zcashd"""
        if params is None:
            params = []
        
        payload = {
            "method": method,
            "params": params,
            "jsonrpc": "2.0",
            "id": 1
        }
        
        try:
            response = requests.post(
                self.rpc_url,
                json=payload,
                auth=(self.rpc_user, self.rpc_password),
                timeout=30
            )
            return response.json()
        except requests.exceptions.ConnectionError:
            return {"error": "Connection refused - node not running"}
        except Exception as e:
            return {"error": str(e)}
    
    def execute_rpc_command(self, method, output_widget, params=None):
        """Execute RPC command and display result"""
        def execute():
            result = self.rpc_call(method, params)
            output_widget.delete(1.0, tk.END)
            output_widget.insert(1.0, json.dumps(result, indent=2))
        
        threading.Thread(target=execute, daemon=True).start()
    
    # ==================== MONITORING METHODS ====================
    def start_monitoring(self):
        """Start real-time blockchain monitoring"""
        if self.monitoring_active:
            messagebox.showinfo("Info", "Monitoring already active")
            return
        
        self.monitoring_active = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        self.status_label.config(text="Real-time monitoring ACTIVE")
    
    def stop_monitoring(self):
        """Stop real-time monitoring"""
        self.monitoring_active = False
        self.status_label.config(text="Monitoring stopped")
    
    def _monitor_loop(self):
        """Main monitoring loop - runs every 5 seconds"""
        while self.monitoring_active:
            try:
                # Get blockchain info
                blockchain_info = self.rpc_call("getblockchaininfo")
                mempool_info = self.rpc_call("getmempoolinfo")
                network_info = self.rpc_call("getnetworkinfo")
                peer_info = self.rpc_call("getpeerinfo")
                
                if "result" in blockchain_info:
                    bc = blockchain_info["result"]
                    self.last_block_height = bc.get("blocks", 0)
                    self.last_block_hash = bc.get("bestblockhash", "")
                    self.sync_progress = bc.get("verificationprogress", 0.0) * 100
                    
                    # Update metrics
                    current_time = datetime.now().strftime("%H:%M:%S")
                    self.metrics_history['blocks'].append(self.last_block_height)
                    self.metrics_history['timestamps'].append(current_time)
                    
                    # Check for new blocks
                    if self.last_block_height > 0:
                        self._fetch_recent_blocks()
                
                if "result" in mempool_info:
                    mp = mempool_info["result"]
                    self.mempool_count = mp.get("size", 0)
                    self.metrics_history['mempool_size'].append(self.mempool_count)
                
                if "result" in network_info:
                    net = network_info["result"]
                    self.current_peers = net.get("connections", 0)
                    self.metrics_history['peers'].append(self.current_peers)
                
                # Update displays
                self.root.after(0, self._update_monitoring_display, blockchain_info, mempool_info, network_info)
                
                # Update connection indicator
                if blockchain_info.get("error"):
                    self.root.after(0, lambda: self.connection_indicator.config(text="â— Offline", fg=self.ZCASH_RED))
                else:
                    self.root.after(0, lambda: self.connection_indicator.config(text="â— Online", fg=self.ZCASH_GREEN))
                
            except Exception as e:
                print(f"Monitor error: {e}")
            
            time.sleep(5)  # Update every 5 seconds
    
    def _fetch_recent_blocks(self):
        """Fetch recent blocks for visualization"""
        try:
            # Get last 20 blocks
            for i in range(20):
                height = self.last_block_height - i
                if height < 0:
                    break
                
                # Check if we already have this block
                if any(b.get('height') == height for b in self.recent_blocks):
                    continue
                
                # Get block hash
                hash_result = self.rpc_call("getblockhash", [height])
                if "result" in hash_result:
                    block_hash = hash_result["result"]
                    
                    # Get block details
                    block_result = self.rpc_call("getblock", [block_hash])
                    if "result" in block_result:
                        block = block_result["result"]
                        block['height'] = height
                        self.recent_blocks.appendleft(block)
                        
                        # Limit to 20 blocks
                        while len(self.recent_blocks) > 20:
                            self.recent_blocks.pop()
                        
                        break  # Only fetch one new block per update
        except Exception as e:
            print(f"Error fetching blocks: {e}")
    
    def _update_monitoring_display(self, blockchain_info, mempool_info, network_info):
        """Update all monitoring displays"""
        try:
            # Update stats text
            if "result" in blockchain_info:
                bc = blockchain_info["result"]
                stats = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  LIVE BLOCKCHAIN STATUS                                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Block Height:      {self.last_block_height:>10}                              â•‘
â•‘  Sync Progress:     {self.sync_progress:>6.2f}%                            â•‘
â•‘  Chain:             {bc.get('chain', 'N/A'):>10}                              â•‘
â•‘  Connections:       {self.current_peers:>10}                              â•‘
â•‘  Mempool Size:      {self.mempool_count:>10} transactions                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
                self.stats_text.delete(1.0, tk.END)
                self.stats_text.insert(1.0, stats)
            
            # Update blockchain stats
            if "result" in blockchain_info:
                bc = blockchain_info["result"]
                blockchain_stats = f"""
CURRENT BLOCK:     {self.last_block_height}
BEST BLOCK HASH:   {self.last_block_hash[:32]}...
CHAIN:             {bc.get('chain', 'N/A').upper()}
DIFFICULTY:        {bc.get('difficulty', 0):,.2f}
VERIFICATION:      {self.sync_progress:.2f}%
"""
                self.blockchain_stats.delete(1.0, tk.END)
                self.blockchain_stats.insert(1.0, blockchain_stats)
            
            # Update mempool display
            if "result" in mempool_info:
                mp = mempool_info["result"]
                mempool_text = f"""
Mempool Size:      {mp.get('size', 0)} transactions
Mempool Bytes:     {mp.get('bytes', 0):,} bytes
Usage:             {mp.get('usage', 0):,} bytes
"""
                self.mempool_text.delete(1.0, tk.END)
                self.mempool_text.insert(1.0, mempool_text)
            
            # Draw blocks visualization
            self._draw_blocks_visual()
            
        except Exception as e:
            print(f"Display update error: {e}")
    
    def _draw_blocks_visual(self):
        """Draw visual representation of recent blocks with Zcash colors"""
        try:
            self.blocks_canvas.delete("all")
            
            width = self.blocks_canvas.winfo_width()
            height = self.blocks_canvas.winfo_height()
            
            if width < 100 or height < 100:
                return
            
            # Draw blocks
            num_blocks = len(self.recent_blocks)
            if num_blocks == 0:
                self.blocks_canvas.create_text(
                    width//2, height//2,
                    text="Waiting for blocks...",
                    fill=self.ZCASH_GOLD,
                    font=('Arial', 14, 'bold')
                )
                return
            
            block_width = min(150, (width - 40) // min(num_blocks, 5))
            block_height = 100
            spacing = 20
            
            x = 20
            y = 20
            col = 0
            
            for i, block in enumerate(list(self.recent_blocks)[:20]):
                # Alternate colors
                if i % 2 == 0:
                    color = self.ZCASH_GOLD
                    text_color = self.ZCASH_BLACK
                else:
                    color = self.ZCASH_DARK_GRAY
                    text_color = self.ZCASH_GOLD
                
                # Draw block rectangle
                self.blocks_canvas.create_rectangle(
                    x, y, x + block_width, y + block_height,
                    fill=color, outline=self.ZCASH_GOLD, width=2
                )
                
                # Block info
                height_val = block.get('height', 'N/A')
                tx_count = len(block.get('tx', []))
                timestamp = block.get('time', 0)
                time_str = datetime.fromtimestamp(timestamp).strftime("%H:%M:%S") if timestamp else "N/A"
                
                # Draw text
                self.blocks_canvas.create_text(
                    x + block_width//2, y + 20,
                    text=f"Block {height_val}",
                    fill=text_color,
                    font=('Arial', 10, 'bold')
                )
                
                self.blocks_canvas.create_text(
                    x + block_width//2, y + 45,
                    text=f"{tx_count} txs",
                    fill=text_color,
                    font=('Arial', 9)
                )
                
                self.blocks_canvas.create_text(
                    x + block_width//2, y + 65,
                    text=time_str,
                    fill=text_color,
                    font=('Arial', 8)
                )
                
                # Move to next position
                col += 1
                if col >= 5:  # 5 blocks per row
                    col = 0
                    x = 20
                    y += block_height + spacing
                else:
                    x += block_width + spacing
                
                # Stop if we run out of vertical space
                if y + block_height > height:
                    break
                    
        except Exception as e:
            print(f"Block visualization error: {e}")
    
    def refresh_dashboard(self):
        """Refresh dashboard information"""
        def refresh():
            try:
                info = self.rpc_call("getinfo")
                blockchain = self.rpc_call("getblockchaininfo")
                network = self.rpc_call("getnetworkinfo")
                
                output = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
                output += "   ZCASH NODE STATUS REPORT\n"
                output += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
                
                if "error" in info:
                    output += f"âŒ Node not running or not accessible\n"
                    output += f"Error: {info['error']}\n\n"
                    output += f"RPC URL: {self.rpc_url}\n"
                    output += f"Make sure zcashd is running with:\n"
                    output += f"  {self.zcashd_path}\n"
                else:
                    output += "âœ… Node is RUNNING\n\n"
                    
                    output += "â•â•â• GETINFO â•â•â•\n"
                    output += json.dumps(info.get("result", info), indent=2) + "\n\n"
                    
                    output += "â•â•â• GETBLOCKCHAININFO â•â•â•\n"
                    output += json.dumps(blockchain.get("result", blockchain), indent=2) + "\n\n"
                    
                    output += "â•â•â• GETNETWORKINFO â•â•â•\n"
                    output += json.dumps(network.get("result", network), indent=2)
                
                self.dashboard_text.delete(1.0, tk.END)
                self.dashboard_text.insert(1.0, output)
                
            except Exception as e:
                self.dashboard_text.delete(1.0, tk.END)
                self.dashboard_text.insert(1.0, f"Error refreshing dashboard: {str(e)}")
        
        threading.Thread(target=refresh, daemon=True).start()
    
    # ==================== BLOCK EXPLORER METHODS ====================
    def get_block_details(self):
        """Get block details by height or hash"""
        block_id = self.block_search_entry.get().strip()
        
        if not block_id:
            messagebox.showwarning("Warning", "Enter block height or hash")
            return
        
        def get_block():
            try:
                # If it's a number, get hash first
                if block_id.isdigit():
                    hash_result = self.rpc_call("getblockhash", [int(block_id)])
                    if "result" in hash_result:
                        block_hash = hash_result["result"]
                    else:
                        self.block_details_text.delete(1.0, tk.END)
                        self.block_details_text.insert(1.0, json.dumps(hash_result, indent=2))
                        return
                else:
                    block_hash = block_id
                
                # Get block details
                block_result = self.rpc_call("getblock", [block_hash, 2])  # Verbosity 2 for full details
                
                self.block_details_text.delete(1.0, tk.END)
                self.block_details_text.insert(1.0, json.dumps(block_result, indent=2))
                
            except Exception as e:
                self.block_details_text.delete(1.0, tk.END)
                self.block_details_text.insert(1.0, f"Error: {str(e)}")
        
        threading.Thread(target=get_block, daemon=True).start()
    
    def get_best_block(self):
        """Get the best (latest) block"""
        def get():
            result = self.rpc_call("getbestblockhash")
            if "result" in result:
                self.block_search_entry.delete(0, tk.END)
                self.block_search_entry.insert(0, result["result"])
                self.get_block_details()
            else:
                self.block_details_text.delete(1.0, tk.END)
                self.block_details_text.insert(1.0, json.dumps(result, indent=2))
        
        threading.Thread(target=get, daemon=True).start()
    
    def get_block_count(self):
        """Get current block count"""
        def get():
            result = self.rpc_call("getblockcount")
            self.block_details_text.delete(1.0, tk.END)
            self.block_details_text.insert(1.0, f"Current Block Count: {json.dumps(result, indent=2)}")
        
        threading.Thread(target=get, daemon=True).start()
    
    # ==================== TRANSACTION METHODS ====================
    def send_shielded_tx(self):
        """Send shielded transaction using z_sendmany"""
        from_addr = self.from_addr.get().strip()
        to_addr = self.to_addr.get().strip()
        amount = self.amount.get().strip()
        memo = self.memo.get().strip()
        
        if not all([from_addr, to_addr, amount]):
            messagebox.showwarning("Warning", "Fill in from, to, and amount fields")
            return
        
        def send():
            try:
                # Build amounts array
                amounts = [{"address": to_addr, "amount": float(amount)}]
                
                # Add memo if provided
                if memo:
                    amounts[0]["memo"] = memo.encode().hex()
                
                result = self.rpc_call("z_sendmany", [from_addr, amounts])
                self.tx_output.delete(1.0, tk.END)
                self.tx_output.insert(1.0, "Transaction sent!\n\n" + json.dumps(result, indent=2))
            except Exception as e:
                self.tx_output.delete(1.0, tk.END)
                self.tx_output.insert(1.0, f"Error: {str(e)}")
        
        threading.Thread(target=send, daemon=True).start()
    
    def send_transparent_tx(self):
        """Send transparent transaction using sendtoaddress"""
        to_addr = self.to_addr.get().strip()
        amount = self.amount.get().strip()
        
        if not all([to_addr, amount]):
            messagebox.showwarning("Warning", "Fill in to address and amount")
            return
        
        def send():
            try:
                result = self.rpc_call("sendtoaddress", [to_addr, float(amount)])
                self.tx_output.delete(1.0, tk.END)
                self.tx_output.insert(1.0, "Transaction sent!\n\n" + json.dumps(result, indent=2))
            except Exception as e:
                self.tx_output.delete(1.0, tk.END)
                self.tx_output.insert(1.0, f"Error: {str(e)}")
        
        threading.Thread(target=send, daemon=True).start()
    
    def sign_message(self):
        """Sign a message with an address"""
        address = self.from_addr.get().strip()
        
        if not address:
            messagebox.showwarning("Warning", "Enter an address in the From field")
            return
        
        message = simpledialog.askstring("Sign Message", "Enter message to sign:")
        if not message:
            return
        
        def sign():
            try:
                result = self.rpc_call("signmessage", [address, message])
                self.tx_output.delete(1.0, tk.END)
                self.tx_output.insert(1.0, f"Message: {message}\n\nAddress: {address}\n\nSignature:\n{json.dumps(result, indent=2)}")
            except Exception as e:
                self.tx_output.delete(1.0, tk.END)
                self.tx_output.insert(1.0, f"Error: {str(e)}")
        
        threading.Thread(target=sign, daemon=True).start()
    
    # ==================== ADDRESS METHODS ====================
    def validate_address(self):
        """Validate a transparent address"""
        address = self.to_addr.get().strip()
        
        if not address:
            address = simpledialog.askstring("Validate Address", "Enter address to validate:")
            if not address:
                return
        
        def validate():
            result = self.rpc_call("validateaddress", [address])
            self.address_output.delete(1.0, tk.END)
            self.address_output.insert(1.0, json.dumps(result, indent=2))
        
        threading.Thread(target=validate, daemon=True).start()
    
    def z_validate_address(self):
        """Validate a shielded address"""
        address = self.to_addr.get().strip()
        
        if not address:
            address = simpledialog.askstring("Validate Shielded Address", "Enter shielded address to validate:")
            if not address:
                return
        
        def validate():
            result = self.rpc_call("z_validateaddress", [address])
            self.address_output.delete(1.0, tk.END)
            self.address_output.insert(1.0, json.dumps(result, indent=2))
        
        threading.Thread(target=validate, daemon=True).start()
    
    # ==================== MINING METHODS ====================
    def generate_blocks(self):
        """Generate blocks (testnet only)"""
        num_blocks = simpledialog.askinteger("Generate Blocks", "Number of blocks to generate:", initialvalue=1, minvalue=1, maxvalue=100)
        
        if not num_blocks:
            return
        
        def generate():
            try:
                result = self.rpc_call("generate", [num_blocks])
                self.mining_output.delete(1.0, tk.END)
                self.mining_output.insert(1.0, f"Generated {num_blocks} block(s):\n\n" + json.dumps(result, indent=2))
            except Exception as e:
                self.mining_output.delete(1.0, tk.END)
                self.mining_output.insert(1.0, f"Error: {str(e)}")
        
        threading.Thread(target=generate, daemon=True).start()
    
    # ==================== WALLET METHODS ====================
    def backup_wallet(self):
        """Backup wallet.dat file"""
        if not self.wallet_file.exists():
            messagebox.showwarning("Warning", "Wallet file not found. Start the node first to create a wallet.")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Backup Wallet",
            defaultextension=".dat",
            filetypes=[("Wallet files", "*.dat"), ("All files", "*.*")],
            initialfile=f"wallet_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.dat"
        )
        
        if filename:
            try:
                shutil.copy2(self.wallet_file, filename)
                messagebox.showinfo("Success", f"Wallet backed up to:\n{filename}")
                self.wallet_output.delete(1.0, tk.END)
                self.wallet_output.insert(1.0, f"âœ… Wallet backed up successfully to:\n{filename}\n\nOriginal: {self.wallet_file}")
            except Exception as e:
                messagebox.showerror("Error", f"Backup failed: {str(e)}")
    
    def restore_wallet(self):
        """Restore wallet.dat file"""
        filename = filedialog.askopenfilename(
            title="Restore Wallet",
            filetypes=[("Wallet files", "*.dat"), ("All files", "*.*")]
        )
        
        if filename:
            response = messagebox.askyesno(
                "Confirm Restore",
                "This will REPLACE your current wallet!\n\nMake sure you have a backup of your current wallet.\n\nContinue?"
            )
            
            if response:
                try:
                    # Stop node first
                    self.stop_node()
                    time.sleep(3)
                    
                    # Restore wallet
                    shutil.copy2(filename, self.wallet_file)
                    messagebox.showinfo("Success", "Wallet restored successfully!\n\nRestart the node to use the restored wallet.")
                    
                    self.wallet_output.delete(1.0, tk.END)
                    self.wallet_output.insert(1.0, f"âœ… Wallet restored from:\n{filename}\n\nRestart node to use restored wallet.")
                except Exception as e:
                    messagebox.showerror("Error", f"Restore failed: {str(e)}")
    
    def encrypt_wallet(self):
        """Encrypt wallet with passphrase"""
        messagebox.showinfo("Note", "encryptwallet requires experimental features.\n\nMake sure your zcash.conf has:\nexperimentalfeatures=1\ndeveloperencryptwallet=1")
        
        password = simpledialog.askstring("Encrypt Wallet", "Enter passphrase to encrypt wallet:", show='*')
        
        if not password:
            return
        
        password_confirm = simpledialog.askstring("Confirm Passphrase", "Confirm passphrase:", show='*')
        
        if password != password_confirm:
            messagebox.showerror("Error", "Passphrases do not match!")
            return
        
        def encrypt():
            try:
                result = self.rpc_call("encryptwallet", [password])
                self.wallet_output.delete(1.0, tk.END)
                self.wallet_output.insert(1.0, "âœ… Wallet encrypted!\n\nThe node will now stop. Restart it to use the encrypted wallet.\n\n" + json.dumps(result, indent=2))
                
                messagebox.showinfo("Success", "Wallet encrypted successfully!\n\nThe node will stop. Restart it to continue.")
            except Exception as e:
                self.wallet_output.delete(1.0, tk.END)
                self.wallet_output.insert(1.0, f"Error: {str(e)}")
        
        threading.Thread(target=encrypt, daemon=True).start()
    
    def wallet_passphrase(self):
        """Unlock wallet with passphrase"""
        password = simpledialog.askstring("Unlock Wallet", "Enter wallet passphrase:", show='*')
        if not password:
            return
        
        timeout = simpledialog.askinteger("Timeout", "Timeout in seconds:", initialvalue=60, minvalue=1)
        if not timeout:
            timeout = 60
        
        def unlock():
            result = self.rpc_call("walletpassphrase", [password, timeout])
            self.wallet_output.delete(1.0, tk.END)
            self.wallet_output.insert(1.0, f"Wallet unlocked for {timeout} seconds\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=unlock, daemon=True).start()
    
    def z_getbalance(self):
        """Get balance for a specific z-address"""
        address = simpledialog.askstring("Get Z-Address Balance", "Enter z-address:")
        if not address:
            return
        
        def get():
            result = self.rpc_call("z_getbalance", [address])
            self.wallet_output.delete(1.0, tk.END)
            self.wallet_output.insert(1.0, f"Balance for {address}:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=get, daemon=True).start()
    
    def z_getnewaccount(self):
        """Create new z-account"""
        def create():
            result = self.rpc_call("z_getnewaccount")
            self.wallet_output.delete(1.0, tk.END)
            self.wallet_output.insert(1.0, "New z-account created:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=create, daemon=True).start()
    
    def z_exportkey(self):
        """Export private key for z-address"""
        address = simpledialog.askstring("Export Key", "Enter z-address to export:")
        if not address:
            return
        
        def export():
            result = self.rpc_call("z_exportkey", [address])
            self.wallet_output.delete(1.0, tk.END)
            self.wallet_output.insert(1.0, f"âš ï¸  KEEP THIS PRIVATE KEY SECURE!\n\nAddress: {address}\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=export, daemon=True).start()
    
    def z_importkey(self):
        """Import z-address private key"""
        key = simpledialog.askstring("Import Key", "Enter private key:")
        if not key:
            return
        
        rescan = messagebox.askyesno("Rescan", "Rescan blockchain for transactions?\n(This may take a while)")
        
        def imp():
            result = self.rpc_call("z_importkey", [key, "yes" if rescan else "no"])
            self.wallet_output.delete(1.0, tk.END)
            self.wallet_output.insert(1.0, "Key imported successfully:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=imp, daemon=True).start()
    
    def z_exportwallet(self):
        """Export wallet to file"""
        filename = filedialog.asksaveasfilename(
            title="Export Wallet",
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            initialfile=f"zcash_wallet_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        )
        
        if filename:
            def export():
                result = self.rpc_call("z_exportwallet", [filename])
                self.wallet_output.delete(1.0, tk.END)
                self.wallet_output.insert(1.0, f"Wallet exported to:\n{filename}\n\n" + json.dumps(result, indent=2))
                messagebox.showinfo("Success", f"Wallet exported to:\n{filename}")
            
            threading.Thread(target=export, daemon=True).start()
    
    def z_importwallet(self):
        """Import wallet from file"""
        filename = filedialog.askopenfilename(
            title="Import Wallet",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if filename:
            def imp():
                result = self.rpc_call("z_importwallet", [filename])
                self.wallet_output.delete(1.0, tk.END)
                self.wallet_output.insert(1.0, f"Wallet imported from:\n{filename}\n\n" + json.dumps(result, indent=2))
                messagebox.showinfo("Success", "Wallet imported successfully!")
            
            threading.Thread(target=imp, daemon=True).start()
    
    # ==================== TRANSACTION METHODS ====================
    def z_shieldcoinbase(self):
        """Shield coinbase funds"""
        from_addr = self.from_addr.get().strip() or "*"
        to_addr = self.to_addr.get().strip()
        
        if not to_addr:
            messagebox.showwarning("Warning", "Enter a shielded address in the To field")
            return
        
        limit = simpledialog.askinteger("Limit", "Maximum number of UTXOs to shield:", initialvalue=50, minvalue=0)
        
        def shield():
            result = self.rpc_call("z_shieldcoinbase", [from_addr, to_addr, 0.0001, limit])
            self.tx_output.delete(1.0, tk.END)
            self.tx_output.insert(1.0, "Shielding coinbase funds...\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=shield, daemon=True).start()
    
    def z_mergetoaddress(self):
        """Merge multiple UTXOs to single address"""
        from_addrs = simpledialog.askstring("From Addresses", "Enter from addresses (comma-separated) or * for any:")
        to_addr = self.to_addr.get().strip()
        
        if not from_addrs or not to_addr:
            messagebox.showwarning("Warning", "Enter from addresses and to address")
            return
        
        from_list = [addr.strip() for addr in from_addrs.split(",")] if from_addrs != "*" else ["ANY_TADDR", "ANY_SPROUT", "ANY_SAPLING"]
        
        def merge():
            result = self.rpc_call("z_mergetoaddress", [from_list, to_addr])
            self.tx_output.delete(1.0, tk.END)
            self.tx_output.insert(1.0, "Merging to address...\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=merge, daemon=True).start()
    
    def z_listreceivedbyaddress(self):
        """List amounts received by z-address"""
        address = simpledialog.askstring("List Received", "Enter z-address:")
        if not address:
            return
        
        minconf = simpledialog.askinteger("Min Confirmations", "Minimum confirmations:", initialvalue=1, minvalue=0)
        
        def list_received():
            result = self.rpc_call("z_listreceivedbyaddress", [address, minconf])
            self.tx_output.delete(1.0, tk.END)
            self.tx_output.insert(1.0, f"Received by {address}:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=list_received, daemon=True).start()
    
    def gettransaction(self):
        """Get transaction details"""
        txid = simpledialog.askstring("Get Transaction", "Enter transaction ID (txid):")
        if not txid:
            return
        
        def get():
            result = self.rpc_call("gettransaction", [txid])
            self.tx_output.delete(1.0, tk.END)
            self.tx_output.insert(1.0, json.dumps(result, indent=2))
        
        threading.Thread(target=get, daemon=True).start()
    
    def z_viewtransaction(self):
        """View z-transaction details"""
        txid = simpledialog.askstring("View Z-Transaction", "Enter transaction ID (txid):")
        if not txid:
            return
        
        def view():
            result = self.rpc_call("z_viewtransaction", [txid])
            self.tx_output.delete(1.0, tk.END)
            self.tx_output.insert(1.0, json.dumps(result, indent=2))
        
        threading.Thread(target=view, daemon=True).start()
    
    # ==================== ADDRESS METHODS ====================
    def z_getaddressforaccount(self):
        """Get address for account"""
        account = simpledialog.askinteger("Get Address", "Enter account number:", initialvalue=0, minvalue=0)
        if account is None:
            return
        
        def get():
            result = self.rpc_call("z_getaddressforaccount", [account])
            self.address_output.delete(1.0, tk.END)
            self.address_output.insert(1.0, f"Address for account {account}:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=get, daemon=True).start()
    
    def z_listunifiedreceivers(self):
        """List unified address receivers"""
        address = simpledialog.askstring("List Receivers", "Enter unified address:")
        if not address:
            return
        
        def list_receivers():
            result = self.rpc_call("z_listunifiedreceivers", [address])
            self.address_output.delete(1.0, tk.END)
            self.address_output.insert(1.0, f"Receivers for {address}:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=list_receivers, daemon=True).start()
    
    def z_exportviewingkey(self):
        """Export viewing key for z-address"""
        address = simpledialog.askstring("Export Viewing Key", "Enter z-address:")
        if not address:
            return
        
        def export():
            result = self.rpc_call("z_exportviewingkey", [address])
            self.address_output.delete(1.0, tk.END)
            self.address_output.insert(1.0, f"Viewing key for {address}:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=export, daemon=True).start()
    
    def z_importviewingkey(self):
        """Import viewing key"""
        vkey = simpledialog.askstring("Import Viewing Key", "Enter viewing key:")
        if not vkey:
            return
        
        rescan = messagebox.askyesno("Rescan", "Rescan blockchain?\n(This may take a while)")
        
        def imp():
            result = self.rpc_call("z_importviewingkey", [vkey, "yes" if rescan else "no"])
            self.address_output.delete(1.0, tk.END)
            self.address_output.insert(1.0, "Viewing key imported:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=imp, daemon=True).start()
    
    def z_getbalanceforviewingkey(self):
        """Get balance for viewing key"""
        vkey = simpledialog.askstring("Balance for Viewing Key", "Enter viewing key:")
        if not vkey:
            return
        
        def get():
            result = self.rpc_call("z_getbalanceforviewingkey", [vkey])
            self.address_output.delete(1.0, tk.END)
            self.address_output.insert(1.0, "Balance for viewing key:\n\n" + json.dumps(result, indent=2))
        
        threading.Thread(target=get, daemon=True).start()
    
    # ==================== MINING METHODS ====================
    def generate_blocks(self):
        """Generate blocks (testnet only)"""
        num_blocks = simpledialog.askinteger("Generate Blocks", "Number of blocks to generate:", initialvalue=1, minvalue=1, maxvalue=100)
        
        if not num_blocks:
            return
        
        def generate():
            try:
                result = self.rpc_call("generate", [num_blocks])
                self.mining_output.delete(1.0, tk.END)
                self.mining_output.insert(1.0, f"Generated {num_blocks} block(s):\n\n" + json.dumps(result, indent=2))
            except Exception as e:
                self.mining_output.delete(1.0, tk.END)
                self.mining_output.insert(1.0, f"Error: {str(e)}")
        
        threading.Thread(target=generate, daemon=True).start()
    
    # ==================== CONFIG METHODS ====================
    def load_config(self):
        """Load zcash.conf file"""
        if self.zcash_conf_file.exists():
            try:
                with open(self.zcash_conf_file, 'r') as f:
                    content = f.read()
                    self.config_text.delete(1.0, tk.END)
                    self.config_text.insert(1.0, content)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load config: {str(e)}")
        else:
            messagebox.showinfo("Info", "No configuration file found. Generate a default one first.")
    
    def save_config(self):
        """Save zcash.conf file"""
        try:
            content = self.config_text.get(1.0, tk.END)
            
            # Create backup first
            if self.zcash_conf_file.exists():
                backup_file = self.zcash_conf_dir / f"zcash.conf.backup.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                shutil.copy2(self.zcash_conf_file, backup_file)
            
            # Save new config
            with open(self.zcash_conf_file, 'w') as f:
                f.write(content)
            
            messagebox.showinfo("Success", f"Configuration saved to:\n{self.zcash_conf_file}\n\nRestart node for changes to take effect.")
            
            # Reload RPC config
            self.load_rpc_config()
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save config: {str(e)}")
    
    def generate_default_config(self):
        """Generate default zcash.conf configuration"""
        rpc_password = secrets.token_hex(32)
        
        default_config = f"""# Zcash Configuration File
# Generated by Zcash Production Node Manager

# RPC Settings (required for GUI communication)
server=1
rpcuser=zcashgui
rpcpassword={rpc_password}
rpcallowip=127.0.0.1
rpcport=8232

# Network Selection
# testnet=1          # Uncomment for testnet (faster sync, test funds)
# regtest=1          # Uncomment for regression testing

# Blockchain Indexing (enables full node features)
txindex=1            # Transaction index
addressindex=1       # Address index
timestampindex=1     # Timestamp index
spentindex=1         # Spent index

# Performance Settings
dbcache=2000         # Database cache size in MB
maxconnections=50    # Maximum peer connections
par=4                # Number of script verification threads

# Privacy Settings
listen=1             # Listen for incoming connections
bind=127.0.0.1       # Bind to localhost only

# Logging
debug=1              # Enable debug logging
logtimestamps=1      # Add timestamps to logs
logips=1             # Log IP addresses

# Mining (testnet only - do not use on mainnet without proper setup)
# gen=0              # Enable/disable mining

# Optional: Add nodes to connect to
# addnode=<ip:port>

# Optional: Reduce logs
# printtoconsole=0
"""
        
        self.config_text.delete(1.0, tk.END)
        self.config_text.insert(1.0, default_config)
        
        messagebox.showinfo("Default Config Generated", "Default configuration generated.\n\nReview and click 'Save Config' to apply.")
    
    # ==================== UTILITY METHODS ====================
    def log_install(self, message):
        """Log installation message to output"""
        try:
            self.install_output.insert(tk.END, message)
            self.install_output.see(tk.END)
            self.root.update_idletasks()
        except:
            pass

def main():
    """Main entry point"""
    root = tk.Tk()
    
    # Set app icon if available
    try:
        root.iconbitmap('zcash.ico')
    except:
        pass
    
    # Create application
    app = ProductionZcashNodeManager(root)
    
    # Handle window close
    def on_closing():
        if app.monitoring_active:
            app.stop_monitoring()
        
        if messagebox.askokcancel("Quit", "Stop monitoring and exit?"):
            root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    # Start GUI
    root.mainloop()

if __name__ == "__main__":
    main()