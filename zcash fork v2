"infoURL": "https://zkkaia.org",
  "testnet": false,
  "icon": "zkkaia",
  "features": {
    "EIP155": true,
    "EIP1559": true,
    "EIP2718": true,
    "EIP2930": true
  }
}
EOL

echo "✅ Created chain configuration"

# ============================================================================
# GENESIS CONFIGURATION
# ============================================================================
cat > genesis/zkKaia.json << 'EOL'
{
  "config": {
    "chainId": 1729,
    "homesteadBlock": 0,
    "eip150Block": 0,
    "eip155Block": 0,
    "eip158Block": 0,
    "byzantiumBlock": 0,
    "constantinopleBlock": 0,
    "petersburgBlock": 0,
    "istanbulBlock": 0,
    "muirGlacierBlock": 0,
    "berlinBlock": 0,
    "londonBlock": 0,
    "arrowGlacierBlock": 0,
    "grayGlacierBlock": 0,
    "zkKaiaBlock": 0,
    "zkKaia": {
      "gasPrice": 250000000,
      "blockGasLimit": 30000000,
      "blockPeriod": 1,
      "epochLength": 30000,
      "validatorMinStake": "1000000000000000000",
      "freeTxsPerDay": 10,
      "gasAbstraction": true,
      "gasSponsorship": true
    }
  },
  "nonce": "0x0000000000000042",
  "timestamp": "0x00",
  "extraData": "0x00000000000000000000000000000000000000000000000000000000000000007a6b4b616961204765736573697320426c6f636b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "gasLimit": "0x1C9C380",
  "difficulty": "0x01",
  "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "alloc": {
    "0x0000000000000000000000000000000000000001": {"balance": "0x1"},
    "0x0000000000000000000000000000000000000002": {"balance": "0x1"},
    "0x0000000000000000000000000000000000000003": {"balance": "0x1"},
    "0x0000000000000000000000000000000000000004": {"balance": "0x1"},
    "0x0000000000000000000000000000000000000005": {"balance": "0x1"},
    "0x0000000000000000000000000000000000000006": {"balance": "0x1"},
    "0x0000000000000000000000000000000000000007": {"balance": "0x1"},
    "0x0000000000000000000000000000000000000008": {"balance": "0x1"},
    "0x0000000000000000000000000000000000000009": {"balance": "0x1"}
  },
  "number": "0x00",
  "gasUsed": "0x00",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "baseFeePerGas": "0xEE6B280"
}
EOL

echo "✅ Created genesis configuration"

# ============================================================================
# ENVIRONMENT FILE
# ============================================================================
cat > .env.example << 'EOL'
# Network Configuration
RPC_URL=http://localhost:8545
CHAIN_ID=1729

# Deployment
PRIVATE_KEY=
DEPLOYER_ADDRESS=

# Gas Configuration
GAS_PRICE=250000000
GAS_LIMIT=30000000

# Testing
REPORT_GAS=false
COVERAGE=false

# Optional: Etherscan Verification
ETHERSCAN_API_KEY=
EOL

echo "✅ Created environment template"

# ============================================================================
# COMPLETE SMART CONTRACTS
# ============================================================================

# Contract 1: KaiaGasSystem.sol
cat > contracts/KaiaGasSystem.sol << 'EOL'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title KaiaGasSystem
 * @notice Implements Kaia's gas model with sponsorship and abstraction
 * @dev Manages gas fees, free transactions, and sponsorship
 */
contract KaiaGasSystem {
    address public owner;
    
    // Kaia gas parameters - matching specification
    uint256 public constant GAS_PRICE = 250000000; // 0.25 gwei
    uint256 public constant BLOCK_GAS_LIMIT = 30000000; // 30M gas
    uint256 public constant FREE_TXS_PER_DAY = 10;
    uint256 public constant MAX_BLOCK_SIZE = 4000000;
    
    // User transaction tracking
    mapping(address => uint256) public dailyTxCount;
    mapping(address => uint256) public lastTxDate;
    mapping(address => bool) public sponsoredAccounts;
    mapping(address => address) public sponsorOf; // sponsor => sponsored
    
    // Events
    event GasSponsored(address indexed account, bool sponsored);
    event FreeTxUsed(address indexed account, uint256 remaining);
    event SponsorSet(address indexed sponsor, address indexed sponsored);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    constructor() {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }
    
    /**
     * @notice Calculate gas cost using Kaia's model
     * @param user Address to check
     * @param gasUsed Amount of gas used
     * @return cost The gas cost in wei
     */
    function calculateGasCost(address user, uint256 gasUsed) public view returns (uint256 cost) {
        // Check sponsorship first
        if (sponsoredAccounts[user]) {
            return 0;
        }
        
        // Check free transactions
        if (_hasFreeTransactionsView(user)) {
            return 0;
        }
        
        // Calculate standard cost
        return gasUsed * GAS_PRICE;
    }
    
    /**
     * @notice Check if user has free transactions remaining
     * @param user Address to check
     * @return hasFreeTx True if user has free transactions
     */
    function hasFreeTransactions(address user) public returns (bool hasFreeTx) {
        uint256 today = block.timestamp / 1 days;
        
        // Reset daily count if new day
        if (lastTxDate[user] != today) {
            dailyTxCount[user] = 0;
            lastTxDate[user] = today;
        }
        
        // Check if under limit
        if (dailyTxCount[user] < FREE_TXS_PER_DAY) {
            dailyTxCount[user]++;
            emit FreeTxUsed(user, FREE_TXS_PER_DAY - dailyTxCount[user]);
            return true;
        }
        
        return false;
    }
    
    /**
     * @notice View-only check for free transactions
     * @param user Address to check
     * @return hasFreeTx True if user has free transactions
     */
    function _hasFreeTransactionsView(address user) internal view returns (bool hasFreeTx) {
        uint256 today = block.timestamp / 1 days;
        
        if (lastTxDate[user] != today) {
            return true; // Would be reset
        }
        
        return dailyTxCount[user] < FREE_TXS_PER_DAY;
    }
    
    /**
     * @notice Set sponsorship status for an account
     * @param account Address to sponsor/unsponsor
     * @param sponsored True to sponsor, false to remove sponsorship
     */
    function setSponsored(address account, bool sponsored) external onlyOwner {
        require(account != address(0), "Invalid address");
        sponsoredAccounts[account] = sponsored;
        if (sponsored) {
            sponsorOf[msg.sender] = account;
        }
        emit GasSponsored(account, sponsored);
    }
    
    /**
     * @notice Get current gas parameters
     * @return gasPrice Current gas price
     * @return blockGasLimit Block gas limit
     * @return freeTxsPerDay Free transactions per day
     * @return maxBlockSize Maximum block size
     */
    function getGasParameters() external pure returns (
        uint256 gasPrice,
        uint256 blockGasLimit,
        uint256 freeTxsPerDay,
        uint256 maxBlockSize
    ) {
        return (GAS_PRICE, BLOCK_GAS_LIMIT, FREE_TXS_PER_DAY, MAX_BLOCK_SIZE);
    }
    
    /**
     * @notice Get remaining free transactions for user
     * @param user Address to check
     * @return remaining Number of free transactions remaining today
     */
    function getRemainingFreeTx(address user) external view returns (uint256 remaining) {
        uint256 today = block.timestamp / 1 days;
        
        if (lastTxDate[user] != today) {
            return FREE_TXS_PER_DAY;
        }
        
        if (dailyTxCount[user] >= FREE_TXS_PER_DAY) {
            return 0;
        }
        
        return FREE_TXS_PER_DAY - dailyTxCount[user];
    }
    
    /**
     * @notice Transfer ownership
     * @param newOwner Address of new owner
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid address");
        address oldOwner = owner;
        owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}
EOL

echo "✅ Created KaiaGasSystem.sol"

# Contract 2: ZKProofVerifier.sol
cat > contracts/ZKProofVerifier.sol << 'EOL'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title ZKProofVerifier
 * @notice Library for verifying zk-SNARK proofs using BN254 pairing
 * @dev Implements Groth16 verification with BN254 curve
 */
library ZKProofVerifier {
    
    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
    
    struct VerifyingKey {
        uint256[2] alpha;
        uint256[2][2] beta;
        uint256[2][2] gamma;
        uint256[2][2] delta;
        uint256[2][] IC;
    }
    
    struct Proof {
        uint256[2] A;
        uint256[2][2] B;
        uint256[2] C;
    }
    
    /**
     * @notice Verify zk-SNARK proof
     * @param input Public inputs
     * @param proof The proof to verify
     * @param vk Verifying key
     * @return valid True if proof is valid
     */
    function verify(
        uint256[] memory input,
        Proof memory proof,
        VerifyingKey memory vk
    ) internal view returns (bool valid) {
        require(input.length + 1 == vk.IC.length, "Invalid input length");
        
        // Compute linear combination vk_x
        uint256[2] memory vk_x = vk.IC[0];
        for (uint256 i = 0; i < input.length; i++) {
            vk_x = addition(vk_x, scalarMul(vk.IC[i + 1], input[i]));
        }
        
        // Verify pairing equation
        return pairing(
            negate(proof.A),
            proof.B,
            vk.alpha,
            vk.beta,
            vk_x,
            vk.gamma,
            proof.C,
            vk.delta
        );
    }
    
    /**
     * @notice BN254 pairing check
     */
    function pairing(
        uint256[2] memory a1,
        uint256[2][2] memory b1,
        uint256[2] memory a2,
        uint256[2][2] memory b2,
        uint256[2] memory a3,
        uint256[2][2] memory b3,
        uint256[2] memory a4,
        uint256[2][2] memory b4
    ) internal view returns (bool) {
        uint256[24] memory input;
        input[0] = a1[0];
        input[1] = a1[1];
        input[2] = b1[0][0];
        input[3] = b1[0][1];
        input[4] = b1[1][0];
        input[5] = b1[1][1];
        input[6] = a2[0];
        input[7] = a2[1];
        input[8] = b2[0][0];
        input[9] = b2[0][1];
        input[10] = b2[1][0];
        input[11] = b2[1][1];
        input[12] = a3[0];
        input[13] = a3[1];
        input[14] = b3[0][0];
        input[15] = b3[0][1];
        input[16] = b3[1][0];
        input[17] = b3[1][1];
        input[18] = a4[0];
        input[19] = a4[1];
        input[20] = b4[0][0];
        input[21] = b4[0][1];
        input[22] = b4[1][0];
        input[23] = b4[1][1];
        
        uint256[1] memory out;
        bool success;
        
        assembly {
            success := staticcall(sub(gas(), 2000), 8, input, 768, out, 32)
        }
        
        require(success, "Pairing check failed");
        return out[0] != 0;
    }
    
    /**
     * @notice EC point addition on BN254
     */
    function addition(uint256[2] memory p1, uint256[2] memory p2)
        internal
        view
        returns (uint256[2] memory r)
    {
        uint256[4] memory input;
        input[0] = p1[0];
        input[1] = p1[1];
        input[2] = p2[0];
        input[3] = p2[1];
        
        bool success;
        assembly {
            success := staticcall(sub(gas(), 2000), 6, input, 128, r, 64)
        }
        require(success, "EC addition failed");
    }
    
    /**
     * @notice EC scalar multiplication on BN254
     */
    function scalarMul(uint256[2] memory p, uint256 s)
        internal
        view
        returns (uint256[2] memory r)
    {
        uint256[3] memory input;
        input[0] = p[0];
        input[1] = p[1];
        input[2] = s;
        
        bool success;
        assembly {
            success := staticcall(sub(gas(), 2000), 7, input, 96, r, 64)
        }
        require(success, "EC multiplication failed");
    }
    
    /**
     * @notice Negate EC point
     */
    function negate(uint256[2] memory p) internal pure returns (uint256[2] memory) {
        if (p[0] == 0 && p[1] == 0) {
            return [uint256(0), uint256(0)];
        }
        return [p[0], PRIME_Q - (p[1] % PRIME_Q)];
    }
}
EOL

echo "✅ Created ZKProofVerifier.sol"

# Contract 3: CustomOpcodePrecompiles.sol
cat > contracts/CustomOpcodePrecompiles.sol << 'EOL'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title CustomOpcodePrecompiles
 * @notice Implements zkSync and Kaia custom opcodes as precompile-style functions
 * @dev Uses Ethereum precompiles where possible, implements others in Solidity
 */
contract CustomOpcodePrecompiles {
    
    // ========== zkSync Era Opcodes ==========
    
    /**
     * @notice ZK_ADD (0xc0) - EC point addition on BN254
     */
    function zkAdd(uint256[2] memory p1, uint256[2] memory p2) 
        public view returns (uint256[2] memory result) 
    {
        uint256[4] memory input;
        input[0] = p1[0];
        input[1] = p1[1];
        input[2] = p2[0];
        input[3] = p2[1];
        
        bool success;
        assembly {
            success := staticcall(gas(), 0x06, input, 0x80, result, 0x40)
        }
        require(success, "zkAdd failed");
    }
    
    /**
     * @notice ZK_MUL (0xc1) - EC scalar multiplication on BN254
     */
    function zkMul(uint256[2] memory p, uint256 s) 
        public view returns (uint256[2] memory result) 
    {
        uint256[3] memory input;
        input[0] = p[0];
        input[1] = p[1];
        input[2] = s;
        
        bool success;
        assembly {
            success := staticcall(gas(), 0x07, input, 0x60, result, 0x40)
        }
        require(success, "zkMul failed");
    }
    
    /**
     * @notice ZK_PAIRING (0xc3) - BN254 pairing check
     */
    function zkPairing(uint256[] memory input) 
        public view returns (bool) 
    {
        require(input.length % 6 == 0, "Invalid input length");
        uint256 inputSize = input.length * 32;
        uint256[1] memory output;
        
        bool success;
        assembly {
            success := staticcall(gas(), 0x08, add(input, 0x20), inputSize, output, 0x20)
        }
        require(success, "zkPairing failed");
        return output[0] != 0;
    }
    
    /**
     * @notice ZK_MODEXP (0xc8) - Modular exponentiation
     */
    function zkModExp(uint256 base, uint256 exp, uint256 mod) 
        public view returns (uint256 result) 
    {
        require(mod != 0, "Modulus cannot be zero");
        
        bytes memory input = abi.encodePacked(
            uint256(32), // base length
            uint256(32), // exp length  
            uint256(32), // mod length
            base,
            exp,
            mod
        );
        
        bytes memory output = new bytes(32);
        bool success;
        assembly {
            success := staticcall(gas(), 0x05, add(input, 0x20), mload(input), add(output, 0x20), 0x20)
        }
        require(success, "zkModExp failed");
        
        assembly {
            result := mload(add(output, 0x20))
        }
    }
    
    // ========== Kaia Opcodes ==========
    
    /**
     * @notice KAI_FEE (0xe0) - Dynamic fee calculation
     */
    function kaiFee(address user, uint256 gasUsed) 
        public view returns (uint256) 
    {
        uint256 baseFee = 250000000; // 0.25 gwei
        uint256 congestionMultiplier = _getNetworkCongestion();
        return gasUsed * baseFee * congestionMultiplier / 100;
    }
    
    /**
     * @notice KAI_VALIDATE (0xe1) - Transaction validation
     */
    function kaiValidate(
        address from,
        address to,
        uint256 value,
        bytes memory data,
        bytes memory signature
    ) public pure returns (bool) {
        bytes32 messageHash = keccak256(abi.encodePacked(from, to, value, data));
        bytes32 ethSignedHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash));
        
        address signer = _recoverSigner(ethSignedHash, signature);
        return signer == from;
    }
    
    /**
     * @notice KAI_COMMIT (0xe2) - State commitment
     */
    function kaiCommit(bytes32[] memory stateRoots) 
        public pure returns (bytes32) 
    {
        return keccak256(abi.encodePacked(stateRoots));
    }
    
    /**
     * @notice KAI_RANDOM (0xe5) - Secure random number generation
     */
    function kaiRandom(uint256 seed) public view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty,
            block.number,
            blockhash(block.number - 1),
            seed,
            tx.gasprice
        )));
    }
    
    /**
     * @notice KAI_HASH (0xea) - Kaia double hash
     */
    function kaiHash(bytes memory data) public pure returns (bytes32) {
        bytes32 firstHash = keccak256(data);
        return keccak256(abi.encodePacked(firstHash, data));
    }
    
    /**
     * @notice KAI_MERKLEPROOF (0xeb) - Merkle proof verification
     */
    function kaiMerkleProof(
        bytes32 leaf,
        bytes32[] memory proof,
        bytes32 root
    ) public pure returns (bool) {
        bytes32 computedHash = leaf;
        
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            
            if (computedHash < proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }
        
        return computedHash == root;
    }
    
    // ========== Internal Helpers ==========
    
    function _getNetworkCongestion() internal view returns (uint256) {
        uint256 gasUsed = block.gaslimit - gasleft();
        uint256 utilizationPercent = (gasUsed * 100) / block.gaslimit;
        
        if (utilizationPercent > 90) return 150; // 1.5x
        if (utilizationPercent > 70) return 120; // 1.2x
        return 100; // 1.0x
    }
    
    function _recoverSigner(bytes32 messageHash, bytes memory signature) 
        internal pure returns (address) 
    {
        require(signature.length == 65, "Invalid signature length");
        
        bytes32 r;
        bytes32 s;
        uint8 v;
        
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        
        if (v < 27) {
            v += 27;
        }
        
        require(v == 27 || v == 28, "Invalid signature v value");
        
        return ecrecover(messageHash, v, r, s);
    }
}
EOL

echo "✅ Created CustomOpcodePrecompiles.sol"

# Contract 4: ZKKaiaSystemComplete.sol
cat > contracts/ZKKaiaSystemComplete.sol << 'EOL'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./KaiaGasSystem.sol";
import "./ZKProofVerifier.sol";
import "./CustomOpcodePrecompiles.sol";

/**
 * @title ZKKaiaSystemComplete
 * @notice Complete implementation merging zkSync Era + Kaia
 * @dev Full system with proof verification, gas management, and validators
 */
contract ZKKaiaSystemComplete is KaiaGasSystem {
    using ZKProofVerifier for *;
    
    CustomOpcodePrecompiles public opcodePrecompiles;
    
    struct ZkProof {
        uint256[2] A;
        uint256[2][2] B;
        uint256[2] C;
        uint256[] publicInputs;
        uint256 timestamp;
        bool verified;
    }
    
    struct ZkBlock {
        uint256 blockNumber;
        bytes32 stateRoot;
        bytes32 commitment;
        ZkProof proof;
        uint256 timestamp;
        address proposer;
    }
    
    struct Validator {
        address addr;
        uint256 stake;
        bool active;
        uint256 lastBlock;
        uint256 rewardBalance;
        uint256 slashCount;
    }
    
    // State
    ZKProofVerifier.VerifyingKey public verifyingKey;
    mapping(bytes32 => bool) public processedTxs;
    mapping(address => Validator) public validators;
    address[] public validatorList;
    ZkBlock[] public blocks;
    
    uint256 public currentBlockNumber;
    uint256 public minValidatorStake = 1000 ether;
    uint256 public blockReward = 2 ether;
    
    // Events
    event BlockCommitted(uint256 indexed blockNumber, bytes32 stateRoot, address proposer);
    event TransactionProcessed(bytes32 indexed txHash, address indexed from, uint256 gasUsed);
    event ValidatorAdded(address indexed validator, uint256 stake);
    event ValidatorRemoved(address indexed validator);
    event ValidatorSlashed(address indexed validator, uint256 amount);
    event ProofVerified(bytes32 indexed proofHash, bool valid);
    event CustomOpcodeExecuted(string opcode, address indexed caller);
    event RewardClaimed(address indexed validator, uint256 amount);
    
    constructor() {
        opcodePrecompiles = new CustomOpcodePrecompiles();
        _initializeVerifyingKey();
    }
    
    /**
     * @notice Process transaction with zkProof verification
     */
    function processTransaction(
        address from,
        address to,
        uint256 value,
        bytes calldata data,
        uint256[2] memory proofA,
        uint256[2][2] memory proofB,
        uint256[2] memory proofC,
        uint256[] memory publicInputs
    ) external payable returns (bytes32 txHash) {
        txHash = keccak256(abi.encodePacked(from, to, value, data, block.timestamp, block.number));
        require(!processedTxs[txHash], "Transaction already processed");
        require(msg.value >= value, "Insufficient value sent");
        
        uint256 gasStart = gasleft();
        
        // Verify zkProof
        ZKProofVerifier.Proof memory proof = ZKProofVerifier.Proof(proofA, proofB, proofC);
        bool proofValid = ZKProofVerifier.verify(publicInputs, proof, verifyingKey);
        require(proofValid, "Invalid zkProof");
        
        emit ProofVerified(keccak256(abi.encode(proof)), true);
        
        // Handle gas
        uint256 gasCost = opcodePrecompiles.kaiFee(from, gasStart - gasleft());
        
        if (gasCost == 0 || msg.value >= gasCost + value) {
            // Execute transaction
            (bool success, ) = to.call{value: value}(data);
            require(success, "Transaction execution failed");
            
            processedTxs[txHash] = true;
            emit TransactionProcessed(txHash, from, gasStart - gasleft());
            
            // Refund excess
            if (msg.value > gasCost + value) {
                payable(msg.sender).transfer(msg.value - gasCost - value);
            }
        } else {
            revert("Insufficient gas payment");
        }
        
        return txHash;
    }
    
    /**
     * @notice Commit block with zkProof
     */
    function commitBlock(
        bytes32 stateRoot,
        bytes32 commitment,
        uint256[2] memory proofA,
        uint256[2][2] memory proofB,
        uint256[2] memory proofC,
        uint256[] memory publicInputs
    ) external onlyValidator {
        // Verify state transition proof
        ZKProofVerifier.Proof memory proof = ZKProofVerifier.Proof(proofA, proofB, proofC);
        bool proofValid = ZKProofVerifier.verify(publicInputs, proof, verifyingKey);
        require(proofValid, "Invalid state transition proof");
        
        ZkProof memory zkProof = ZkProof({
            A: proofA,
            B: proofB,
            C: proofC,
            publicInputs: publicInputs,
            timestamp: block.timestamp,
            verified: true
        });
        
        ZkBlock memory newBlock = ZkBlock({
            blockNumber: currentBlockNumber,
            stateRoot: stateRoot,
            commitment: commitment,
            proof: zkProof,
            timestamp: block.timestamp,
            proposer: msg.sender
        });
        
        blocks.push(newBlock);
        currentBlockNumber++;
        
        validators[msg.sender].lastBlock = currentBlockNumber;
        validators[msg.sender].rewardBalance += blockReward;