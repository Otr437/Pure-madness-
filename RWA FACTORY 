// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

/*
Universal RWA Factory - Maximum Security Version
- Deploy ANY Real World Asset (stocks, real estate, commodities, art, etc.)
- Atomic payment verification with CREATE2 deterministic addresses
- User's address in salt for unique deployments per user
- Maximum security with comprehensive verification system
- Zero proxy vulnerabilities - full contract deployments only
- Revenue generation for factory owner through deployment fees
- Complete audit trail for regulatory compliance
*/

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/// ------------------------------------------------------------------------
/// Universal RWA Token Contract - Enhanced for ALL Asset Types
/// ------------------------------------------------------------------------
contract UniversalRWAToken is ERC20, AccessControl, Pausable, ReentrancyGuard {
    using Address for address;
    using Strings for uint256;

    // Role definitions
    bytes32 public constant CUSTODIAN_ROLE = keccak256("CUSTODIAN_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant AUDITOR_ROLE = keccak256("AUDITOR_ROLE");

    // Core configuration
    uint256 public immutable supplyCap;
    address public priceOracle;
    uint256 public deploymentTimestamp;
    address public factoryAddress;

    // Enhanced tracking with gas optimization
    bytes32[] private _attestationIds;
    uint256 public totalBackedAmount;
    uint256 public totalMintedAmount;
    uint256 public totalRedeemedAmount;
    uint256 public totalActiveRedemptions;

    // RWA Asset Information - Universal Support
    struct AssetInfo {
        string assetType;        // "STOCK", "REAL_ESTATE", "COMMODITY", "ART", "BOND", etc.
        string assetId;          // Unique identifier: ticker, address, serial number, etc.
        string assetDescription; // Human readable description
        string assetLocation;    // Geographic location or exchange
        uint256 assetValue;      // Current market value in USD (18 decimals)
        string regulatoryInfo;   // Compliance and regulatory details
        string[] documents;      // IPFS hashes of legal documents
        bool verified;           // Verification status by auditor
    }
    AssetInfo public assetInfo;

    // Enhanced attestation system
    struct Attestation {
        address custodian;
        uint256 amount;
        uint256 minted;
        uint256 redeemed;
        uint256 timestamp;
        uint256 expiryTimestamp;
        string metadata;
        string custodianInfo;
        string verificationHash;
        bool exists;
        bool active;
        bool auditorVerified;
    }
    mapping(bytes32 => Attestation) public attestations;
    mapping(address => bytes32[]) public custodianAttestations;

    // Enhanced redemption tracking
    struct Redemption {
        address requester;
        uint256 amount;
        bytes32 attestationId;
        uint256 timestamp;
        uint256 deadline;
        string deliveryInstructions;
        bool settled;
        bool expired;
    }
    uint256 public redemptionCounter;
    mapping(uint256 => Redemption) public redemptions;
    mapping(address => uint256[]) public userRedemptions;

    // Security and compliance features
    mapping(address => bool) public blacklisted;
    mapping(string => bool) public supportedAssetTypes;
    uint256 public minAttestationAmount;
    uint256 public maxAttestationDuration;
    uint256 public redemptionDeadlineDays;

    // Comprehensive events
    event AssetVerified(address indexed auditor, uint256 timestamp);
    event AttestationCreated(bytes32 indexed attestationId, address indexed custodian, uint256 amount, uint256 expiry);
    event AttestationVerified(bytes32 indexed attestationId, address indexed auditor);
    event MintedWithAttestation(bytes32 indexed attestationId, address indexed to, uint256 amount);
    event RedemptionRequested(uint256 indexed redemptionId, address indexed requester, uint256 amount, uint256 deadline);
    event RedemptionSettled(uint256 indexed redemptionId, bytes32 indexed attestationId, address indexed custodian);
    event RedemptionExpired(uint256 indexed redemptionId);
    event AttestationUpdated(bytes32 indexed attestationId, uint256 minted, uint256 redeemed);
    event AttestationExpired(bytes32 indexed attestationId);
    event UserBlacklisted(address indexed user, bool status);
    event AssetValueUpdated(uint256 oldValue, uint256 newValue);
    event EmergencyPause(address indexed pauser, string reason);

    modifier notBlacklisted(address user) {
        require(!blacklisted[user], "User blacklisted");
        _;
    }

    modifier onlyValidAssetType(string memory assetType) {
        require(supportedAssetTypes[assetType] || hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Unsupported asset type");
        _;
    }

    constructor(
        string memory name_,
        string memory symbol_,
        uint256 cap_,
        address initialAdmin_,
        string memory assetType_,
        string memory assetId_,
        string memory assetDescription_,
        string memory assetLocation_
    ) ERC20(name_, symbol_) {
        require(initialAdmin_ != address(0), "Invalid admin");
        require(bytes(name_).length > 0 && bytes(name_).length <= 50, "Invalid name length");
        require(bytes(symbol_).length > 0 && bytes(symbol_).length <= 10, "Invalid symbol length");
        require(bytes(assetType_).length > 0, "Asset type required");
        require(bytes(assetId_).length > 0, "Asset ID required");

        supplyCap = cap_;
        deploymentTimestamp = block.timestamp;
        factoryAddress = msg.sender;

        // Initialize asset info
        assetInfo = AssetInfo({
            assetType: assetType_,
            assetId: assetId_,
            assetDescription: assetDescription_,
            assetLocation: assetLocation_,
            assetValue: 0,
            regulatoryInfo: "",
            documents: new string[](0),
            verified: false
        });

        // Setup roles
        _setupRole(DEFAULT_ADMIN_ROLE, initialAdmin_);
        _setupRole(PAUSER_ROLE, initialAdmin_);

        // Initialize security parameters
        minAttestationAmount = 1e18; // 1 token minimum
        maxAttestationDuration = 365 days;
        redemptionDeadlineDays = 30;

        // Initialize supported asset types
        _initializeSupportedAssetTypes();
    }

    function _initializeSupportedAssetTypes() private {
        supportedAssetTypes["STOCK"] = true;
        supportedAssetTypes["BOND"] = true;
        supportedAssetTypes["REAL_ESTATE"] = true;
        supportedAssetTypes["COMMODITY"] = true;
        supportedAssetTypes["ART"] = true;
        supportedAssetTypes["COLLECTIBLE"] = true;
        supportedAssetTypes["EQUIPMENT"] = true;
        supportedAssetTypes["INVOICE"] = true;
        supportedAssetTypes["CARBON_CREDIT"] = true;
        supportedAssetTypes["INTELLECTUAL_PROPERTY"] = true;
        supportedAssetTypes["PRECIOUS_METAL"] = true;
        supportedAssetTypes["ENERGY_ASSET"] = true;
        supportedAssetTypes["AGRICULTURAL"] = true;
        supportedAssetTypes["INFRASTRUCTURE"] = true;
        supportedAssetTypes["PRIVATE_EQUITY"] = true;
        supportedAssetTypes["DEBT_INSTRUMENT"] = true;
        supportedAssetTypes["REVENUE_STREAM"] = true;
        supportedAssetTypes["OTHER"] = true;
    }

    // === ASSET VERIFICATION SYSTEM ===
    function verifyAsset(
        string calldata regulatoryInfo,
        string[] calldata documents
    ) external onlyRole(AUDITOR_ROLE) {
        assetInfo.regulatoryInfo = regulatoryInfo;
        delete assetInfo.documents;
        for (uint256 i = 0; i < documents.length; i++) {
            assetInfo.documents.push(documents[i]);
        }
        assetInfo.verified = true;
        emit AssetVerified(msg.sender, block.timestamp);
    }

    function updateAssetValue(uint256 newValue) external onlyRole(AUDITOR_ROLE) {
        uint256 oldValue = assetInfo.assetValue;
        assetInfo.assetValue = newValue;
        emit AssetValueUpdated(oldValue, newValue);
    }

    // === ENHANCED ATTESTATION SYSTEM ===
    function createAttestation(
        bytes32 attestationId,
        uint256 amount,
        uint256 durationDays,
        string calldata metadata,
        string calldata custodianInfo,
        string calldata verificationHash
    ) external onlyRole(CUSTODIAN_ROLE) whenNotPaused notBlacklisted(msg.sender) {
        require(attestationId != bytes32(0), "Invalid attestation ID");
        require(amount >= minAttestationAmount, "Amount below minimum");
        require(durationDays > 0 && durationDays <= (maxAttestationDuration / 1 days), "Invalid duration");
        require(!attestations[attestationId].exists, "Attestation exists");
        require(bytes(custodianInfo).length > 0, "Custodian info required");

        uint256 expiryTimestamp = block.timestamp + (durationDays * 1 days);

        attestations[attestationId] = Attestation({
            custodian: msg.sender,
            amount: amount,
            minted: 0,
            redeemed: 0,
            timestamp: block.timestamp,
            expiryTimestamp: expiryTimestamp,
            metadata: metadata,
            custodianInfo: custodianInfo,
            verificationHash: verificationHash,
            exists: true,
            active: true,
            auditorVerified: false
        });

        _attestationIds.push(attestationId);
        custodianAttestations[msg.sender].push(attestationId);
        totalBackedAmount += amount;

        emit AttestationCreated(attestationId, msg.sender, amount, expiryTimestamp);
    }

    function verifyAttestation(bytes32 attestationId) external onlyRole(AUDITOR_ROLE) {
        Attestation storage attestation = attestations[attestationId];
        require(attestation.exists, "Attestation not found");
        require(attestation.active, "Attestation inactive");
        require(block.timestamp < attestation.expiryTimestamp, "Attestation expired");

        attestation.auditorVerified = true;
        emit AttestationVerified(attestationId, msg.sender);
    }

    function increaseAttestation(
        bytes32 attestationId,
        uint256 extraAmount,
        uint256 additionalDays
    ) external onlyRole(CUSTODIAN_ROLE) whenNotPaused notBlacklisted(msg.sender) {
        Attestation storage attestation = attestations[attestationId];
        require(attestation.exists && attestation.active, "Invalid attestation");
        require(attestation.custodian == msg.sender, "Not attestation owner");
        require(extraAmount > 0, "Invalid extra amount");
        require(block.timestamp < attestation.expiryTimestamp, "Attestation expired");

        attestation.amount += extraAmount;
        if (additionalDays > 0) {
            attestation.expiryTimestamp += (additionalDays * 1 days);
        }
        
        totalBackedAmount += extraAmount;
        emit AttestationUpdated(attestationId, attestation.minted, attestation.redeemed);
    }

    // === ENHANCED MINTING SYSTEM ===
    function mintWithAttestation(
        bytes32 attestationId,
        address to,
        uint256 amount
    ) external onlyRole(MINTER_ROLE) nonReentrant whenNotPaused notBlacklisted(to) {
        require(to != address(0), "Invalid recipient");
        require(amount > 0, "Invalid amount");

        Attestation storage attestation = attestations[attestationId];
        require(attestation.exists && attestation.active, "Invalid attestation");
        require(attestation.auditorVerified, "Attestation not verified");
        require(block.timestamp < attestation.expiryTimestamp, "Attestation expired");

        uint256 availableCapacity = attestation.amount - attestation.minted;
        require(availableCapacity >= amount, "Insufficient attestation capacity");

        if (supplyCap > 0) {
            require(totalSupply() + amount <= supplyCap, "Supply cap exceeded");
        }

        attestation.minted += amount;
        totalMintedAmount += amount;
        _mint(to, amount);

        emit MintedWithAttestation(attestationId, to, amount);
        emit AttestationUpdated(attestationId, attestation.minted, attestation.redeemed);
    }

    function batchMintWithAttestations(
        bytes32[] calldata attestationIds_,
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external onlyRole(MINTER_ROLE) nonReentrant whenNotPaused {
        require(
            attestationIds_.length == recipients.length && 
            recipients.length == amounts.length && 
            amounts.length <= 50, 
            "Invalid arrays"
        );

        for (uint256 i = 0; i < attestationIds_.length; i++) {
            _mintWithAttestationInternal(attestationIds_[i], recipients[i], amounts[i]);
        }
    }

    function _mintWithAttestationInternal(bytes32 attestationId, address to, uint256 amount) internal {
        require(to != address(0) && !blacklisted[to], "Invalid recipient");
        require(amount > 0, "Invalid amount");

        Attestation storage attestation = attestations[attestationId];
        require(attestation.exists && attestation.active && attestation.auditorVerified, "Invalid attestation");
        require(block.timestamp < attestation.expiryTimestamp, "Attestation expired");

        uint256 availableCapacity = attestation.amount - attestation.minted;
        require(availableCapacity >= amount, "Insufficient capacity");

        if (supplyCap > 0) {
            require(totalSupply() + amount <= supplyCap, "Supply cap exceeded");
        }

        attestation.minted += amount;
        totalMintedAmount += amount;
        _mint(to, amount);

        emit MintedWithAttestation(attestationId, to, amount);
        emit AttestationUpdated(attestationId, attestation.minted, attestation.redeemed);
    }

    // === ENHANCED REDEMPTION SYSTEM ===
    function requestRedemption(
        uint256 amount,
        bytes32 attestationHint,
        string calldata deliveryInstructions
    ) external nonReentrant whenNotPaused notBlacklisted(msg.sender) {
        require(amount > 0, "Invalid amount");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        require(bytes(deliveryInstructions).length > 0, "Delivery instructions required");

        _burn(msg.sender, amount);

        uint256 redemptionId = ++redemptionCounter;
        uint256 deadline = block.timestamp + (redemptionDeadlineDays * 1 days);

        redemptions[redemptionId] = Redemption({
            requester: msg.sender,
            amount: amount,
            attestationId: attestationHint,
            timestamp: block.timestamp,
            deadline: deadline,
            deliveryInstructions: deliveryInstructions,
            settled: false,
            expired: false
        });

        userRedemptions[msg.sender].push(redemptionId);
        totalActiveRedemptions++;

        emit RedemptionRequested(redemptionId, msg.sender, amount, deadline);
    }

    function settleRedemption(
        uint256 redemptionId,
        bytes32 attestationId
    ) external onlyRole(CUSTODIAN_ROLE) nonReentrant whenNotPaused {
        Redemption storage redemption = redemptions[redemptionId];
        require(redemption.amount > 0, "Invalid redemption");
        require(!redemption.settled && !redemption.expired, "Redemption not active");
        require(block.timestamp <= redemption.deadline, "Redemption expired");

        Attestation storage attestation = attestations[attestationId];
        require(attestation.exists && attestation.active, "Invalid attestation");
        require(attestation.custodian == msg.sender, "Not attestation owner");

        uint256 availableToRedeem = attestation.minted - attestation.redeemed;
        require(availableToRedeem >= redemption.amount, "Insufficient attestation funds");

        attestation.redeemed += redemption.amount;
        totalRedeemedAmount += redemption.amount;
        redemption.settled = true;
        totalActiveRedemptions--;

        emit RedemptionSettled(redemptionId, attestationId, msg.sender);
        emit AttestationUpdated(attestationId, attestation.minted, attestation.redeemed);
    }

    function expireRedemption(uint256 redemptionId) external {
        Redemption storage redemption = redemptions[redemptionId];
        require(redemption.amount > 0, "Invalid redemption");
        require(!redemption.settled && !redemption.expired, "Redemption not active");
        require(block.timestamp > redemption.deadline, "Redemption not expired yet");

        redemption.expired = true;
        totalActiveRedemptions--;

        // Refund tokens to original requester
        _mint(redemption.requester, redemption.amount);

        emit RedemptionExpired(redemptionId);
    }

    // === SECURITY AND COMPLIANCE ===
    function setBlacklistStatus(address user, bool status) external onlyRole(DEFAULT_ADMIN_ROLE) {
        blacklisted[user] = status;
        emit UserBlacklisted(user, status);
    }

    function addSupportedAssetType(string calldata assetType) external onlyRole(DEFAULT_ADMIN_ROLE) {
        supportedAssetTypes[assetType] = true;
    }

    function emergencyPause(string calldata reason) external onlyRole(PAUSER_ROLE) {
        _pause();
        emit EmergencyPause(msg.sender, reason);
    }

    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function setPriceOracle(address oracle) external onlyRole(DEFAULT_ADMIN_ROLE) {
        priceOracle = oracle;
    }

    function setMinAttestationAmount(uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        minAttestationAmount = amount;
    }

    function setRedemptionDeadline(uint256 days_) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(days_ > 0 && days_ <= 365, "Invalid deadline");
        redemptionDeadlineDays = days_;
    }

    function rescueERC20(address token, address to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(token != address(this), "Cannot rescue own token");
        require(to != address(0), "Invalid recipient");
        IERC20(token).transfer(to, amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) 
        internal override whenNotPaused 
    {
        require(!blacklisted[from] && !blacklisted[to], "Transfer involves blacklisted address");
        super._beforeTokenTransfer(from, to, amount);
    }

    // === COMPREHENSIVE VIEW FUNCTIONS ===
    function getAssetInfo() external view returns (AssetInfo memory) {
        return assetInfo;
    }

    function getAttestation(bytes32 attestationId) external view returns (Attestation memory) {
        require(attestations[attestationId].exists, "Attestation not found");
        return attestations[attestationId];
    }

    function getAttestationCount() external view returns (uint256) {
        return _attestationIds.length;
    }

    function getAttestationIdByIndex(uint256 index) external view returns (bytes32) {
        require(index < _attestationIds.length, "Index out of bounds");
        return _attestationIds[index];
    }

    function getCustodianAttestations(address custodian) external view returns (bytes32[] memory) {
        return custodianAttestations[custodian];
    }

    function getUserRedemptions(address user) external view returns (uint256[] memory) {
        return userRedemptions[user];
    }

    function getBackingRatio() external view returns (uint256) {
        uint256 supply = totalSupply();
        return supply == 0 ? 0 : (totalBackedAmount * 1e18) / supply;
    }

    function getUtilizationRatio() external view returns (uint256) {
        return totalBackedAmount == 0 ? 0 : (totalMintedAmount * 1e18) / totalBackedAmount;
    }

    function getProtocolStats() external view returns (
        uint256 totalBacked,
        uint256 totalSupply_,
        uint256 totalMinted_,
        uint256 totalRedeemed_,
        uint256 backingRatio,
        uint256 utilizationRatio,
        uint256 attestationCount,
        uint256 activeRedemptionCount
    ) {
        totalBacked = totalBackedAmount;
        totalSupply_ = totalSupply();
        totalMinted_ = totalMintedAmount;
        totalRedeemed_ = totalRedeemedAmount;
        
        backingRatio = totalSupply_ == 0 ? 0 : (totalBacked * 1e18) / totalSupply_;
        utilizationRatio = totalBacked == 0 ? 0 : (totalMinted_ * 1e18) / totalBacked;
        attestationCount = _attestationIds.length;
        activeRedemptionCount = totalActiveRedemptions;
    }
}

/// ------------------------------------------------------------------------
/// Universal RWA Factory - Maximum Security & Revenue Generation
/// ------------------------------------------------------------------------
contract UniversalRWAFactory is Ownable, ReentrancyGuard, Pausable {
    using Address for address;

    // Fee configuration - supports ETH and ERC20 payments
    address public paymentToken; // address(0) = ETH, otherwise ERC20
    uint256 public baseFee;
    
    // Enhanced fee structure
    struct FeeTier {
        string name;
        uint256 fee;
        uint256 maxSupplyCap;
        bool active;
        string description;
    }
    mapping(uint256 => FeeTier) public feeTiers;
    uint256 public feeTierCount;

    // Deployment tracking with maximum security
    mapping(bytes32 => address) public deployedTokens; // assetKey => token address
    mapping(address => DeploymentInfo[]) public creatorDeployments;
    mapping(string => address[]) public assetTypeDeployments;
    
    struct DeploymentInfo {
        address tokenAddress;
        address creator;
        string assetType;
        string assetId;
        string name;
        string symbol;
        uint256 supplyCap;
        uint256 timestamp;
        uint256 feePaid;
        uint256 feeTierUsed;
        bool active;
        bool verified;
    }
    DeploymentInfo[] public allDeployments;

    // Security features
    mapping(address => bool) public blacklistedCreators;
    mapping(string => bool) public restrictedAssetTypes;
    mapping(address => uint256) public creatorDeploymentCount;
    uint256 public maxDeploymentsPerCreator;
    uint256 public deploymentCooldownSeconds;
    mapping(address => uint256) public lastDeploymentTime;

    // Revenue and statistics
    uint256 public totalFeesCollected;
    uint256 public totalActiveDeployments;
    mapping(address => uint256) public feesCollectedByToken;

    // Comprehensive events
    event TokenDeployed(
        address indexed tokenAddress,
        address indexed creator,
        string assetType,
        string assetId,
        bytes32 indexed assetKey,
        uint256 feePaid
    );
    event FeeConfigUpdated(address indexed paymentToken, uint256 newFee);
    event FeeTierAdded(uint256 indexed tierId, string name, uint256 fee);
    event DeploymentVerified(address indexed tokenAddress, address indexed verifier);
    event DeploymentDeactivated(address indexed tokenAddress, string reason);
    event CreatorBlacklisted(address indexed creator, bool status);
    event FeesWithdrawn(address indexed to, uint256 amount);
    event EmergencyShutdown(string reason);

    modifier notBlacklistedCreator() {
        require(!blacklistedCreators[msg.sender], "Creator blacklisted");
        _;
    }

    modifier respectsCooldown() {
        require(
            lastDeploymentTime[msg.sender] + deploymentCooldownSeconds <= block.timestamp,
            "Deployment cooldown active"
        );
        _;
    }

    modifier respectsDeploymentLimit() {
        require(
            creatorDeploymentCount[msg.sender] < maxDeploymentsPerCreator,
            "Max deployments exceeded"
        );
        _;
    }

    constructor(
        address _paymentToken,
        uint256 _baseFee,
        uint256 _maxDeploymentsPerCreator,
        uint256 _deploymentCooldownSeconds
    ) {
        paymentToken = _paymentToken;
        baseFee = _baseFee;
        maxDeploymentsPerCreator = _maxDeploymentsPerCreator;
        deploymentCooldownSeconds = _deploymentCooldownSeconds;

        // Initialize default fee tier
        feeTiers[0] = FeeTier({
            name: "Standard",
            fee: _baseFee,
            maxSupplyCap: type(uint256).max,
            active: true,
            description: "Standard deployment tier"
        });
        feeTierCount = 1;
    }

    receive() external payable {
        // Accept ETH payments
    }

    // === FEE MANAGEMENT ===
    function updateFeeConfig(address _paymentToken, uint256 _baseFee) 
        external onlyOwner 
    {
        paymentToken = _paymentToken;
        baseFee = _baseFee;
        feeTiers[0].fee = _baseFee; // Update default tier
        emit FeeConfigUpdated(_paymentToken, _baseFee);
    }

    function addFeeTier(
        string calldata name,
        uint256 fee,
        uint256 maxSupplyCap,
        string calldata description
    ) external onlyOwner {
        feeTiers[feeTierCount] = FeeTier({
            name: name,
            fee: fee,
            maxSupplyCap: maxSupplyCap,
            active: true,
            description: description
        });
        
        emit FeeTierAdded(feeTierCount, name, fee);
        feeTierCount++;
    }

    function updateFeeTier(
        uint256 tierId,
        uint256 newFee,
        uint256 newMaxSupplyCap,
        bool active
    ) external onlyOwner {
        require(tierId < feeTierCount, "Invalid tier ID");
        
        feeTiers[tierId].fee = newFee;
        feeTiers[tierId].maxSupplyCap = newMaxSupplyCap;
        feeTiers[tierId].active = active;
    }

    // === DEPLOYMENT FUNCTIONS ===
    function deployUniversalRWA(
        string calldata name,
        string calldata symbol,
        uint256 supplyCap,
        address initialAdmin,
        string calldata assetType,
        string calldata assetId,
        string calldata assetDescription,
        string calldata assetLocation,
        bytes32 userSalt
    ) external payable nonReentrant whenNotPaused 
        notBlacklistedCreator 
        respectsCooldown 
        respectsDeploymentLimit 
        returns (address deployedToken) 
    {
        return _deployWithFeeTier(
            name, symbol, supplyCap, initialAdmin,
            assetType, assetId, assetDescription, assetLocation,
            userSalt, 0
        );
    }

    function deployUniversalRWAWithTier(
        string calldata name,
        string calldata symbol,
        uint256 supplyCap,
        address initialAdmin,
        string calldata assetType,
        string calldata assetId,
        string calldata assetDescription,
        string calldata assetLocation,
        bytes32 userSalt,
        uint256 feeTierId
    ) external payable nonReentrant whenNotPaused 
        notBlacklistedCreator 
        respectsCooldown 
        respectsDeploymentLimit 
        returns (address deployedToken) 
    {
        require(feeTierId < feeTierCount, "Invalid fee tier");
        require(feeTiers[feeTierId].active, "Fee tier inactive");
        require(supplyCap <= feeTiers[feeTierId].maxSupplyCap, "Supply cap exceeds tier limit");
        
        return _deployWithFeeTier(
            name, symbol, supplyCap, initialAdmin,
            assetType, assetId, assetDescription, assetLocation,
            userSalt, feeTierId
        );
    }

    function _deployWithFeeTier(
        string calldata name,
        string calldata symbol,
        uint256 supplyCap,
        address initialAdmin,
        string calldata assetType,
        string calldata assetId,
        string calldata assetDescription,
        string calldata assetLocation,
        bytes32 userSalt,
        uint256 feeTierId
    ) internal returns (address deployedToken) {
        // Validate inputs with enhanced checks
        require(bytes(name).length > 0 && bytes(name).length <= 50, "Invalid name");
        require(bytes(symbol).length > 0 && bytes(symbol).length <= 10, "Invalid symbol");
        require(bytes(assetType).length > 0, "Asset type required");
        require(bytes(assetId).length > 0, "Asset ID required");
        require(!restrictedAssetTypes[assetType], "Asset type restricted");

        // Generate unique asset key
        bytes32 assetKey = keccak256(abi.encodePacked(assetType, assetId, msg.sender));
        require(deployedTokens[assetKey] == address(0), "Asset already deployed by this creator");

        // Handle atomic payment verification
        FeeTier memory tier = feeTiers[feeTierId];
        uint256 requiredFee = tier.fee;
        
        if (paymentToken == address(0)) {
            require(msg.value == requiredFee, "Incorrect ETH payment");
        } else {
            require(msg.value == 0, "Do not send ETH");
            IERC20(paymentToken).transferFrom(msg.sender, address(this), requiredFee);
        }

        // Determine admin address
        address adminToUse = initialAdmin == address(0) ? msg.sender : initialAdmin;

        // Create deterministic salt with user's address for uniqueness
        bytes32 salt = keccak256(abi.encodePacked(
            assetType, 
            assetId, 
            msg.sender, 
            userSalt,
            block.timestamp
        ));

        // Deploy new RWA token contract
        bytes memory initCode = abi.encodePacked(
            type(UniversalRWAToken).creationCode,
            abi.encode(
                name,
                symbol,
                supplyCap,
                adminToUse,
                assetType,
                assetId,
                assetDescription,
                assetLocation
            )
        );

        address tokenAddress;
        assembly {
            tokenAddress := create2(0, add(initCode, 0x20), mload(initCode), salt)
            if iszero(tokenAddress) { revert(0, 0) }
        }

        // Record deployment with comprehensive tracking
        deployedTokens[assetKey] = tokenAddress;
        
        DeploymentInfo memory deployment = DeploymentInfo({
            tokenAddress: tokenAddress,
            creator: msg.sender,
            assetType: assetType,
            assetId: assetId,
            name: name,
            symbol: symbol,
            supplyCap: supplyCap,
            timestamp: block.timestamp,
            feePaid: requiredFee,
            feeTierUsed: feeTierId,
            active: true,
            verified: false
        });

        allDeployments.push(deployment);
        creatorDeployments[msg.sender].push(deployment);
        assetTypeDeployments[assetType].push(tokenAddress);
        
        // Update statistics and limits
        creatorDeploymentCount[msg.sender]++;
        lastDeploymentTime[msg.sender] = block.timestamp;
        totalFeesCollected += requiredFee;
        totalActiveDeployments++;
        feesCollectedByToken[paymentToken] += requiredFee;

        emit TokenDeployed(tokenAddress, msg.sender, assetType, assetId, assetKey, requiredFee);
        return tokenAddress;
    }

    // === ADDRESS COMPUTATION ===
    function computeTokenAddress(
        string calldata name,
        string calldata symbol,
        uint256 supplyCap,
        address initialAdmin,
        string calldata assetType,
        string calldata assetId,
        string calldata assetDescription,
        string calldata assetLocation,
        address creator,
        bytes32 userSalt,
        uint256 timestamp
    ) external view returns (address) {
        address adminToUse = initialAdmin == address(0) ? creator : initialAdmin;
        
        bytes32 salt = keccak256(abi.encodePacked(
            assetType, 
            assetId, 
            creator, 
            userSalt,
            timestamp
        ));

        bytes memory initCode = abi.encodePacked(
            type(UniversalRWAToken).creationCode,
            abi.encode(
                name, symbol, supplyCap, adminToUse,
                assetType, assetId, assetDescription, assetLocation
            )
        );

        bytes32 hash = keccak256(abi.encodePacked(
            bytes1(0xff),
            address(this),
            salt,
            keccak256(initCode)
        ));

        return address(uint160(uint256(hash)));
    }

    // === SECURITY AND COMPLIANCE ===
    function setCreatorBlacklist(address creator, bool blacklisted) external onlyOwner {
        blacklistedCreators[creator] = blacklisted;
        emit CreatorBlacklisted(creator, blacklisted);
    }

    function setAssetTypeRestriction(string calldata assetType, bool restricted) external onlyOwner {
        restrictedAssetTypes[assetType] = restricted;
    }

    function verifyDeployment(address tokenAddress) external onlyOwner {
        for (uint256 i = 0; i < allDeployments.length; i++) {
            if (allDeployments[i].tokenAddress == tokenAddress) {
                allDeployments[i].verified = true;
                emit DeploymentVerified(tokenAddress, msg.sender);
                return;
            }
        }
        revert("Deployment not found");
    }

    function deactivateDeployment(address tokenAddress, string calldata reason) external onlyOwner {
        for (uint256 i = 0; i < allDeployments.length; i++) {
            if (allDeployments[i].tokenAddress == tokenAddress && allDeployments[i].active) {
                allDeployments[i].active = false;
                totalActiveDeployments--;
                emit DeploymentDeactivated(tokenAddress, reason);
                return;
            }
        }
        revert("Active deployment not found");
    }

    function setDeploymentLimits(
        uint256 _maxDeploymentsPerCreator,
        uint256 _deploymentCooldownSeconds
    ) external onlyOwner {
        maxDeploymentsPerCreator = _maxDeploymentsPerCreator;
        deploymentCooldownSeconds = _deploymentCooldownSeconds;
    }

    function emergencyShutdown(string calldata reason) external onlyOwner {
        _pause();
        emit EmergencyShutdown(reason);
    }

    function resume() external onlyOwner {
        _unpause();
    }

    // === REVENUE MANAGEMENT ===
    function withdrawFees(address to, uint256 amount) external onlyOwner nonReentrant {
        require(to != address(0), "Invalid recipient");
        
        if (paymentToken == address(0)) {
            require(address(this).balance >= amount, "Insufficient ETH balance");
            payable(to).transfer(amount);
        } else {
            require(IERC20(paymentToken).balanceOf(address(this)) >= amount, "Insufficient token balance");
            IERC20(paymentToken).transfer(to, amount);
        }
        
        emit FeesWithdrawn(to, amount);
    }

    function withdrawAllFees(address to) external onlyOwner nonReentrant {
        require(to != address(0), "Invalid recipient");
        
        uint256 amount;
        if (paymentToken == address(0)) {
            amount = address(this).balance;
            if (amount > 0) {
                payable(to).transfer(amount);
            }
        } else {
            amount = IERC20(paymentToken).balanceOf(address(this));
            if (amount > 0) {
                IERC20(paymentToken).transfer(to, amount);
            }
        }
        
        if (amount > 0) {
            emit FeesWithdrawn(to, amount);
        }
    }

    function rescueERC20(address token, address to, uint256 amount) external onlyOwner {
        require(to != address(0), "Invalid recipient");
        require(token != paymentToken, "Cannot rescue payment token");
        IERC20(token).transfer(to, amount);
    }

    // === COMPREHENSIVE VIEW FUNCTIONS ===
    function getTotalDeployments() external view returns (uint256) {
        return allDeployments.length;
    }

    function getDeployment(uint256 index) external view returns (DeploymentInfo memory) {
        require(index < allDeployments.length, "Index out of bounds");
        return allDeployments[index];
    }

    function getDeploymentsByCreator(address creator) external view returns (DeploymentInfo[] memory) {
        return creatorDeployments[creator];
    }

    function getDeploymentsByAssetType(string calldata assetType) external view returns (address[] memory) {
        return assetTypeDeployments[assetType];
    }

    function getActiveDeployments() external view returns (DeploymentInfo[] memory) {
        uint256 activeCount;
        for (uint256 i = 0; i < allDeployments.length; i++) {
            if (allDeployments[i].active) {
                activeCount++;
            }
        }

        DeploymentInfo[] memory active = new DeploymentInfo[](activeCount);
        uint256 index;
        for (uint256 i = 0; i < allDeployments.length; i++) {
            if (allDeployments[i].active) {
                active[index] = allDeployments[i];
                index++;
            }
        }
        return active;
    }

    function getVerifiedDeployments() external view returns (DeploymentInfo[] memory) {
        uint256 verifiedCount;
        for (uint256 i = 0; i < allDeployments.length; i++) {
            if (allDeployments[i].verified && allDeployments[i].active) {
                verifiedCount++;
            }
        }

        DeploymentInfo[] memory verified = new DeploymentInfo[](verifiedCount);
        uint256 index;
        for (uint256 i = 0; i < allDeployments.length; i++) {
            if (allDeployments[i].verified && allDeployments[i].active) {
                verified[index] = allDeployments[i];
                index++;
            }
        }
        return verified;
    }

    function getFeeTier(uint256 tierId) external view returns (FeeTier memory) {
        require(tierId < feeTierCount, "Invalid tier ID");
        return feeTiers[tierId];
    }

    function getAllFeeTiers() external view returns (FeeTier[] memory) {
        FeeTier[] memory tiers = new FeeTier[](feeTierCount);
        for (uint256 i = 0; i < feeTierCount; i++) {
            tiers[i] = feeTiers[i];
        }
        return tiers;
    }

    function isAssetDeployedBy(
        string calldata assetType,
        string calldata assetId,
        address creator
    ) external view returns (bool deployed, address tokenAddress) {
        bytes32 assetKey = keccak256(abi.encodePacked(assetType, assetId, creator));
        tokenAddress = deployedTokens[assetKey];
        deployed = tokenAddress != address(0);
    }

    function getCreatorStats(address creator) external view returns (
        uint256 totalDeployments,
        uint256 activeDeployments,
        uint256 verifiedDeployments,
        uint256 totalFeesPaid,
        uint256 lastDeployment,
        bool blacklisted
    ) {
        DeploymentInfo[] memory creatorDeps = creatorDeployments[creator];
        totalDeployments = creatorDeps.length;
        
        for (uint256 i = 0; i < creatorDeps.length; i++) {
            if (creatorDeps[i].active) {
                activeDeployments++;
            }
            if (creatorDeps[i].verified) {
                verifiedDeployments++;
            }
            totalFeesPaid += creatorDeps[i].feePaid;
            if (creatorDeps[i].timestamp > lastDeployment) {
                lastDeployment = creatorDeps[i].timestamp;
            }
        }
        
        blacklisted = blacklistedCreators[creator];
    }

    function getFactoryStats() external view returns (
        uint256 totalDeployments,
        uint256 totalActiveDeployments,
        uint256 totalVerifiedDeployments,
        uint256 totalFeesCollected_,
        uint256 currentBalance,
        uint256 uniqueCreators,
        uint256 supportedAssetTypes
    ) {
        totalDeployments = allDeployments.length;
        totalActiveDeployments = totalActiveDeployments;
        totalFeesCollected_ = totalFeesCollected;

        // Count verified deployments
        for (uint256 i = 0; i < allDeployments.length; i++) {
            if (allDeployments[i].verified) {
                totalVerifiedDeployments++;
            }
        }

        // Get current balance
        if (paymentToken == address(0)) {
            currentBalance = address(this).balance;
        } else {
            currentBalance = IERC20(paymentToken).balanceOf(address(this));
        }

        // Count unique creators (approximation)
        uniqueCreators = allDeployments.length; // Simplified for gas efficiency
        supportedAssetTypes = 18; // As initialized in the token contract
    }

    function getPaymentInfo() external view returns (
        address paymentToken_,
        uint256 baseFee_,
        uint256 feeTierCount_,
        uint256 maxDeploymentsPerCreator_,
        uint256 deploymentCooldownSeconds_
    ) {
        return (
            paymentToken,
            baseFee,
            feeTierCount,
            maxDeploymentsPerCreator,
            deploymentCooldownSeconds
        );
    }

    // === BATCH OPERATIONS FOR EFFICIENCY ===
    function batchVerifyDeployments(address[] calldata tokenAddresses) external onlyOwner {
        for (uint256 i = 0; i < tokenAddresses.length; i++) {
            for (uint256 j = 0; j < allDeployments.length; j++) {
                if (allDeployments[j].tokenAddress == tokenAddresses[i]) {
                    allDeployments[j].verified = true;
                    emit DeploymentVerified(tokenAddresses[i], msg.sender);
                    break;
                }
            }
        }
    }

    function batchSetCreatorBlacklist(
        address[] calldata creators,
        bool[] calldata statuses
    ) external onlyOwner {
        require(creators.length == statuses.length, "Array length mismatch");
        
        for (uint256 i = 0; i < creators.length; i++) {
            blacklistedCreators[creators[i]] = statuses[i];
            emit CreatorBlacklisted(creators[i], statuses[i]);
        }
    }
}
