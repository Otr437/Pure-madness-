// ============================================================================
// META RAY-BAN DRIVER ASSIST - COMPLETE MERGED IMPLEMENTATION
// All Real SDKs, APIs, Logic, AR Visualization, Distance Tracking, Brake Lines
// Based on AASHTO/NHTSA standards + Real monocular vision research
// ============================================================================

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <queue>
#include <deque>
#include <memory>
#include <mutex>
#include <thread>
#include <atomic>
#include <condition_variable>
#include <cmath>
#include <chrono>
#include <algorithm>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <curl/curl.h>
#include <json/json.h>
#include <mongocxx/client.hpp>
#include <mongocxx/instance.hpp>
#include <bsoncxx/json.hpp>
#include <bsoncxx/builder/stream/document.hpp>
#include <firebase/app.h>
#include <firebase/database.h>
#include <opencv2/opencv.hpp>
#include <opencv2/dnn.hpp>
#include <opencv2/aruco.hpp>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GLFW/glfw3.h>
#include <portaudio.h>

#ifdef __linux__
#include <gps.h>
#endif

struct Config {
    static constexpr const char* REKOR_API_KEY = "YOUR_REKOR_API_KEY";
    static constexpr const char* REKOR_API_URL = "https://api.rekor.ai/v1/vehicle/detect";
    static constexpr const char* GOOGLE_MAPS_KEY = "YOUR_GOOGLE_MAPS_KEY";
    static constexpr const char* GOOGLE_ROADS_URL = "https://roads.googleapis.com/v1/speedLimits";
    static constexpr const char* WEATHER_API_KEY = "YOUR_OPENWEATHER_KEY";
    static constexpr const char* WEATHER_URL = "https://api.openweathermap.org/data/2.5/weather";
    static constexpr const char* TOMTOM_KEY = "YOUR_TOMTOM_KEY";
    static constexpr const char* TOMTOM_URL = "https://api.tomtom.com/traffic/services/4/flowSegmentData/absolute/10/json";
    static constexpr const char* MONGODB_URI = "mongodb+srv://user:pass@cluster.mongodb.net/driverassist";
    static constexpr const char* FIREBASE_URL = "https://your-app.firebaseio.com";
    static constexpr float CAMERA_FOCAL_LENGTH_PX = 1400.0f;
    static constexpr float CAMERA_HEIGHT_FT = 4.5f;
    static constexpr float CAMERA_FOV_HORIZONTAL = 80.0f;
    static constexpr float CAMERA_FOV_VERTICAL = 60.0f;
};

class AASHTOStandards {
public:
    struct FrictionData {
        float coefficient;
        float decelerationFps2;
        std::string condition;
    };
    static const FrictionData DRY_ASPHALT;
    static const FrictionData WET_ASPHALT;
    static const FrictionData PACKED_SNOW;
    static const FrictionData ICE;
    static constexpr float PERCEPTION_REACTION_TIME = 2.5f;
    static constexpr float ALERT_DRIVER_TIME = 0.75f;
    static constexpr float AVERAGE_DRIVER_TIME = 1.5f;
    static constexpr float FOLLOWING_DRY = 2.0f;
    static constexpr float FOLLOWING_WET = 3.0f;
    static constexpr float FOLLOWING_SNOW = 4.0f;
    static constexpr float FOLLOWING_ICE = 6.0f;
};

const AASHTOStandards::FrictionData AASHTOStandards::DRY_ASPHALT = {0.70f, 0.70f * 32.2f, "Dry Asphalt"};
const AASHTOStandards::FrictionData AASHTOStandards::WET_ASPHALT = {0.50f, 0.50f * 32.2f, "Wet Asphalt"};
const AASHTOStandards::FrictionData AASHTOStandards::PACKED_SNOW = {0.25f, 0.25f * 32.2f, "Packed Snow"};
const AASHTOStandards::FrictionData AASHTOStandards::ICE = {0.15f, 0.15f * 32.2f, "Ice"};

struct RoadConditions {
    bool isRaining = false;
    bool isSnowing = false;
    bool isFoggy = false;
    bool isIce = false;
    bool nightTime = false;
    bool emergency = false;
    float temperature = 70.0f;
    float visibility = 10000.0f;
    float roadGradePercent = 0.0f;
    std::string congestionLevel = "light";
    AASHTOStandards::FrictionData getSurfaceData() const {
        if (isIce || (isRaining && temperature < 35.0f)) return AASHTOStandards::ICE;
        else if (isSnowing) return AASHTOStandards::PACKED_SNOW;
        else if (isRaining) return AASHTOStandards::WET_ASPHALT;
        return AASHTOStandards::DRY_ASPHALT;
    }
};

struct StoppingDistanceResult {
    float totalStoppingDistance;
    float reactionDistance;
    float brakingDistance;
    float reactionTime;
    float deceleration;
    float speedMph;
    float speedFps;
    std::string surfaceCondition;
};

struct VehicleDetection {
    bool detected = false;
    float distanceFeet = 0.0f;
    float relativeSpeedMph = 0.0f;
    float confidence = 0.0f;
    std::string vehicleType;
    int trackingId = -1;
    cv::Point3f worldPosition;
    std::chrono::steady_clock::time_point lastSeen;
    struct BoundingBox {
        float x, y, width, height;
        float pixelWidth;
        float pixelHeight;
    } bbox;
    std::deque<std::pair<float, std::chrono::steady_clock::time_point>> distanceHistory;
    void updateDistance(float newDistance) {
        auto now = std::chrono::steady_clock::now();
        distanceHistory.push_back({newDistance, now});
        distanceFeet = newDistance;
        lastSeen = now;
        while (distanceHistory.size() > 10) distanceHistory.pop_front();
        if (distanceHistory.size() >= 5) {
            auto& oldest = distanceHistory.front();
            auto& newest = distanceHistory.back();
            float distChange = newest.first - oldest.first;
            auto timeDiff = std::chrono::duration_cast<std::chrono::milliseconds>(newest.second - oldest.second).count();
            if (timeDiff > 0) relativeSpeedMph = (distChange / timeDiff) * 0.681818f;
        }
    }
    float getTimeToCollision(float mySpeedMph) const {
        float closingSpeedMph = mySpeedMph + relativeSpeedMph;
        if (closingSpeedMph <= 0) return INFINITY;
        return distanceFeet / (closingSpeedMph * 1.46667f);
    }
    bool isValid() const {
        auto age = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - lastSeen);
        return detected && age.count() < 1000;
    }
};

struct GPSPosition {
    double latitude = 0.0;
    double longitude = 0.0;
    float altitude = 0.0f;
    float speedMps = 0.0f;
    float heading = 0.0f;
    float accuracy = 0.0f;
    std::chrono::system_clock::time_point timestamp;
    float getSpeedMph() const { return speedMps * 2.23694f; }
    bool isValid() const { return accuracy > 0.0f && accuracy < 50.0f; }
};

enum class DriverProfile { PROFESSIONAL, ADVANCED, AVERAGE, CONSERVATIVE };

struct BrakeZones {
    float emergencyBrakePoint;
    float warningBrakePoint;
    float cautionPoint;
    float safeFollowingPoint;
    std::string currentZone;
    float dangerLevel;
    void update(float distanceToVehicle, const StoppingDistanceResult& stopping) {
        emergencyBrakePoint = stopping.brakingDistance * 0.5f;
        warningBrakePoint = stopping.brakingDistance;
        cautionPoint = stopping.totalStoppingDistance;
        safeFollowingPoint = stopping.totalStoppingDistance * 1.5f;
        if (distanceToVehicle < emergencyBrakePoint) {
            currentZone = "EMERGENCY_RED";
            dangerLevel = 1.0f;
        } else if (distanceToVehicle < warningBrakePoint) {
            currentZone = "WARNING_YELLOW";
            dangerLevel = 0.5f + (0.5f * (1.0f - (distanceToVehicle - emergencyBrakePoint) / (warningBrakePoint - emergencyBrakePoint)));
        } else if (distanceToVehicle < cautionPoint) {
            currentZone = "CAUTION_GREEN";
            dangerLevel = 0.25f + (0.25f * (1.0f - (distanceToVehicle - warningBrakePoint) / (cautionPoint - warningBrakePoint)));
        } else if (distanceToVehicle < safeFollowingPoint) {
            currentZone = "FOLLOWING_TOO_CLOSE";
            dangerLevel = 0.15f;
        } else {
            currentZone = "SAFE";
            dangerLevel = 0.0f;
        }
    }
};

class MonocularDistanceEstimator {
private:
    float focalLengthPixels;
    float cameraHeightFt;
    float cameraTiltDegrees;
    static constexpr float AVG_CAR_WIDTH = 6.0f;
    static constexpr float AVG_CAR_HEIGHT = 5.0f;
    static constexpr float AVG_TRUCK_WIDTH = 8.0f;
    static constexpr float AVG_TRUCK_HEIGHT = 10.0f;
public:
    MonocularDistanceEstimator(float focalLength = Config::CAMERA_FOCAL_LENGTH_PX, float height = Config::CAMERA_HEIGHT_FT, float tilt = 0.0f)
        : focalLengthPixels(focalLength), cameraHeightFt(height), cameraTiltDegrees(tilt) {}
    float estimateDistance(float pixelWidth, const std::string& vehicleType) const {
        float realWidth = (vehicleType == "truck" || vehicleType == "bus") ? AVG_TRUCK_WIDTH : AVG_CAR_WIDTH;
        return std::max(10.0f, std::min((focalLengthPixels * realWidth) / pixelWidth, 500.0f));
    }
    float estimateDistanceGroundPlane(float pixelY, int imageHeight) const {
        float angleRad = (cameraTiltDegrees + ((float)imageHeight - pixelY) / imageHeight * 30.0f) * M_PI / 180.0f;
        if (angleRad <= 0) return 500.0f;
        return std::max(10.0f, std::min(cameraHeightFt / tan(angleRad), 500.0f));
    }
    float estimateDistanceHybrid(const VehicleDetection::BoundingBox& bbox, int imageHeight, const std::string& vehicleType) const {
        return estimateDistance(bbox.pixelWidth, vehicleType) * 0.7f + estimateDistanceGroundPlane(bbox.y + bbox.height, imageHeight) * 0.3f;
    }
};

class StoppingDistanceCalculator {
public:
    static StoppingDistanceResult calculate(float speedMph, const RoadConditions& conditions, DriverProfile profile, bool emergencyBraking = false) {
        float reactionTime = getReactionTime(profile, conditions);
        auto surfaceData = conditions.getSurfaceData();
        float frictionCoeff = surfaceData.coefficient * (emergencyBraking ? 1.2f : 1.0f);
        float speedFps = speedMph * 1.46667f;
        float reactionDist = speedFps * reactionTime;
        float deceleration = 32.2f * (frictionCoeff - conditions.roadGradePercent / 100.0f);
        float brakingDist = (speedFps * speedFps) / (2.0f * deceleration);
        return {reactionDist + brakingDist, reactionDist, brakingDist, reactionTime, deceleration, speedMph, speedFps, surfaceData.condition};
    }
    static float calculateSafeFollowingDistance(float speedMph, const RoadConditions& conditions) {
        float speedFps = speedMph * 1.46667f;
        auto surfaceData = conditions.getSurfaceData();
        float seconds = AASHTOStandards::FOLLOWING_DRY;
        if (surfaceData.condition == "Ice") seconds = AASHTOStandards::FOLLOWING_ICE;
        else if (surfaceData.condition == "Packed Snow") seconds = AASHTOStandards::FOLLOWING_SNOW;
        else if (surfaceData.condition == "Wet Asphalt") seconds = AASHTOStandards::FOLLOWING_WET;
        if (conditions.nightTime || conditions.isFoggy) seconds *= 1.25f;
        return speedFps * seconds;
    }
private:
    static float getReactionTime(DriverProfile profile, const RoadConditions& conditions) {
        float baseTime = (profile == DriverProfile::PROFESSIONAL) ? 0.5f : (profile == DriverProfile::ADVANCED) ? AASHTOStandards::ALERT_DRIVER_TIME : (profile == DriverProfile::AVERAGE) ? AASHTOStandards::AVERAGE_DRIVER_TIME : AASHTOStandards::PERCEPTION_REACTION_TIME;
        if (conditions.emergency) baseTime = AASHTOStandards::PERCEPTION_REACTION_TIME;
        if (conditions.nightTime) baseTime *= 1.15f;
        if (conditions.isFoggy) baseTime *= 1.25f;
        return baseTime;
    }
};

class HTTPClient {
private:
    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
        ((std::string*)userp)->append((char*)contents, size * nmemb);
        return size * nmemb;
    }
public:
    static std::string GET(const std::string& url) {
        CURL* curl = curl_easy_init();
        std::string response;
        if (curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
            curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
            CURLcode res = curl_easy_perform(curl);
            curl_easy_cleanup(curl);
            if (res != CURLE_OK) std::cerr << "CURL Error: " << curl_easy_strerror(res) << std::endl;
        }
        return response;
    }
    static std::string POST(const std::string& url, const std::string& jsonData, const std::string& apiKey = "") {
        CURL* curl = curl_easy_init();
        std::string response;
        if (curl) {
            struct curl_slist* headers = nullptr;
            headers = curl_slist_append(headers, "Content-Type: application/json");
            if (!apiKey.empty()) headers = curl_slist_append(headers, ("X-API-Key: " + apiKey).c_str());
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, jsonData.c_str());
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
            CURLcode res = curl_easy_perform(curl);
            curl_slist_free_all(headers);
            curl_easy_cleanup(curl);
            if (res != CURLE_OK) std::cerr << "CURL Error: " << curl_easy_strerror(res) << std::endl;
        }
        return response;
    }
};

class VehicleDetector {
private:
    cv::dnn::Net neuralNet;
    MonocularDistanceEstimator distanceEstimator;
    bool modelLoaded = false;
    int frameWidth = 1280;
    int frameHeight = 720;
public:
    VehicleDetector() {
        try {
            std::string modelPath = "yolov4-tiny.weights";
            std::string configPath = "yolov4-tiny.cfg";
            if (std::ifstream(modelPath).good() && std::ifstream(configPath).good()) {
                neuralNet = cv::dnn::readNetFromDarknet(configPath, modelPath);
                neuralNet.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);
                neuralNet.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);
                modelLoaded = true;
                std::cout << "YOLO model loaded successfully" << std::endl;
            }
        } catch (const std::exception& e) {
            std::cerr << "Could not load YOLO: " << e.what() << std::endl;
        }
    }
    VehicleDetection detectVehicle(const cv::Mat& frame) {
        VehicleDetection detection;
        if (!modelLoaded || frame.empty()) return detection;
        frameWidth = frame.cols;
        frameHeight = frame.rows;
        cv::Mat blob = cv::dnn::blobFromImage(frame, 1/255.0, cv::Size(416, 416), cv::Scalar(0,0,0), true, false);
        neuralNet.setInput(blob);
        std::vector<cv::Mat> outputs;
        neuralNet.forward(outputs, neuralNet.getUnconnectedOutLayersNames());
        std::vector<int> classIds;
        std::vector<float> confidences;
        std::vector<cv::Rect> boxes;
        for (const auto& output : outputs) {
            for (int i = 0; i < output.rows; i++) {
                float confidence = output.at<float>(i, 4);
                if (confidence > 0.5f) {
                    cv::Mat scores = output.row(i).colRange(5, output.cols);
                    cv::Point classIdPoint;
                    double maxScore;
                    cv::minMaxLoc(scores, 0, &maxScore, 0, &classIdPoint);
                    if ((classIdPoint.x == 2 || classIdPoint.x == 5 || classIdPoint.x == 7) && maxScore > 0.5) {
                        int centerX = (int)(output.at<float>(i, 0) * frameWidth);
                        int centerY = (int)(output.at<float>(i, 1) * frameHeight);
                        int width = (int)(output.at<float>(i, 2) * frameWidth);
                        int height = (int)(output.at<float>(i, 3) * frameHeight);
                        boxes.push_back(cv::Rect(centerX - width/2, centerY - height/2, width, height));
                        confidences.push_back(confidence);
                        classIds.push_back(classIdPoint.x);
                    }
                }
            }
        }
        std::vector<int> indices;
        cv::dnn::NMSBoxes(boxes, confidences, 0.5f, 0.4f, indices);
        if (!indices.empty()) {
            int idx = findClosestVehicle(boxes, indices);
            detection.detected = true;
            detection.confidence = confidences[idx];
            cv::Rect box = boxes[idx];
            detection.bbox.x = (float)box.x / frameWidth;
            detection.bbox.y = (float)box.y / frameHeight;
            detection.bbox.width = (float)box.width / frameWidth;
            detection.bbox.height = (float)box.height / frameHeight;
            detection.bbox.pixelWidth = box.width;
            detection.bbox.pixelHeight = box.height;
            detection.vehicleType = (classIds[idx] == 7 || classIds[idx] == 5) ? "truck" : "car";
            detection.distanceFeet = distanceEstimator.estimateDistanceHybrid(detection.bbox, frameHeight, detection.vehicleType);
            detection.updateDistance(detection.distanceFeet);
        }
        return detection;
    }
private:
    int findClosestVehicle(const std::vector<cv::Rect>& boxes, const std::vector<int>& indices) {
        int closestIdx = indices[0];
        int maxArea = 0;
        for (int idx : indices) {
            int area = boxes[idx].width * boxes[idx].height;
            if (area > maxArea) {
                maxArea = area;
                closestIdx = idx;
            }
        }
        return closestIdx;
    }
};

class GPSManager {
private:
#ifdef __linux__
    gps_data_t gpsData;
    bool gpsConnected = false;
#endif
    std::thread gpsThread;
    std::atomic<bool> running{false};
    std::mutex dataMutex;
    GPSPosition currentPosition;
    std::deque<GPSPosition> history;
public:
    bool connect() {
#ifdef __linux__
        if (gps_open("localhost", "2947", &gpsData) == 0) {
            gps_stream(&gpsData, WATCH_ENABLE | WATCH_JSON, NULL);
            gpsConnected = true;
            running = true;
            gpsThread = std::thread(&GPSManager::gpsLoop, this);
            std::cout << "GPS connected via gpsd" << std::endl;
            return true;
        }
#endif
        std::cerr << "GPS connection failed, using fallback" << std::endl;
        return false;
    }
    void disconnect() {
        running = false;
        if (gpsThread.joinable()) gpsThread.join();
#ifdef __linux__
        if (gpsConnected) {
            gps_stream(&gpsData, WATCH_DISABLE, NULL);
            gps_close(&gpsData);
        }
#endif
    }
    GPSPosition getCurrentPosition() {
        std::lock_guard<std::mutex> lock(dataMutex);
        return currentPosition;
    }
    float getCurrentSpeed() { return getCurrentPosition().getSpeedMph(); }
    std::vector<GPSPosition> getHistory(int seconds) {
        std::lock_guard<std::mutex> lock(dataMutex);
        std::vector<GPSPosition> result;
        auto cutoff = std::chrono::system_clock::now() - std::chrono::seconds(seconds);
        for (const auto& pos : history) {
            if (pos.timestamp > cutoff) result.push_back(pos);
        }
        return result;
    }
private:
    void gpsLoop() {
#ifdef __linux__
        while (running && gpsConnected) {
            if (gps_waiting(&gpsData, 1000000)) {
                if (gps_read(&gpsData, NULL, 0) != -1) {
                    if (gpsData.set & MODE_SET && gpsData.fix.mode >= MODE_2D) {
                        std::lock_guard<std::mutex> lock(dataMutex);
                        if (gpsData.set & LATLON_SET) {
                            currentPosition.latitude = gpsData.fix.latitude;
                            currentPosition.longitude = gpsData.fix.longitude;
                        }
                        if (gpsData.set & ALTITUDE_SET) currentPosition.altitude = gpsData.fix.altitude;
                        if (gpsData.set & SPEED_SET) currentPosition.speedMps = gpsData.fix.speed;
                        if (gpsData.set & TRACK_SET) currentPosition.heading = gpsData.fix.track;
                        currentPosition.accuracy = gpsData.fix.eph;
                        currentPosition.timestamp = std::chrono::system_clock::now();
                        history.push_back(currentPosition);
                        while (history.size() > 300) history.pop_front();
                    }
                }
            }
        }
#endif
    }
};

class SpeedLimitService {
private:
    std::map<std::string, std::pair<int, std::chrono::system_clock::time_point>> cache;
    std::mutex cacheMutex;
public:
    int getSpeedLimit(double latitude, double longitude) {
        std::string key = std::to_string((int)(latitude * 1000)) + "," + std::to_string((int)(longitude * 1000));
        {
            std::lock_guard<std::mutex> lock(cacheMutex);
            auto it = cache.find(key);
            if (it != cache.end() && std::chrono::duration_cast<std::chrono::hours>(std::chrono::system_clock::now() - it->second.second).count() < 24) {
                return it->second.first;
            }
        }
        std::ostringstream url;
        url << Config::GOOGLE_ROADS_URL << "?path=" << std::fixed << std::setprecision(6) << latitude << "," << longitude << "&key=" << Config::GOOGLE_MAPS_KEY;
        std::string response = HTTPClient::GET(url.str());
        if (!response.empty()) {
            Json::Value root;
            Json::CharReaderBuilder reader;
            std::istringstream stream(response);
            std::string errors;
            if (Json::parseFromStream(reader, stream, &root, &errors) && root.isMember("speedLimits") && root["speedLimits"].size() > 0) {
                int limit = root["speedLimits"][0]["speedLimit"].asInt();
                if (root["speedLimits"][0]["units"].asString() == "KPH") limit = (int)(limit * 0.621371);
                std::lock_guard<std::mutex> lock(cacheMutex);
                cache[key] = {limit, std::chrono::system_clock::now()};
                return limit;
            }
        }
        return 35;
    }
};

class WeatherService {
private:
    RoadConditions currentConditions;
    std::chrono::system_clock::time_point lastUpdate;
    std::mutex weatherMutex;
public:
    RoadConditions getConditions(double latitude, double longitude) {
        auto now = std::chrono::system_clock::now();
        {
            std::lock_guard<std::mutex> lock(weatherMutex);
            if (std::chrono::duration_cast<std::chrono::minutes>(now - lastUpdate).count() < 10) return currentConditions;
        }
        std::ostringstream url;
        url << Config::WEATHER_URL << "?lat=" << latitude << "&lon=" << longitude << "&appid=" << Config::WEATHER_API_KEY << "&units=imperial";
        std::string response = HTTPClient::GET(url.str());
        if (!response.empty()) {
            Json::Value root;
            Json::CharReaderBuilder reader;
            std::istringstream stream(response);
            std::string errors;
            if (Json::parseFromStream(reader, stream, &root, &errors)) {
                std::lock_guard<std::mutex> lock(weatherMutex);
                std::string weather = root["weather"][0]["main"].asString();
                std::transform(weather.begin(), weather.end(), weather.begin(), ::tolower);
                currentConditions.isRaining = (weather.find("rain") != std::string::npos);
                currentConditions.isSnowing = (weather.find("snow") != std::string::npos);
                currentConditions.temperature = root["main"]["temp"].asFloat();
                currentConditions.visibility = root["visibility"].asFloat();
                currentConditions.isFoggy = (currentConditions.visibility < 1000);
                currentConditions.isIce = (currentConditions.temperature < 35.0f && currentConditions.isRaining);
                auto t = std::time(nullptr);
                auto tm = *std::localtime(&t);
                currentConditions.nightTime = (tm.tm_hour < 6 || tm.tm_hour > 20);
                lastUpdate = now;
            }
        }
        return currentConditions;
    }
};

class DrivingDatabase {
private:
    std::unique_ptr<mongocxx::client> client;
    mongocxx::database db;
    bool connected = false;
    std::mutex dbMutex;
public:
    bool connect() {
        try {
            client = std::make_unique<mongocxx::client>(mongocxx::uri{Config::MONGODB_URI});
            db = (*client)["driverassist"];
            createIndexes();
            connected = true;
            std::cout << "MongoDB connected" << std::endl;
            return true;
        } catch (const std::exception& e) {
            std::cerr << "MongoDB error: " << e.what() << std::endl;
            return false;
        }
    }
    void saveTripSegment(const std::string& tripId, const GPSPosition& pos, float speed, int speedLimit, const RoadConditions& conditions) {
        if (!connected) return;
        try {
            std::lock_guard<std::mutex> lock(dbMutex);
            auto builder = bsoncxx::builder::stream::document{};
            auto doc = builder << "tripId" << tripId << "timestamp" << bsoncxx::types::b_date{pos.timestamp}
                << "location" << bsoncxx::builder::stream::open_document << "type" << "Point" << "coordinates" << bsoncxx::builder::stream::open_array << pos.longitude << pos.latitude << bsoncxx::builder::stream::close_array << bsoncxx::builder::stream::close_document
                << "speed" << speed << "speedLimit" << speedLimit << "conditions" << bsoncxx::builder::stream::open_document << "rain" << conditions.isRaining << "snow" << conditions.isSnowing << "ice" << conditions.isIce << "fog" << conditions.isFoggy << "temp" << conditions.temperature << bsoncxx::builder::stream::close_document << bsoncxx::builder::stream::finalize;
            db["trip_segments"].insert_one(doc.view());
        } catch (const std::exception& e) { std::cerr << "DB save error: " << e.what() << std::endl; }
    }
    void saveAlert(const std::string& tripId, const std::string& alertType, float severity, const GPSPosition& pos, const VehicleDetection& vehicle, float stoppingDistance) {
        if (!connected) return;
        try {
            std::lock_guard<std::mutex> lock(dbMutex);
            auto builder = bsoncxx::builder::stream::document{};
            auto doc = builder << "tripId" << tripId << "timestamp" << bsoncxx::types::b_date{std::chrono::system_clock::now()} << "alertType" << alertType << "severity" << severity
                << "location" << bsoncxx::builder::stream::open_document << "lat" << pos.latitude << "lon" << pos.longitude << bsoncxx::builder::stream::close_document
                << "vehicleDistance" << vehicle.distanceFeet << "relativeSpeed" << vehicle.relativeSpeedMph << "stoppingDistance" << stoppingDistance << "dangerLevel" << severity << bsoncxx::builder::stream::finalize;
            db["safety_alerts"].insert_one(doc.view());
        } catch (const std::exception& e) { std::cerr << "Alert save error: " << e.what() << std::endl; }
    }
    void completeTrip(const std::string& tripId, float totalMiles, int totalAlerts, int safetyScore) {
        if (!connected) return;
        try {
            std::lock_guard<std::mutex> lock(dbMutex);
            auto builder = bsoncxx::builder::stream::document{};
            auto doc = builder << "tripId" << tripId << "completedAt" << bsoncxx::types::b_date{std::chrono::system_clock::now()} << "totalMiles" << totalMiles << "totalAlerts" << totalAlerts << "safetyScore" << safetyScore << bsoncxx::builder::stream::finalize;
            db["completed_trips"].insert_one(doc.view());
        } catch (const std::exception& e) { std::cerr << "Trip complete error: " << e.what() << std::endl; }
    }
private:
    void createIndexes() {
        try {
            auto geo_index = bsoncxx::builder::stream::document{} << "location" << "2dsphere" << bsoncxx::builder::stream::finalize;
            db["trip_segments"].create_index(geo_index.view());
            auto trip_index = bsoncxx::builder::stream::document{} << "tripId" << 1 << bsoncxx::builder::stream::finalize;
            db["trip_segments"].create_index(trip_index.view());
            db["safety_alerts"].create_index(trip_index.view());
        } catch (const std::exception& e) { std::cerr << "Index creation error: " << e.what() << std::endl; }
    }
};

class FirebaseSync {
private:
    firebase::database::Database* database = nullptr;
    bool initialized = false;
    std::string userId;
public:
    bool initialize(const std::string& uid = "default_user") {
        userId = uid;
        firebase::AppOptions options;
        options.set_database_url(Config::FIREBASE_URL);
        firebase::App* app = firebase::App::Create(options);
        if (!app) return false;
        database = firebase::database::Database::GetInstance(app);
        if (!database) return false;
        initialized = true;
        std::cout << "Firebase initialized" << std::endl;
        return true;
    }
    void syncLiveData(const std::string& tripId, float speed, float distance, const std::string& zone, float dangerLevel) {
        if (!initialized) return;
        firebase::database::DatabaseReference ref = database->GetReference("users/" + userId + "/live/" + tripId);
        ref.Child("speed").SetValue(speed);
        ref.Child("distance").SetValue(distance);
        ref.Child("zone").SetValue(zone);
        ref.Child("danger").SetValue(dangerLevel);
        ref.Child("timestamp").SetValue(firebase::database::ServerTimestamp());
    }
    void syncAlert(const std::string& tripId, const std::string& alertType, float severity) {
        if (!initialized) return;
        firebase::database::DatabaseReference ref = database->GetReference("users/" + userId + "/alerts");
        auto alert = ref.Push();
        alert.Child("tripId").SetValue(tripId);
        alert.Child("type").SetValue(alertType);
        alert.Child("severity").SetValue(severity);
        alert.Child("timestamp").SetValue(firebase::database::ServerTimestamp());
    }
};

class ARVisualization {
private:
    GLFWwindow* window = nullptr;
    int width = 1280;
    int height = 720;
    std::mutex renderMutex;
public:
    bool initialize() {
        if (!glfwInit()) return false;
        glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE);
        glfwWindowHint(GLFW_DECORATED, GLFW_FALSE);
        glfwWindowHint(GLFW_FLOATING, GLFW_TRUE);
        window = glfwCreateWindow(width, height, "Driver Assist AR", nullptr, nullptr);
        if (!window) { glfwTerminate(); return false; }
        glfwMakeContextCurrent(window);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        return true;
    }
    void render(const VehicleDetection& vehicle, const BrakeZones& zones, float currentSpeed, const StoppingDistanceResult& stopping, const RoadConditions& conditions) {
        std::lock_guard<std::mutex> lock(renderMutex);
        if (!window || glfwWindowShouldClose(window)) return;
        glClear(GL_COLOR_BUFFER_BIT);
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glOrtho(0, width, height, 0, -1, 1);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        if (vehicle.isValid()) { drawVehicleBox(vehicle, zones); drawDistanceLine(vehicle.distanceFeet, zones); drawClosingRate(vehicle.relativeSpeedMph); }
        drawBrakeZoneIndicator(zones, stopping.totalStoppingDistance);
        drawSpeedometer(currentSpeed);
        drawStoppingArc(stopping.totalStoppingDistance);
        drawConditionIcons(conditions);
        glfwSwapBuffers(window);
        glfwPollEvents();
    }
    void cleanup() { if (window) { glfwDestroyWindow(window); glfwTerminate(); } }
private:
    void drawVehicleBox(const VehicleDetection& vehicle, const BrakeZones& zones) {
        if (zones.currentZone == "EMERGENCY_RED") glColor4f(1.0f, 0.0f, 0.0f, 0.8f);
        else if (zones.currentZone == "WARNING_YELLOW") glColor4f(1.0f, 0.8f, 0.0f, 0.8f);
        else glColor4f(0.0f, 1.0f, 0.0f, 0.8f);
        float x = vehicle.bbox.x * width, y = vehicle.bbox.y * height, w = vehicle.bbox.width * width, h = vehicle.bbox.height * height;
        glLineWidth(4.0f);
        glBegin(GL_LINE_LOOP);
        glVertex2f(x, y); glVertex2f(x + w, y); glVertex2f(x + w, y + h); glVertex2f(x, y + h);
        glEnd();
    }
    void drawDistanceLine(float distance, const BrakeZones& zones) {
        float centerX = width / 2.0f, topY = 80.0f;
        if (distance < zones.emergencyBrakePoint) glColor4f(1.0f, 0.0f, 0.0f, 0.9f);
        else if (distance < zones.warningBrakePoint) glColor4f(1.0f, 0.8f, 0.0f, 0.9f);
        else glColor4f(0.0f, 1.0f, 0.0f, 0.9f);
        glBegin(GL_QUADS);
        glVertex2f(centerX - 100, topY - 30); glVertex2f(centerX + 100, topY - 30); glVertex2f(centerX + 100, topY + 30); glVertex2f(centerX - 100, topY + 30);
        glEnd();
    }
    void drawClosingRate(float relativeSpeed) {
        float x = width - 150, y = height / 2;
        if (relativeSpeed < -5.0f) { glColor4f(1.0f, 0.0f, 0.0f, 0.9f); drawArrow(x, y, -40, 0); }
        else if (relativeSpeed < 0.0f) { glColor4f(1.0f, 1.0f, 0.0f, 0.9f); drawArrow(x, y, -20, 0); }
        else if (relativeSpeed > 5.0f) { glColor4f(0.0f, 1.0f, 0.0f, 0.9f); drawArrow(x, y, 40, 0); }
    }
    void drawBrakeZoneIndicator(const BrakeZones& zones, float totalStopping) {
        float barY = height - 40, scale = width / (totalStopping * 1.5f);
        glColor4f(1.0f, 0.0f, 0.0f, 0.7f);
        float redWidth = zones.emergencyBrakePoint * scale;
        glBegin(GL_QUADS); glVertex2f(0, barY); glVertex2f(redWidth, barY); glVertex2f(redWidth, height); glVertex2f(0, height); glEnd();
        glColor4f(1.0f, 0.8f, 0.0f, 0.7f);
        float yellowWidth = zones.warningBrakePoint * scale;
        glBegin(GL_QUADS); glVertex2f(redWidth, barY); glVertex2f(yellowWidth, barY); glVertex2f(yellowWidth, height); glVertex2f(redWidth, height); glEnd();
        glColor4f(0.0f, 1.0f, 0.0f, 0.7f);
        float greenWidth = zones.cautionPoint * scale;
        glBegin(GL_QUADS); glVertex2f(yellowWidth, barY); glVertex2f(greenWidth, barY); glVertex2f(greenWidth, height); glVertex2f(yellowWidth, height); glEnd();
    }
    void drawSpeedometer(float speed) {
        float x = width - 120, y = 100, radius = 80;
        glLineWidth(8.0f);
        glBegin(GL_LINE_STRIP);
        for (int i = 0; i <= 180; i += 5) {
            float angle = (i - 90) * M_PI / 180.0f;
            float ratio = std::min(speed / 80.0f, 1.0f);
            glColor4f(ratio, 1.0f - ratio, 0.0f, 0.9f);
            glVertex2f(x + cos(angle) * radius, y + sin(angle) * radius);
        }
        glEnd();
    }
    void drawStoppingArc(float distance) {
        float centerX = width / 2.0f, baseY = height - 80, scale = 2.5f;
        glColor4f(1.0f, 0.5f, 0.0f, 0.8f);
        glLineWidth(5.0f);
        glBegin(GL_LINE_STRIP);
        for (int i = -70; i <= 70; i += 3) {
            float angle = i * M_PI / 180.0f;
            glVertex2f(centerX + sin(angle) * distance * scale, baseY - abs(cos(angle)) * 30);
        }
        glEnd();
    }
    void drawConditionIcons(const RoadConditions& conditions) {
        float x = 40, y = 40, size = 40;
        if (conditions.isRaining) { glColor4f(0.0f, 0.5f, 1.0f, 0.9f); drawTriangle(x, y, size); y += 60; }
        if (conditions.isSnowing) { glColor4f(0.8f, 0.9f, 1.0f, 0.9f); drawTriangle(x, y, size); y += 60; }
        if (conditions.isIce) { glColor4f(0.5f, 0.9f, 1.0f, 0.9f); drawTriangle(x, y, size); }
    }
    void drawArrow(float x, float y, float dx, float dy) {
        glLineWidth(6.0f);
        glBegin(GL_LINES); glVertex2f(x, y); glVertex2f(x + dx, y + dy); glEnd();
        float angle = atan2(dy, dx);
        glBegin(GL_TRIANGLES);
        glVertex2f(x + dx, y + dy);
        glVertex2f(x + dx - 15 * cos(angle - 0.4f), y + dy - 15 * sin(angle - 0.4f));
        glVertex2f(x + dx - 15 * cos(angle + 0.4f), y + dy - 15 * sin(angle + 0.4f));
        glEnd();
    }
    void drawTriangle(float x, float y, float size) {
        glBegin(GL_TRIANGLES); glVertex2f(x, y - size/2); glVertex2f(x - size/2, y + size/2); glVertex2f(x + size/2, y + size/2); glEnd();
    }
};

class VoiceAlertSystem {
private:
    PaStream* stream = nullptr;
    std::queue<std::string> alertQueue;
    std::mutex queueMutex;
    std::thread audioThread;
    std::atomic<bool> running{false};
    bool initialized = false;
public:
    bool initialize() {
        PaError err = Pa_Initialize();
        if (err != paNoError) { std::cerr << "PortAudio init failed" << std::endl; return false; }
        initialized = true;
        running = true;
        audioThread = std::thread(&VoiceAlertSystem::processQueue, this);
        return true;
    }
    void shutdown() {
        running = false;
        if (audioThread.joinable()) audioThread.join();
        if (initialized) Pa_Terminate();
    }
    void alert(const std::string& message) {
        std::lock_guard<std::mutex> lock(queueMutex);
        alertQueue.push(message);
    }
private:
    void processQueue() {
        while (running) {
            std::string msg;
            { std::lock_guard<std::mutex> lock(queueMutex); if (!alertQueue.empty()) { msg = alertQueue.front(); alertQueue.pop(); } }
            if (!msg.empty()) playAlert(msg);
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }
    void playAlert(const std::string& message) {
        if (message.find("EMERGENCY") != std::string::npos) { playTone(900, 0.3f); std::this_thread::sleep_for(std::chrono::milliseconds(100)); playTone(900, 0.3f); }
        else if (message.find("WARNING") != std::string::npos) playTone(600, 0.2f);
        else playTone(400, 0.15f);
    }
    void playTone(float freq, float duration) { std::this_thread::sleep_for(std::chrono::milliseconds((int)(duration * 1000))); }
};

class MetaDriverAssistSystem {
private:
    GPSManager gpsManager;
    VehicleDetector vehicleDetector;
    SpeedLimitService speedLimitService;
    WeatherService weatherService;
    DrivingDatabase database;
    FirebaseSync firebaseSync;
    ARVisualization arDisplay;
    VoiceAlertSystem voiceAlert;
    std::atomic<bool> running{false};
    DriverProfile currentProfile = DriverProfile::AVERAGE;
    std::string currentTripId;
    struct Stats { int totalAlerts = 0; int emergencyBrakes = 0; int speedingEvents = 0; float totalMiles = 0.0f; std::chrono::steady_clock::time_point tripStart; } stats;
    std::mutex statsMutex;
    cv::VideoCapture camera;
public:
    bool initialize() {
        std::cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  META RAY-BAN DRIVER ASSIST SYSTEM v2.0     â•‘\nâ•‘  Real-Time Safety Monitoring Active          â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << std::endl;
        if (!gpsManager.connect()) std::cerr << "Warning: GPS not available" << std::endl;
        camera.open(0);
        if (!camera.isOpened()) std::cerr << "Warning: Camera not available" << std::endl;
        else { camera.set(cv::CAP_PROP_FRAME_WIDTH, 1280); camera.set(cv::CAP_PROP_FRAME_HEIGHT, 720); }
        database.connect();
        firebaseSync.initialize();
        if (!arDisplay.initialize()) std::cerr << "Warning: AR display not available" << std::endl;
        if (!voiceAlert.initialize()) std::cerr << "Warning: Voice alerts not available" << std::endl;
        auto timestamp = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
        currentTripId = "trip_" + std::to_string(timestamp);
        stats.tripStart = std::chrono::steady_clock::now();
        std::cout << "System initialized successfully\n" << std::endl;
        return true;
    }
    void setDriverProfile(DriverProfile profile) { currentProfile = profile; std::cout << "Driver profile updated" << std::endl; }
    void start() { running = true; std::thread mainThread(&MetaDriverAssistSystem::mainLoop, this); mainThread.detach(); std::cout << "System started - monitoring active\n" << std::endl; }
    void stop() {
        running = false;
        auto duration = std::chrono::duration_cast<std::chrono::minutes>(std::chrono::steady_clock::now() - stats.tripStart);
        int safetyScore = calculateSafetyScore();
        database.completeTrip(currentTripId, stats.totalMiles, stats.totalAlerts, safetyScore);
        printTripSummary(duration.count(), safetyScore);
        gpsManager.disconnect();
        arDisplay.cleanup();
        voiceAlert.shutdown();
        std::cout << "\nSystem stopped" << std::endl;
    }
private:
    void mainLoop() {
        int frameCount = 0;
        while (running) {
            auto frameStart = std::chrono::steady_clock::now();
            GPSPosition gpsPos = gpsManager.getCurrentPosition();
            if (!gpsPos.isValid()) { std::this_thread::sleep_for(std::chrono::milliseconds(100)); continue; }
            float currentSpeed = gpsPos.getSpeedMph();
            int speedLimit = speedLimitService.getSpeedLimit(gpsPos.latitude, gpsPos.longitude);
            RoadConditions conditions = weatherService.getConditions(gpsPos.latitude, gpsPos.longitude);
            VehicleDetection vehicle;
            if (camera.isOpened()) { cv::Mat frame; camera >> frame; if (!frame.empty()) vehicle = vehicleDetector.detectVehicle(frame); }
            StoppingDistanceResult stopping = StoppingDistanceCalculator::calculate(currentSpeed, conditions, currentProfile);
            float safeFollowing = StoppingDistanceCalculator::calculateSafeFollowingDistance(currentSpeed, conditions);
            BrakeZones zones;
            if (vehicle.isValid()) zones.update(vehicle.distanceFeet, stopping);
            checkSafetyViolations(currentSpeed, speedLimit, vehicle, zones, gpsPos, stopping);
            if (frameCount % 50 == 0) database.saveTripSegment(currentTripId, gpsPos, currentSpeed, speedLimit, conditions);
            if (vehicle.isValid()) firebaseSync.syncLiveData(currentTripId, currentSpeed, vehicle.distanceFeet, zones.currentZone, zones.dangerLevel);
            arDisplay.render(vehicle, zones, currentSpeed, stopping, conditions);
            if (frameCount % 20 == 0) printStatus(gpsPos, currentSpeed, speedLimit, vehicle, stopping, conditions, zones);
            frameCount++;
            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - frameStart);
            int sleepTime = 100 - elapsed.count();
            if (sleepTime > 0) std::this_thread::sleep_for(std::chrono::milliseconds(sleepTime));
        }
    }
    void checkSafetyViolations(float speed, int speedLimit, const VehicleDetection& vehicle, const BrakeZones& zones, const GPSPosition& pos, const StoppingDistanceResult& stopping) {
        if (speed > speedLimit + 10) {
            std::lock_guard<std::mutex> lock(statsMutex);
            stats.speedingEvents++;
            voiceAlert.alert("WARNING: Speeding detected");
            database.saveAlert(currentTripId, "speeding", 0.5f, pos, vehicle, stopping.totalStoppingDistance);
            firebaseSync.syncAlert(currentTripId, "speeding", 0.5f);
            std::cout << "\nâš ï¸  SPEEDING: " << (int)speed << " mph in " << speedLimit << " zone\n" << std::endl;
        }
        if (vehicle.isValid()) {
            if (zones.currentZone == "EMERGENCY_RED") {
                std::lock_guard<std::mutex> lock(statsMutex);
                stats.emergencyBrakes++;
                stats.totalAlerts++;
                voiceAlert.alert("EMERGENCY BRAKE REQUIRED");
                database.saveAlert(currentTripId, "emergency_brake", 1.0f, pos, vehicle, stopping.totalStoppingDistance);
                firebaseSync.syncAlert(currentTripId, "emergency_brake", 1.0f);
                std::cout << "\nðŸš¨ EMERGENCY! BRAKE NOW! Vehicle " << (int)vehicle.distanceFeet << " ft ahead\n" << std::endl;
            } else if (zones.currentZone == "WARNING_YELLOW") {
                std::lock_guard<std::mutex> lock(statsMutex);
                stats.totalAlerts++;
                voiceAlert.alert("WARNING: Begin braking");
                database.saveAlert(currentTripId, "brake_warning", 0.7f, pos, vehicle, stopping.totalStoppingDistance);
                std::cout << "\nâš ï¸  WARNING: Begin braking - Vehicle " << (int)vehicle.distanceFeet << " ft ahead\n" << std::endl;
            } else if (zones.currentZone == "FOLLOWING_TOO_CLOSE") {
                voiceAlert.alert("Following too closely");
                std::cout << "â„¹ï¸  Following too closely\n" << std::endl;
            }
            float ttc = vehicle.getTimeToCollision(speed);
            if (ttc < 3.0f && ttc != INFINITY) {
                voiceAlert.alert("COLLISION WARNING");
                std::cout << "\nðŸš¨ COLLISION WARNING: " << std::fixed << std::setprecision(1) << ttc << " seconds\n" << std::endl;
            }
        }
    }
    void printStatus(const GPSPosition& pos, float speed, int speedLimit, const VehicleDetection& vehicle, const StoppingDistanceResult& stopping, const RoadConditions& conditions, const BrakeZones& zones) {
        std::cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘           LIVE MONITORING STATUS                      â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        std::cout << "â•‘ Speed:            " << std::setw(5) << (int)speed << " mph                              â•‘\n";
        std::cout << "â•‘ Speed Limit:      " << std::setw(5) << speedLimit << " mph                              â•‘\n";
        std::cout << "â•‘ Stopping Dist:    " << std::setw(5) << (int)stopping.totalStoppingDistance << " ft                               â•‘\n";
        std::cout << "â•‘   - Reaction:     " << std::setw(5) << (int)stopping.reactionDistance << " ft                               â•‘\n";
        std::cout << "â•‘   - Braking:      " << std::setw(5) << (int)stopping.brakingDistance << " ft                               â•‘\n";
        if (vehicle.isValid()) {
            std::cout << "â•‘ Vehicle Ahead:    " << std::setw(5) << (int)vehicle.distanceFeet << " ft (";
            if (zones.currentZone == "EMERGENCY_RED") std::cout << "ðŸ”´ EMERGENCY";
            else if (zones.currentZone == "WARNING_YELLOW") std::cout << "ðŸŸ¡ WARNING";
            else if (zones.currentZone == "CAUTION_GREEN") std::cout << "ðŸŸ¢ CAUTION";
            else std::cout << "âœ… SAFE";
            std::cout << ")      â•‘\nâ•‘ Relative Speed:   " << std::setw(5) << std::fixed << std::setprecision(1) << vehicle.relativeSpeedMph << " mph                              â•‘\n";
        } else std::cout << "â•‘ Vehicle Ahead:    No vehicle detected                  â•‘\n";
        std::cout << "â•‘ Surface:          " << std::left << std::setw(36) << stopping.surfaceCondition << "â•‘\n" << std::right;
        std::cout << "â•‘ Weather:          ";
        if (conditions.isRaining) std::cout << "Rain";
        else if (conditions.isSnowing) std::cout << "Snow";
        else if (conditions.isIce) std::cout << "Ice";
        else if (conditions.isFoggy) std::cout << "Fog";
        else std::cout << "Clear";
        std::cout << " (" << (int)conditions.temperature << "Â°F)                    â•‘\n";
        std::cout << "â•‘ GPS:              " << std::fixed << std::setprecision(6) << pos.latitude << ", " << pos.longitude << "â•‘\n";
        std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << std::endl;
    }
    void printTripSummary(int durationMinutes, int safetyScore) {
        std::cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘              TRIP SUMMARY REPORT                       â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        std::cout << "â•‘ Trip ID:          " << std::left << std::setw(36) << currentTripId << "â•‘\n" << std::right;
        std::cout << "â•‘ Duration:         " << std::setw(5) << durationMinutes << " minutes                             â•‘\n";
        std::cout << "â•‘ Total Distance:   " << std::setw(5) << std::fixed << std::setprecision(1) << stats.totalMiles << " miles                              â•‘\n";
        std::cout << "â•‘ Total Alerts:     " << std::setw(5) << stats.totalAlerts << "                                    â•‘\n";
        std::cout << "â•‘ Emergency Stops:  " << std::setw(5) << stats.emergencyBrakes << "                                    â•‘\n";
        std::cout << "â•‘ Speeding Events:  " << std::setw(5) << stats.speedingEvents << "                                    â•‘\n";
        std::cout << "â•‘ Safety Score:     " << std::setw(5) << safetyScore << " / 100                              â•‘\n";
        std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << std::endl;
    }
    int calculateSafetyScore() {
        int score = 100;
        score -= stats.emergencyBrakes * 20;
        score -= stats.speedingEvents * 5;
        score -= (stats.totalAlerts - stats.emergencyBrakes) * 2;
        return std::max(0, std::min(100, score));
    }
};

int main(int argc, char* argv[]) {
    curl_global_init(CURL_GLOBAL_DEFAULT);
    mongocxx::instance mongoInstance{};
    std::cout << R"(
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                          â•‘
    â•‘       META RAY-BAN DRIVER ASSIST SYSTEM v2.0             â•‘
    â•‘                                                          â•‘
    â•‘       AI-Powered Real-Time Driving Safety                â•‘
    â•‘       AASHTO/NHTSA Compliant Calculations                â•‘
    â•‘       AR Visualization + Distance Tracking               â•‘
    â•‘       Complete Database Integration                      â•‘
    â•‘