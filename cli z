#!/usr/bin/env python3
"""
Ultimate Crypto Super Bot - Unified Multi-Cryptocurrency Management System
Combines Zcash Super Bot with Multi-Crypto CLI Agent
Supports: Zcash, Monero, Ethereum with full RPC, CLI, and node management
Author: SAGEDEV1307
"""

import os
import sys
import subprocess
import json
import requests
import platform
import shutil
from pathlib import Path
import argparse
import time
import webbrowser
import sqlite3
from typing import Dict, List, Optional, Tuple, Any
import getpass
import hashlib
import base64
import threading
from datetime import datetime
import logging
from bs4 import BeautifulSoup
import re

class CryptoCommandScraper:
    """Scrapes and caches CLI commands from official documentation"""
    
    def __init__(self):
        self.command_cache = {
            'zcash': {},
            'monero': {},
            'ethereum': {}
        }
        self.doc_urls = {
            'zcash': 'https://zcash.readthedocs.io/en/latest/rtd_pages/zcash-cli.html',
            'monero': 'https://docs.getmonero.org/interacting/monero-wallet-cli-reference/',
            'ethereum': 'https://geth.ethereum.org/docs/fundamentals/command-line-options'
        }
    
    def scrape_zcash_commands(self) -> Dict[str, Any]:
        """Dynamically scrape Zcash CLI commands"""
        try:
            result = subprocess.run(['zcash-cli', 'help'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                commands = {}
                lines = result.stdout.split('\n')
                for line in lines:
                    if line.strip() and not line.startswith('='):
                        parts = line.split()
                        if parts:
                            cmd = parts[0]
                            commands[cmd] = ' '.join(parts[1:]) if len(parts) > 1 else "No description"
                self.command_cache['zcash'] = commands
                return commands
        except Exception as e:
            logging.error(f"Failed to scrape Zcash commands: {e}")
        return {}
    
    def scrape_monero_commands(self) -> Dict[str, Any]:
        """Dynamically discover Monero wallet commands"""
        commands = {
            'help': 'Show all available commands',
            'balance': 'Show wallet balance',
            'address': 'Show wallet address',
            'transfer': 'Send XMR to an address',
            'show_transfers': 'Show transaction history',
            'wallet_info': 'Display wallet information',
            'refresh': 'Sync with blockchain',
            'account': 'Manage accounts',
            'get_tx_key': 'Get transaction private key',
            'check_tx_key': 'Verify transaction',
            'export_outputs': 'Export outputs for cold wallet',
            'import_outputs': 'Import outputs from cold wallet',
            'sweep_all': 'Send entire balance'
        }
        self.command_cache['monero'] = commands
        return commands
    
    def scrape_ethereum_commands(self) -> Dict[str, Any]:
        """Dynamically discover Geth commands"""
        try:
            result = subprocess.run(['geth', '--help'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                commands = {}
                lines = result.stdout.split('\n')
                in_commands = False
                for line in lines:
                    if 'COMMANDS:' in line:
                        in_commands = True
                        continue
                    if in_commands and line.strip():
                        parts = line.strip().split(maxsplit=1)
                        if len(parts) >= 2:
                            commands[parts[0]] = parts[1]
                        elif len(parts) == 1:
                            commands[parts[0]] = "No description"
                self.command_cache['ethereum'] = commands
                return commands
        except Exception as e:
            logging.error(f"Failed to scrape Ethereum commands: {e}")
        return {}

class UltimateCryptoSuperBot:
    def __init__(self):
        self.system = platform.system().lower()
        self.setup_directories()
        self.setup_logging()
        
        # Initialize components
        self.scraper = CryptoCommandScraper()
        self.rpc_url = "http://127.0.0.1:8232/"
        self.monero_wallet_rpc_url = "http://127.0.0.1:18082/json_rpc"
        self.geth = "geth"
        
        # Load all systems
        self.rpc_commands = self.load_all_rpc_commands()
        self.documentation_urls = self.load_unified_documentation()
        self.crypto_libs = self.load_crypto_libraries()
        
        # Auto-discover available commands
        logging.info("Discovering available commands...")
        self.scraper.scrape_zcash_commands()
        self.scraper.scrape_monero_commands()
        self.scraper.scrape_ethereum_commands()
        
    def setup_directories(self):
        """Setup necessary directories for all cryptocurrencies"""
        self.data_dir = Path.home() / ".crypto_super_bot"
        self.data_dir.mkdir(exist_ok=True)
        
        # Zcash directories
        self.zcash_dir = self.get_zcash_path()
        self.zcash_config_dir = self.zcash_dir / "zcash.conf"
        
        # Monero directories
        self.monero_dir = Path.home() / ".bitmonero"
        self.monero_wallet_dir = self.monero_dir / "wallets"
        
        # Ethereum directories
        self.ethereum_dir = Path.home() / ".ethereum"
        
    def setup_logging(self):
        """Setup unified logging system"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.data_dir / 'crypto_super_bot.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
    def get_zcash_path(self) -> Path:
        """Get Zcash installation path based on OS"""
        if self.system == "linux" or self.system == "darwin":
            return Path.home() / ".zcash"
        elif self.system == "windows":
            return Path.home() / "AppData" / "Roaming" / "Zcash"
        else:
            return Path.home() / ".zcash"

    def load_unified_documentation(self) -> Dict:
        """Load all documentation URLs from both systems"""
        return {
            # Zcash documentation
            "zcash_getting_started": "https://zcash.readthedocs.io/en/latest/",
            "zcash_rpc_docs": "https://zcash.github.io/rpc/",
            "zcash_book": "https://zcash.github.io/zcash/",
            "zcash_developer_roadmap": "https://zcash.github.io/developers/",
            "zcash_orchard": "https://github.com/zcash/orchard",
            "zcash_halo2": "https://github.com/zcash/halo2",
            "zcash_librustzcash": "https://github.com/zcash/librustzcash",
            "zcash_orchard_docs": "https://zcash.github.io/orchard",
            "zcash_halo2_docs": "https://zcash.github.io/halo2",
            "zcash_librustzcash_docs": "https://zcash.github.io/librustzcash",
            "zcash_payment_api": "https://nathan-zcash-docs.readthedocs.io/en/latest/rtd_pages/payment_api.html",
            "zcash_shield_coinbase": "https://zcash.readthedocs.io/en/latest/rtd_pages/shield_coinbase.html",
            
            # Monero documentation
            "monero_wallet_cli": "https://docs.getmonero.org/interacting/monero-wallet-cli-reference/",
            "monero_rpc": "https://www.getmonero.org/resources/developer-guides/wallet-rpc.html",
            "monero_developer": "https://github.com/monero-project/monero",
            
            # Ethereum documentation
            "ethereum_geth": "https://geth.ethereum.org/docs/fundamentals/command-line-options",
            "ethereum_jsonrpc": "https://ethereum.org/en/developers/docs/apis/json-rpc/",
            "ethereum_web3": "https://web3js.readthedocs.io/"
        }

    def load_crypto_libraries(self) -> Dict:
        """Load cryptographic library information"""
        return {
            "orchard": {
                "name": "Orchard",
                "description": "Zcash's latest shielded protocol",
                "github": "https://github.com/zcash/orchard",
                "docs": "https://zcash.github.io/orchard"
            },
            "halo2": {
                "name": "Halo2", 
                "description": "Zero-knowledge proof system",
                "github": "https://github.com/zcash/halo2",
                "docs": "https://zcash.github.io/halo2"
            },
            "librustzcash": {
                "name": "librustzcash",
                "description": "Zcash cryptographic library in Rust",
                "github": "https://github.com/zcash/librustzcash",
                "docs": "https://zcash.github.io/librustzcash"
            }
        }

    def load_all_rpc_commands(self) -> Dict[str, Dict]:
        """Load COMPLETE RPC commands from all cryptocurrencies"""
        commands = {}
        
        # Wallet RPC Methods [citation:2]
        wallet_commands = {
            "getnewaddress": {
                "description": "Generate a new transparent address",
                "usage": "getnewaddress (label)",
                "example": 'zcash-cli getnewaddress "savings"',
                "category": "wallet",
                "crypto": "zcash"
            },
            "z_getnewaddress": {
                "description": "Generate a new shielded address", 
                "usage": "z_getnewaddress",
                "example": "zcash-cli z_getnewaddress",
                "category": "wallet",
                "crypto": "zcash"
            },
            "z_getbalance": {
                "description": "Get balance for address",
                "usage": "z_getbalance address (minconf)",
                "example": 'zcash-cli z_getbalance "zs..." 1',
                "category": "wallet",
                "crypto": "zcash"
            },
            "z_sendmany": {
                "description": "Send from an address to multiple recipients",
                "usage": 'z_sendmany "fromaddress" [{"address":amount,...}] (minconf) (fee)',
                "example": 'zcash-cli z_sendmany "t1..." \'[{"address": "zs...", "amount": 10.0}]\'',
                "category": "wallet",
                "crypto": "zcash"
            },
            "z_shieldcoinbase": {
                "description": "Shield transparent coinbase funds", 
                "usage": 'z_shieldcoinbase "fromaddress" "toaddress" (fee) (limit)',
                "example": 'zcash-cli z_shieldcoinbase "tMyMiningAddress" "zMyPrivateAddress"',
                "category": "wallet",
                "crypto": "zcash"
            },
            "z_exportwallet": {
                "description": "Export wallet keys to file",
                "usage": 'z_exportwallet "filename"', 
                "example": 'zcash-cli z_exportwallet "export.dat"',
                "category": "wallet",
                "crypto": "zcash"
            },
            "z_importwallet": {
                "description": "Import keys from file",
                "usage": 'z_importwallet "filename"',
                "example": 'zcash-cli z_importwallet "export.dat"',
                "category": "wallet",
                "crypto": "zcash"
            },
            "walletpassphrase": {
                "description": "Unlock wallet",
                "usage": 'walletpassphrase "passphrase" timeout',
                "example": 'zcash-cli walletpassphrase "passphrase" 300',
                "category": "wallet",
                "crypto": "zcash"
            }
        }
        commands.update(wallet_commands)

        # Specialized RPC Methods [citation:4][citation:5][citation:6]
        specialized_commands = {
            "z_setmigration": {
                "description": "Enable Sprout to Sapling migration",
                "usage": "z_setmigration enabled",
                "example": "zcash-cli z_setmigration true", 
                "category": "wallet",
                "crypto": "zcash",
                "note": "Takes several weeks for significant balances"
            },
            "z_viewtransaction": {
                "description": "Get detailed shielded information about transaction",
                "usage": 'z_viewtransaction "txid"',
                "example": 'zcash-cli z_viewtransaction "1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d"',
                "category": "wallet",
                "crypto": "zcash"
            },
            "zcbenchmark": {
                "description": "Run benchmarks", 
                "usage": "zcbenchmark benchmarktype samplecount",
                "example": "zcash-cli zcbenchmark verify 10",
                "category": "control",
                "crypto": "zcash"
            }
        }
        commands.update(specialized_commands)

        # Additional commands from comprehensive lists [citation:8][citation:10]
        additional_categories = {
            # Blockchain
            "getblockchaininfo": {
                "category": "blockchain", 
                "description": "Get blockchain state information",
                "crypto": "zcash"
            },
            "getblockcount": {
                "category": "blockchain", 
                "description": "Get current block height",
                "crypto": "zcash"
            },
            "getbestblockhash": {
                "category": "blockchain", 
                "description": "Get best block hash",
                "crypto": "zcash"
            },
            
            # Network  
            "getnetworkinfo": {
                "category": "network", 
                "description": "Get network information",
                "crypto": "zcash"
            },
            "getpeerinfo": {
                "category": "network", 
                "description": "Get peer information",
                "crypto": "zcash"
            },
            
            # Mining
            "getmininginfo": {
                "category": "mining", 
                "description": "Get mining information",
                "crypto": "zcash"
            },
            "getblocksubsidy": {
                "category": "mining", 
                "description": "Get block subsidy",
                "crypto": "zcash"
            },
            
            # Raw transactions
            "getrawtransaction": {
                "category": "rawtransactions", 
                "description": "Get raw transaction data",
                "crypto": "zcash"
            },
            "sendrawtransaction": {
                "category": "rawtransactions", 
                "description": "Send raw transaction",
                "crypto": "zcash"
            },
            
            # Utility
            "validateaddress": {
                "category": "util", 
                "description": "Validate address",
                "crypto": "zcash"
            },
            "z_validateaddress": {
                "category": "util", 
                "description": "Validate z-address",
                "crypto": "zcash"
            }
        }
        
        # Merge all commands
        for cmd, info in additional_categories.items():
            if cmd not in commands:
                commands[cmd] = info
                
        return commands

    def install_zcash_node(self):
        """Install and configure Zcash node"""
        print("üöÄ Installing Zcash Node...")
        
        # Create directories [citation:9]
        self.zcash_dir.mkdir(parents=True, exist_ok=True)
        
        # Create basic zcash.conf [citation:9]
        config_content = """# Basic Zcash configuration
testnet=0
server=1
rpcuser=zcashrpc
rpcpassword={}
rpcport=8232
rpcallowip=127.0.0.1
txindex=1
addressindex=1
timestampindex=1
spentindex=1
""".format(self.generate_password())
        
        with open(self.zcash_config_dir, 'w') as f:
            f.write(config_content)
            
        print(f"‚úÖ Zcash configuration created at: {self.zcash_config_dir}")
        
        # Provide installation instructions based on OS [citation:9]
        install_instructions = {
            "linux": """
            For Linux systems (best-effort supported):
            git clone https://github.com/zcash/zcash.git
            cd zcash
            git checkout v6.10.0
            ./zcutil/clean.sh
            ./zcutil/build.sh -j$(nproc)
            """,
            "darwin": """
            For macOS (best-effort supported):
            git clone https://github.com/zcash/zcash.git
            cd zcash
            git checkout v6.10.0
            ./zcutil/clean.sh
            ./zcutil/build.sh
            """,
            "windows": """
            For Windows (unsupported but possible):
            Use Windows Subsystem for Linux (WSL) or follow:
            https://github.com/zcash/zcash/blob/master/doc/build-windows.md
            """
        }
        
        print(f"üìù Installation instructions for {self.system}:")
        print(install_instructions.get(self.system, install_instructions["linux"]))
        
        # Fetch parameters [citation:9]
        print("üì• Downloading Zcash parameters...")
        try:
            subprocess.run(["./zcutil/fetch-params.sh"], check=True, cwd="zcash")
        except:
            print("‚ö†Ô∏è  Parameter download may be required after building")

    def install_all_nodes(self):
        """Install and configure all cryptocurrency nodes"""
        print("üöÄ Installing All Cryptocurrency Nodes...")
        
        # Install Zcash
        self.install_zcash_node()
        
        # Provide Monero installation instructions
        print("\nüì• Monero Installation:")
        monero_instructions = {
            "linux": """
            Ubuntu/Debian:
            sudo apt update
            sudo apt install monero-wallet-rpc monero-wallet-cli
            
            Or build from source:
            git clone https://github.com/monero-project/monero.git
            cd monero
            git checkout v0.18.3.1
            make release -j$(nproc)
            """,
            "darwin": """
            macOS:
            brew install monero
            """,
            "windows": """
            Download from: https://www.getmonero.org/downloads/
            Or use Windows Subsystem for Linux (WSL)
            """
        }
        print(monero_instructions.get(self.system, monero_instructions["linux"]))
        
        # Provide Ethereum installation instructions
        print("\nüì• Ethereum/Geth Installation:")
        ethereum_instructions = {
            "linux": """
            Ubuntu/Debian:
            sudo add-apt-repository -y ppa:ethereum/ethereum
            sudo apt update
            sudo apt install ethereum
            
            Or download from: https://geth.ethereum.org/downloads/
            """,
            "darwin": """
            macOS:
            brew tap ethereum/ethereum
            brew install ethereum
            """,
            "windows": """
            Download from: https://geth.ethereum.org/downloads/
            Or use Chocolatey: choco install geth
            """
        }
        print(ethereum_instructions.get(self.system, ethereum_instructions["linux"]))

    def generate_password(self, length=32):
        """Generate secure RPC password"""
        return base64.b64encode(os.urandom(length)).decode('utf-8')

    def execute_shell_command(self, command: List[str]) -> Dict[str, Any]:
        """Execute any shell command and return structured result"""
        try:
            result = subprocess.run(command, capture_output=True, text=True, timeout=60)
            return {
                "success": result.returncode == 0,
                "output": result.stdout,
                "error": result.stderr,
                "returncode": result.returncode
            }
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Command timed out after 60 seconds"}
        except FileNotFoundError:
            return {"success": False, "error": f"Command not found: {command[0]}"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    # ==================== ZCASH OPERATIONS ====================

    def zcash_execute(self, command: str, *args) -> Dict[str, Any]:
        """Execute any Zcash CLI command dynamically"""
        cmd = ["zcash-cli", command] + list(args)
        result = self.execute_shell_command(cmd)
        if result["success"] and result["output"]:
            try:
                result["parsed"] = json.loads(result["output"])
            except json.JSONDecodeError:
                result["parsed"] = result["output"]
        return result
    
    def run_cli_command(self, command: str, params: List[str] = None) -> Dict:
        """Execute Zcash CLI command (legacy compatibility)"""
        return self.zcash_execute(command, *(params or []))

    def run_rpc_call(self, method: str, params: List = None):
        """Execute JSON-RPC call directly"""
        if params is None:
            params = []
            
        payload = {
            "jsonrpc": "1.0",
            "id": "cryptobot",
            "method": method,
            "params": params
        }
        
        try:
            # Read RPC credentials from config
            with open(self.zcash_config_dir, 'r') as f:
                config_content = f.read()
                
            rpc_user = "zcashrpc"  # Extract from config
            rpc_password = "password"  # Extract from config
            
            response = requests.post(
                self.rpc_url,
                json=payload,
                auth=(rpc_user, rpc_password),
                headers={'content-type': 'text/plain;'}
            )
            
            return response.json()
            
        except Exception as e:
            self.logger.error(f"RPC call failed: {e}")
            return {"error": str(e)}

    def zcash_get_balance(self) -> Dict[str, Any]:
        """Get total Zcash balance (transparent + shielded)"""
        return self.zcash_execute("z_gettotalbalance")
    
    def zcash_get_address(self, addr_type: str = "sapling") -> Optional[str]:
        """Generate new Zcash address"""
        if addr_type == "sapling":
            result = self.zcash_execute("z_getnewaddress", "sapling")
        else:
            result = self.zcash_execute("getnewaddress")
        return result["output"].strip() if result["success"] else None
    
    def zcash_send(self, to_addr: str, amount: str, from_addr: str = None) -> Dict[str, Any]:
        """Send Zcash transaction"""
        if from_addr:
            # Shielded transaction using z_sendmany
            tx_data = json.dumps([{"address": to_addr, "amount": float(amount)}])
            return self.zcash_execute("z_sendmany", from_addr, tx_data)
        else:
            # Transparent transaction
            return self.zcash_execute("sendtoaddress", to_addr, amount)
    
    def zcash_get_info(self) -> Dict[str, Any]:
        """Get blockchain and node info"""
        return self.zcash_execute("getinfo")
    
    def zcash_list_addresses(self) -> Dict[str, Any]:
        """List all addresses in wallet"""
        transparent = self.zcash_execute("listaddresses")
        shielded = self.zcash_execute("z_listaddresses")
        return {
            "transparent": transparent.get("parsed", []),
            "shielded": shielded.get("parsed", [])
        }

    # ==================== MONERO OPERATIONS ====================
    
    def monero_rpc_call(self, method: str, params: Dict = None) -> Dict[str, Any]:
        """Execute Monero wallet RPC call"""
        payload = {
            "jsonrpc": "2.0",
            "id": "0",
            "method": method,
            "params": params or {}
        }
        try:
            response = requests.post(self.monero_wallet_rpc_url, json=payload, timeout=30)
            return response.json()
        except requests.exceptions.ConnectionError:
            return {"error": "Cannot connect to Monero wallet RPC. Is monero-wallet-rpc running?"}
        except Exception as e:
            return {"error": str(e)}
    
    def monero_get_balance(self) -> Dict[str, float]:
        """Get Monero wallet balance"""
        result = self.monero_rpc_call("get_balance")
        if "result" in result:
            return {
                "balance": result["result"]["balance"] / 1e12,
                "unlocked_balance": result["result"]["unlocked_balance"] / 1e12
            }
        return {"error": result.get("error", "Unknown error")}
    
    def monero_get_address(self, account_index: int = 0, address_index: List[int] = None) -> Optional[str]:
        """Get Monero wallet address"""
        params = {"account_index": account_index}
        if address_index:
            params["address_index"] = address_index
        result = self.monero_rpc_call("get_address", params)
        if "result" in result:
            return result["result"]["address"]
        return None
    
    def monero_transfer(self, address: str, amount: float, priority: int = 0) -> Dict[str, Any]:
        """Send Monero transaction"""
        params = {
            "destinations": [{"amount": int(amount * 1e12), "address": address}],
            "priority": priority,
            "ring_size": 16,
            "get_tx_key": True
        }
        return self.monero_rpc_call("transfer", params)
    
    def monero_get_height(self) -> int:
        """Get current blockchain height"""
        result = self.monero_rpc_call("get_height")
        if "result" in result:
            return result["result"]["height"]
        return 0
    
    def monero_sweep_all(self, address: str) -> Dict[str, Any]:
        """Send all available balance to address"""
        params = {"address": address}
        return self.monero_rpc_call("sweep_all", params)

    # ==================== ETHEREUM/GETH OPERATIONS ====================
    
    def geth_attach_exec(self, command: str) -> Dict[str, Any]:
        """Execute command via geth attach"""
        cmd = [self.geth, "attach", "--exec", command]
        return self.execute_shell_command(cmd)
    
    def geth_account_new(self, password: str = None) -> Dict[str, Any]:
        """Create new Ethereum account"""
        if password:
            cmd = [self.geth, "account", "new", "--password", password]
        else:
            cmd = [self.geth, "account", "new"]
        return self.execute_shell_command(cmd)
    
    def geth_account_list(self) -> Dict[str, Any]:
        """List all Ethereum accounts"""
        return self.execute_shell_command([self.geth, "account", "list"])
    
    def eth_get_balance(self, address: str) -> Dict[str, Any]:
        """Get Ethereum balance for address"""
        command = f'eth.getBalance("{address}")'
        return self.geth_attach_exec(command)
    
    def eth_send_transaction(self, from_addr: str, to_addr: str, value: str) -> Dict[str, Any]:
        """Send Ethereum transaction"""
        command = f'eth.sendTransaction({{from:"{from_addr}", to:"{to_addr}", value: web3.toWei({value}, "ether")}})'
        return self.geth_attach_exec(command)
    
    def eth_get_block_number(self) -> Dict[str, Any]:
        """Get current block number"""
        return self.geth_attach_exec("eth.blockNumber")
    
    def eth_syncing(self) -> Dict[str, Any]:
        """Check if node is syncing"""
        return self.geth_attach_exec("eth.syncing")

    # ==================== UNIFIED OPERATIONS ====================

    def open_documentation(self, doc_type: str):
        """Open relevant documentation in browser"""
        doc_map = {
            "zcash": self.documentation_urls["zcash_getting_started"],
            "monero": self.documentation_urls["monero_wallet_cli"],
            "ethereum": self.documentation_urls["ethereum_geth"],
            "orchard": self.documentation_urls["zcash_orchard_docs"],
            "halo2": self.documentation_urls["zcash_halo2_docs"],
            "shield": self.documentation_urls["zcash_shield_coinbase"]
        }
        
        if doc_type in doc_map:
            webbrowser.open(doc_map[doc_type])
            print(f"üìö Opening {doc_type} documentation...")
        else:
            print("‚ùå Unknown documentation type")

    def get_all_balances(self) -> Dict[str, Any]:
        """Get balances for all cryptocurrencies"""
        balances = {}
        
        # Zcash balance
        try:
            zcash_balance = self.zcash_get_balance()
            balances["zcash"] = zcash_balance
        except Exception as e:
            balances["zcash"] = {"error": str(e)}
            
        # Monero balance
        try:
            monero_balance = self.monero_get_balance()
            balances["monero"] = monero_balance
        except Exception as e:
            balances["monero"] = {"error": str(e)}
            
        # Ethereum block number (placeholder for balance)
        try:
            eth_block = self.eth_get_block_number()
            balances["ethereum"] = {"block_height": eth_block}
        except Exception as e:
            balances["ethereum"] = {"error": str(e)}
            
        return balances

    def execute_unified_command(self, crypto: str, command: str, *args) -> Dict[str, Any]:
        """Execute command for any cryptocurrency"""
        crypto = crypto.lower()
        
        if crypto == "zcash":
            return self.zcash_execute(command, *args)
        elif crypto == "monero":
            return self.monero_rpc_call(command, args[0] if args else {})
        elif crypto == "ethereum":
            if command.startswith("eth_"):
                # Direct Ethereum command
                method_name = command
                if hasattr(self, method_name):
                    return getattr(self, method_name)(*args)
            return self.geth_attach_exec(command)
        else:
            return {"error": f"Unknown cryptocurrency: {crypto}"}

    def wallet_operations(self, crypto: str = "zcash"):
        """Comprehensive wallet management for all cryptos"""
        print(f"\nüí∞ {crypto.upper()} Wallet Operations:")
        
        if crypto == "zcash":
            print("1. Create new addresses")
            print("2. Check balances") 
            print("3. Send transactions")
            print("4. Backup wallet")
            print("5. Shield coinbase funds")
            
            choice = input("Select operation: ").strip()
            
            if choice == "1":
                addr_type = input("Address type (taddr/zaddr) [zaddr]: ").strip() or "zaddr"
                if addr_type == "zaddr":
                    result = self.zcash_execute("z_getnewaddress")
                    print(f"‚úÖ New shielded address: {result}")
                else:
                    label = input("Label (optional): ").strip()
                    result = self.zcash_execute("getnewaddress", [label] if label else [])
                    print(f"‚úÖ New transparent address: {result}")
                    
            elif choice == "2":
                balance_type = input("Balance type (total/address) [total]: ").strip() or "total"
                if balance_type == "total":
                    result = self.zcash_get_balance()
                    print(f"üí∞ Total balance: {result}")
                else:
                    address = input("Enter address: ").strip()
                    result = self.zcash_execute("z_getbalance", [address, "1"])
                    print(f"üí∞ Balance for {address}: {result}")
                    
        elif crypto == "monero":
            print("1. Get address")
            print("2. Check balance")
            print("3. Send XMR")
            print("4. Sweep all funds")
            print("5. Transaction history")
            
            choice = input("Select operation: ").strip()
            
            if choice == "1":
                address = self.monero_get_address()
                print(f"‚úÖ Monero address: {address}")
            elif choice == "2":
                balance = self.monero_get_balance()
                print(f"üí∞ Monero balance: {balance}")
                
        elif crypto == "ethereum":
            print("1. Create account")
            print("2. List accounts") 
            print("3. Check balance")
            print("4. Send ETH")
            print("5. Blockchain info")
            
            choice = input("Select operation: ").strip()
            
            if choice == "1":
                result = self.geth_account_new()
                print(f"‚úÖ New Ethereum account: {result}")
            elif choice == "3":
                address = input("Enter Ethereum address: ").strip()
                balance = self.eth_get_balance(address)
                print(f"üí∞ Balance for {address}: {balance}")

    def transaction_operations(self, crypto: str = "zcash"):
        """Comprehensive transaction management"""
        print(f"\nüîó {crypto.upper()} Transaction Operations:")
        
        if crypto == "zcash":
            print("1. Send to address")
            print("2. Send multiple (z_sendmany)")
            print("3. Shield coinbase funds") 
            print("4. View transaction details")
            print("5. List transactions")
            
            choice = input("Select operation: ").strip()
            
            if choice == "2":
                from_addr = input("From address: ").strip()
                to_addr = input("To address: ").strip() 
                amount = input("Amount: ").strip()
                fee = input("Fee [0.0001]: ").strip() or "0.0001"
                
                recipients = [{"address": to_addr, "amount": float(amount)}]
                params = [from_addr, json.dumps(recipients), 1, float(fee)]
                
                print(f"üöÄ Sending {amount} ZEC from {from_addr} to {to_addr}...")
                result = self.zcash_execute("z_sendmany", *[str(p) for p in params])
                print(f"‚úÖ Operation ID: {result}")

            elif choice == "3":
                from_addr = input("From address (or '*' for all): ").strip()
                to_addr = input("To shielded address: ").strip()
                fee = input("Fee [0.001]: ").strip() or "0.001"
                limit = input("UTXO limit [50]: ").strip() or "50"
                
                print(f"üõ°Ô∏è  Shielding coinbase funds to {to_addr}...")
                result = self.zcash_execute("z_shieldcoinbase", from_addr, to_addr, fee, limit)
                print(f"‚úÖ Shield operation: {result}")
                
        elif crypto == "monero":
            print("1. Send XMR")
            print("2. Sweep all")
            print("3. Get transaction key")
            print("4. Check transaction")
            
            choice = input("Select operation: ").strip()
            
            if choice == "1":
                address = input("To address: ").strip()
                amount = input("Amount: ").strip()
                result = self.monero_transfer(address, float(amount))
                print(f"‚úÖ Transaction: {result}")

    def node_management(self, crypto: str = "zcash"):
        """Node management and monitoring"""
        print(f"\n‚öôÔ∏è {crypto.upper()} Node Management:")
        
        if crypto == "zcash":
            print("1. Node information")
            print("2. Blockchain info")
            print("3. Network info")
            print("4. Mining info")
            print("5. Benchmark node")
            
            choice = input("Select operation: ").strip()
            
            if choice == "1":
                result = self.zcash_get_info()
                print(f"üìä Node info: {json.dumps(result, indent=2)}")
            elif choice == "5":
                benchmark_type = input("Benchmark type: ").strip()
                sample_count = input("Sample count: ").strip()
                result = self.zcash_execute("zcbenchmark", benchmark_type, sample_count)
                print(f"üìà Benchmark results: {result}")
                
        elif crypto == "ethereum":
            print("1. Block number")
            print("2. Sync status")
            print("3. Create account")
            print("4. List accounts")
            
            choice = input("Select operation: ").strip()
            
            if choice == "1":
                result = self.eth_get_block_number()
                print(f"üì¶ Current block: {result}")
            elif choice == "2":
                result = self.eth_syncing()
                print(f"üîÑ Sync status: {result}")

    def show_help(self):
        """Display comprehensive help"""
        print(f"""
ü§ñ Ultimate Crypto Super Bot - Complete Multi-Cryptocurrency Management System

Supported Cryptocurrencies:
‚Ä¢ Zcash (zcash-cli) - Full RPC support with shielded transactions
‚Ä¢ Monero (monero-wallet-rpc) - Private transactions with wallet RPC
‚Ä¢ Ethereum (geth) - Smart contracts and Web3 integration

Available Resources:
üìö Documentation:
   - Zcash: {self.documentation_urls['zcash_getting_started']}
   - Monero: {self.documentation_urls['monero_wallet_cli']}
   - Ethereum: {self.documentation_urls['ethereum_geth']}

üîê Cryptographic Libraries:
   - Orchard: {self.crypto_libs['orchard']['github']}
   - Halo2: {self.crypto_libs['halo2']['github']}
   - librustzcash: {self.crypto_libs['librustzcash']['github']}

üíª Available Commands: {len(self.rpc_commands)}+ methods across all cryptos

üõ†Ô∏è Usage Examples:
   Zcash:
   - Create shielded address: zcash z_getnewaddress
   - Send shielded transaction: zcash z_sendmany "from" '[{{"address":"to","amount":1.0}}]'
   - Shield coinbase: zcash z_shieldcoinbase "*" "zsaddress"

   Monero:
   - Get balance: monero get_balance
   - Send XMR: monero transfer address amount
   - Sweep all: monero sweep_all address

   Ethereum:
   - Check balance: ethereum eth_get_balance "0x..."
   - Send ETH: ethereum eth_send_transaction "from" "to" "amount"
   - Block info: ethereum eth_blockNumber

Universal Commands:
   - balances: Get all cryptocurrency balances
   - install: Install all nodes
   - wallet <crypto>: Wallet operations
   - tx <crypto>: Transaction operations
   - node <crypto>: Node management
   - docs <type>: Open documentation

‚ö†Ô∏è Important Notes:
   - Ensure nodes are running before operations
   - Wallet must be unlocked for sensitive operations
   - Shielded transactions are asynchronous
   - Always backup wallet files and private keys
        """)

    def interactive_mode(self):
        """Run interactive bot mode"""
        print("üöÄ Ultimate Crypto Super Bot Started!")
        print("Type 'help' for commands, 'exit' to quit")
        
        while True:
            try:
                user_input = input("\nü§ñ CryptoBot> ").strip().lower()
                
                if user_input in ['exit', 'quit']:
                    break
                elif user_input == 'help':
                    self.show_help()
                elif user_input == 'install':
                    self.install_all_nodes()
                elif user_input == 'balances':
                    balances = self.get_all_balances()
                    print(json.dumps(balances, indent=2))
                elif user_input.startswith('wallet'):
                    parts = user_input.split()
                    crypto = parts[1] if len(parts) > 1 else "zcash"
                    self.wallet_operations(crypto)
                elif user_input.startswith('tx'):
                    parts = user_input.split()
                    crypto = parts[1] if len(parts) > 1 else "zcash"
                    self.transaction_operations(crypto)
                elif user_input.startswith('node'):
                    parts = user_input.split()
                    crypto = parts[1] if len(parts) > 1 else "zcash"
                    self.node_management(crypto)
                elif user_input.startswith('docs'):
                    parts = user_input.split()
                    doc_type = parts[1] if len(parts) > 1 else "zcash"
                    self.open_documentation(doc_type)
                elif user_input == 'status':
                    self.zcash_get_info()
                elif user_input == '':
                    continue
                elif len(user_input.split()) >= 2:
                    # Direct command execution: <crypto> <command> [args...]
                    parts = user_input.split()
                    crypto = parts[0]
                    command = parts[1]
                    args = parts[2:]
                    
                    result = self.execute_unified_command(crypto, command, *args)
                    print(json.dumps(result, indent=2))
                else:
                    print("‚ùå Unknown command. Type 'help' for available commands.")
                    
            except KeyboardInterrupt:
                print("\nüëã Goodbye!")
                break
            except Exception as e:
                self.logger.error(f"Error: {e}")
                print(f"‚ùå Error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="Ultimate Crypto Super Bot")
    parser.add_argument('--interactive', '-i', action='store_true', help='Interactive mode')
    parser.add_argument('--install', action='store_true', help='Install all nodes')
    parser.add_argument('--crypto', help='Cryptocurrency (zcash|monero|ethereum)')
    parser.add_argument('--command', '-c', help='Execute single command')
    parser.add_argument('--params', '-p', nargs='*', help='Command parameters')
    
    args = parser.parse_args()
    
    bot = UltimateCryptoSuperBot()
    
    if args.install:
        bot.install_all_nodes()
    elif args.command and args.crypto:
        result = bot.execute_unified_command(args.crypto, args.command, *(args.params or []))
        print(json.dumps(result, indent=2))
    else:
        bot.interactive_mode()

if __name__ == "__main__":
    main()