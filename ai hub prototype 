"""
COMPLETE AI HUB - FULL PRODUCTION SYSTEM
All AI Services: Claude Code Agent, DALL-E 3, Stable Diffusion, Flux, Imagen 3, Runway Gen-4, Veo 3, ElevenLabs, Whisper, etc.
Install: pip install flask flask-cors flask-sqlalchemy flask-jwt-extended openai anthropic google-generativeai replicate elevenlabs stability-sdk celery redis bcrypt httpx pillow boto3
"""

from flask import Flask, request, jsonify, send_file, send_from_directory
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta
from openai import OpenAI
from anthropic import Anthropic
import google.generativeai as genai
from elevenlabs.client import ElevenLabs
from elevenlabs import Voice, VoiceSettings
import replicate
import requests
import base64
import time
import os
import json
import subprocess
from celery import Celery
import redis
import httpx
from pathlib import Path
import shutil
import tempfile

# ==================== APP CONFIGURATION ====================
app = Flask(__name__)
CORS(app)

app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///ai_hub.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['JWT_SECRET_KEY'] = os.getenv('JWT_SECRET_KEY', 'your-secret-key-change-this')
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(days=30)

UPLOAD_FOLDER = 'storage/generations'
CODE_PROJECTS_FOLDER = 'storage/code_projects'
AUDIO_FOLDER = 'storage/audio'
VIDEO_FOLDER = 'storage/video'

for folder in [UPLOAD_FOLDER, CODE_PROJECTS_FOLDER, AUDIO_FOLDER, VIDEO_FOLDER]:
    os.makedirs(folder, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['CODE_PROJECTS_FOLDER'] = CODE_PROJECTS_FOLDER
app.config['AUDIO_FOLDER'] = AUDIO_FOLDER
app.config['VIDEO_FOLDER'] = VIDEO_FOLDER

db = SQLAlchemy(app)
jwt = JWTManager(app)
celery = Celery(app.name, broker='redis://localhost:6379/0')
celery.conf.update(app.config)
redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)

# ==================== DATABASE MODELS ====================

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(200), nullable=False)
    role = db.Column(db.String(20), default='user')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    is_active = db.Column(db.Boolean, default=True)
    credits = db.Column(db.Integer, default=100)
    generations = db.relationship('Generation', backref='user', lazy=True)
    api_keys = db.relationship('APIKey', backref='user', lazy=True)
    code_projects = db.relationship('CodeProject', backref='user', lazy=True)

class APIKey(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    service = db.Column(db.String(50), nullable=False)
    encrypted_key = db.Column(db.String(500), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Generation(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    service = db.Column(db.String(50), nullable=False)
    type = db.Column(db.String(20), nullable=False)
    prompt = db.Column(db.Text, nullable=False)
    status = db.Column(db.String(20), default='pending')
    result_path = db.Column(db.String(500))
    result_url = db.Column(db.String(500))
    result_data = db.Column(db.Text)
    cost = db.Column(db.Float, default=0.0)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    completed_at = db.Column(db.DateTime)
    error_message = db.Column(db.Text)
    metadata = db.Column(db.Text)

class CodeProject(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    name = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    project_path = db.Column(db.String(500))
    status = db.Column(db.String(20), default='active')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    agent_sessions = db.relationship('AgentSession', backref='project', lazy=True)

class AgentSession(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    project_id = db.Column(db.Integer, db.ForeignKey('code_project.id'), nullable=False)
    task = db.Column(db.Text, nullable=False)
    status = db.Column(db.String(20), default='running')
    conversation_history = db.Column(db.Text)
    files_modified = db.Column(db.Text)
    cost = db.Column(db.Float, default=0.0)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    completed_at = db.Column(db.DateTime)

class UsageLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    service = db.Column(db.String(50), nullable=False)
    tokens_used = db.Column(db.Integer, default=0)
    cost = db.Column(db.Float, default=0.0)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

with app.app_context():
    db.create_all()

# ==================== AUTHENTICATION ====================

@app.route('/api/auth/register', methods=['POST'])
def register():
    data = request.json
    
    if User.query.filter_by(username=data['username']).first():
        return jsonify({'error': 'Username already exists'}), 400
    
    if User.query.filter_by(email=data['email']).first():
        return jsonify({'error': 'Email already exists'}), 400
    
    user = User(
        username=data['username'],
        email=data['email'],
        password_hash=generate_password_hash(data['password']),
        role=data.get('role', 'user')
    )
    db.session.add(user)
    db.session.commit()
    
    token = create_access_token(identity=user.id)
    return jsonify({
        'success': True,
        'token': token,
        'user': {
            'id': user.id,
            'username': user.username,
            'email': user.email,
            'role': user.role,
            'credits': user.credits
        }
    }), 201

@app.route('/api/auth/login', methods=['POST'])
def login():
    data = request.json
    user = User.query.filter_by(username=data['username']).first()
    
    if not user or not check_password_hash(user.password_hash, data['password']):
        return jsonify({'error': 'Invalid credentials'}), 401
    
    if not user.is_active:
        return jsonify({'error': 'Account is disabled'}), 403
    
    token = create_access_token(identity=user.id)
    return jsonify({
        'success': True,
        'token': token,
        'user': {
            'id': user.id,
            'username': user.username,
            'email': user.email,
            'role': user.role,
            'credits': user.credits
        }
    })

@app.route('/api/auth/me', methods=['GET'])
@jwt_required()
def get_current_user():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    return jsonify({
        'id': user.id,
        'username': user.username,
        'email': user.email,
        'role': user.role,
        'credits': user.credits,
        'created_at': user.created_at.isoformat()
    })

# ==================== API KEY MANAGEMENT ====================

@app.route('/api/keys', methods=['POST'])
@jwt_required()
def add_api_key():
    user_id = get_jwt_identity()
    data = request.json
    
    encrypted = base64.b64encode(data['apiKey'].encode()).decode()
    
    existing = APIKey.query.filter_by(user_id=user_id, service=data['service']).first()
    if existing:
        existing.encrypted_key = encrypted
    else:
        api_key = APIKey(
            user_id=user_id,
            service=data['service'],
            encrypted_key=encrypted
        )
        db.session.add(api_key)
    
    db.session.commit()
    return jsonify({'success': True, 'message': 'API key added'})

@app.route('/api/keys', methods=['GET'])
@jwt_required()
def get_api_keys():
    user_id = get_jwt_identity()
    keys = APIKey.query.filter_by(user_id=user_id).all()
    
    return jsonify({
        'keys': [{
            'id': k.id,
            'service': k.service,
            'created_at': k.created_at.isoformat()
        } for k in keys]
    })

@app.route('/api/keys/<int:key_id>', methods=['DELETE'])
@jwt_required()
def delete_api_key(key_id):
    user_id = get_jwt_identity()
    key = APIKey.query.filter_by(id=key_id, user_id=user_id).first()
    
    if not key:
        return jsonify({'error': 'Key not found'}), 404
    
    db.session.delete(key)
    db.session.commit()
    
    return jsonify({'success': True})

def get_user_api_key(user_id, service):
    api_key_record = APIKey.query.filter_by(user_id=user_id, service=service).first()
    if not api_key_record:
        return None
    return base64.b64decode(api_key_record.encrypted_key).decode()

# ==================== RATE LIMITING ====================

def check_rate_limit(user_id, limit=10, window=60):
    key = f'rate_limit:{user_id}'
    current = redis_client.get(key)
    
    if current and int(current) >= limit:
        return False
    
    pipe = redis_client.pipeline()
    pipe.incr(key)
    pipe.expire(key, window)
    pipe.execute()
    
    return True

# ==================== CLAUDE CODE AGENT INTEGRATION ====================

@app.route('/api/claude-code/projects', methods=['POST'])
@jwt_required()
def create_code_project():
    user_id = get_jwt_identity()
    data = request.json
    
    # Create project directory
    project_id = int(time.time())
    project_path = os.path.join(CODE_PROJECTS_FOLDER, f"project_{project_id}")
    os.makedirs(project_path, exist_ok=True)
    
    project = CodeProject(
        user_id=user_id,
        name=data['name'],
        description=data.get('description', ''),
        project_path=project_path
    )
    db.session.add(project)
    db.session.commit()
    
    return jsonify({
        'success': True,
        'project_id': project.id,
        'path': project_path
    })

@app.route('/api/claude-code/projects', methods=['GET'])
@jwt_required()
def get_code_projects():
    user_id = get_jwt_identity()
    projects = CodeProject.query.filter_by(user_id=user_id).all()
    
    return jsonify({
        'projects': [{
            'id': p.id,
            'name': p.name,
            'description': p.description,
            'status': p.status,
            'created_at': p.created_at.isoformat(),
            'updated_at': p.updated_at.isoformat()
        } for p in projects]
    })

@app.route('/api/claude-code/execute', methods=['POST'])
@jwt_required()
def execute_claude_code_task():
    user_id = get_jwt_identity()
    data = request.json
    
    if not check_rate_limit(user_id, limit=20, window=300):
        return jsonify({'error': 'Rate limit exceeded'}), 429
    
    api_key = get_user_api_key(user_id, 'anthropic')
    if not api_key:
        return jsonify({'error': 'Anthropic API key not configured'}), 400
    
    project_id = data['project_id']
    task = data['task']
    
    project = CodeProject.query.filter_by(id=project_id, user_id=user_id).first()
    if not project:
        return jsonify({'error': 'Project not found'}), 404
    
    # Create agent session
    session = AgentSession(
        project_id=project_id,
        task=task,
        status='running'
    )
    db.session.add(session)
    db.session.commit()
    
    # Queue the Claude Code agent task
    execute_claude_agent.delay(session.id, api_key, project.project_path, task, data.get('context', {}))
    
    return jsonify({
        'success': True,
        'session_id': session.id,
        'status': 'running'
    })

@celery.task
def execute_claude_agent(session_id, api_key, project_path, task, context):
    session = AgentSession.query.get(session_id)
    session.status = 'processing'
    db.session.commit()
    
    try:
        client = Anthropic(api_key=api_key)
        
        # Read project files
        project_context = []
        for root, dirs, files in os.walk(project_path):
            for file in files:
                if file.endswith(('.py', '.js', '.ts', '.jsx', '.tsx', '.html', '.css', '.json')):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r') as f:
                            content = f.read()
                            rel_path = os.path.relpath(file_path, project_path)
                            project_context.append(f"File: {rel_path}\n{content}\n")
                    except:
                        pass
        
        project_context_str = "\n".join(project_context[:50])  # Limit context
        
        conversation = []
        files_modified = []
        
        # Initial message to Claude
        system_prompt = f"""You are an expert coding agent working on a project at {project_path}.
        
Current project structure:
{project_context_str}

You can:
1. Create, read, update, and delete files
2. Run terminal commands
3. Write tests
4. Fix bugs
5. Add features
6. Refactor code

When you want to modify a file, respond with JSON in this format:
{{
    "action": "write_file",
    "path": "relative/path/to/file.py",
    "content": "file content here"
}}

When you want to run a command:
{{
    "action": "run_command",
    "command": "npm install lodash"
}}

When you're done:
{{
    "action": "complete",
    "summary": "What you accomplished"
}}
"""
        
        user_message = f"Task: {task}\n\nAdditional context: {json.dumps(context)}"
        
        max_iterations = 10
        iteration = 0
        
        while iteration < max_iterations:
            response = client.messages.create(
                model="claude-sonnet-4-5-20250929",
                max_tokens=4096,
                system=system_prompt,
                messages=[
                    {"role": "user", "content": user_message}
                ] + conversation
            )
            
            assistant_message = response.content[0].text
            conversation.append({"role": "assistant", "content": assistant_message})
            
            # Parse agent action
            try:
                # Try to extract JSON from response
                json_start = assistant_message.find('{')
                json_end = assistant_message.rfind('}') + 1
                
                if json_start != -1 and json_end > json_start:
                    action_data = json.loads(assistant_message[json_start:json_end])
                    
                    if action_data.get('action') == 'write_file':
                        file_path = os.path.join(project_path, action_data['path'])
                        os.makedirs(os.path.dirname(file_path), exist_ok=True)
                        with open(file_path, 'w') as f:
                            f.write(action_data['content'])
                        files_modified.append(action_data['path'])
                        
                        user_message = f"File {action_data['path']} written successfully. Continue with next step."
                        conversation.append({"role": "user", "content": user_message})
                        
                    elif action_data.get('action') == 'run_command':
                        try:
                            result = subprocess.run(
                                action_data['command'],
                                shell=True,
                                cwd=project_path,
                                capture_output=True,
                                text=True,
                                timeout=30
                            )
                            output = f"Command output:\nSTDOUT: {result.stdout}\nSTDERR: {result.stderr}\nReturn code: {result.returncode}"
                            user_message = output
                            conversation.append({"role": "user", "content": user_message})
                        except Exception as e:
                            user_message = f"Command failed: {str(e)}"
                            conversation.append({"role": "user", "content": user_message})
                    
                    elif action_data.get('action') == 'complete':
                        session.status = 'completed'
                        session.conversation_history = json.dumps(conversation)
                        session.files_modified = json.dumps(files_modified)
                        session.completed_at = datetime.utcnow()
                        session.cost = len(json.dumps(conversation)) * 0.000003  # Rough estimate
                        db.session.commit()
                        break
                else:
                    # No action found, agent is thinking/explaining
                    if iteration < max_iterations - 1:
                        user_message = "Please proceed with the next step or mark as complete if done."
                        conversation.append({"role": "user", "content": user_message})
                    
            except json.JSONDecodeError:
                # Agent is explaining, continue conversation
                if iteration < max_iterations - 1:
                    user_message = "Please proceed with the implementation."
                    conversation.append({"role": "user", "content": user_message})
            
            iteration += 1
        
        if iteration >= max_iterations:
            session.status = 'timeout'
            session.conversation_history = json.dumps(conversation)
            session.files_modified = json.dumps(files_modified)
            session.completed_at = datetime.utcnow()
            db.session.commit()
            
    except Exception as e:
        session.status = 'failed'
        session.conversation_history = json.dumps([{"error": str(e)}])
        session.completed_at = datetime.utcnow()
        db.session.commit()

@app.route('/api/claude-code/sessions/<int:session_id>', methods=['GET'])
@jwt_required()
def get_agent_session(session_id):
    user_id = get_jwt_identity()
    session = AgentSession.query.get(session_id)
    
    if not session:
        return jsonify({'error': 'Session not found'}), 404
    
    project = CodeProject.query.filter_by(id=session.project_id, user_id=user_id).first()
    if not project:
        return jsonify({'error': 'Unauthorized'}), 403
    
    return jsonify({
        'id': session.id,
        'task': session.task,
        'status': session.status,
        'conversation': json.loads(session.conversation_history) if session.conversation_history else [],
        'files_modified': json.loads(session.files_modified) if session.files_modified else [],
        'cost': session.cost,
        'created_at': session.created_at.isoformat(),
        'completed_at': session.completed_at.isoformat() if session.completed_at else None
    })

# ==================== CELERY TASKS FOR AI GENERATION ====================

@celery.task
def process_image_generation(generation_id, user_api_key, prompt, service, params):
    generation = Generation.query.get(generation_id)
    generation.status = 'processing'
    db.session.commit()
    
    try:
        if service == 'dalle3':
            client = OpenAI(api_key=user_api_key)
            response = client.images.generate(
                model="dall-e-3",
                prompt=prompt,
                size=params.get('size', "1024x1024"),
                quality=params.get('quality', "standard"),
                n=1
            )
            
            image_url = response.data[0].url
            image_data = requests.get(image_url).content
            
            filename = f"{generation_id}_{int(time.time())}.png"
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(image_data)
            
            generation.result_path = filepath
            generation.result_url = image_url
            generation.cost = 0.04
            
        elif service == 'dalle2':
            client = OpenAI(api_key=user_api_key)
            response = client.images.generate(
                model="dall-e-2",
                prompt=prompt,
                size=params.get('size', "1024x1024"),
                n=1
            )
            
            image_url = response.data[0].url
            image_data = requests.get(image_url).content
            
            filename = f"{generation_id}_{int(time.time())}.png"
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(image_data)
            
            generation.result_path = filepath
            generation.result_url = image_url
            generation.cost = 0.02
            
        elif service == 'stable-diffusion':
            output = replicate.run(
                "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
                input={
                    "prompt": prompt,
                    "width": params.get('width', 1024),
                    "height": params.get('height', 1024),
                    "num_outputs": 1,
                },
                api_token=user_api_key
            )
            
            image_url = output[0]
            image_data = requests.get(image_url).content
            
            filename = f"{generation_id}_{int(time.time())}.png"
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(image_data)
            
            generation.result_path = filepath
            generation.result_url = image_url
            generation.cost = 0.01
            
        elif service == 'flux':
            output = replicate.run(
                "black-forest-labs/flux-1.1-pro",
                input={
                    "prompt": prompt,
                    "aspect_ratio": params.get('aspect_ratio', "1:1"),
                    "output_format": "png",
                    "output_quality": 100,
                },
                api_token=user_api_key
            )
            
            image_url = output
            image_data = requests.get(image_url).content
            
            filename = f"{generation_id}_{int(time.time())}.png"
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(image_data)
            
            generation.result_path = filepath
            generation.result_url = image_url
            generation.cost = 0.04
            
        elif service == 'imagen3':
            genai.configure(api_key=user_api_key)
            response = genai.generate_images(
                model='imagen-3.0-generate-001',
                prompt=prompt,
                number_of_images=1,
                aspect_ratio=params.get('aspect_ratio', '1:1'),
                safety_filter_level='block_some'
            )
            
            image = response.images[0]
            filename = f"{generation_id}_{int(time.time())}.png"
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            image._pil_image.save(filepath)
            
            generation.result_path = filepath
            generation.cost = 0.04
            
        generation.status = 'completed'
        generation.completed_at = datetime.utcnow()
        db.session.commit()
        
    except Exception as e:
        generation.status = 'failed'
        generation.error_message = str(e)
        db.session.commit()

@celery.task
def process_video_generation(generation_id, user_api_key, prompt, service, params):
    generation = Generation.query.get(generation_id)
    generation.status = 'processing'
    db.session.commit()
    
    try:
        if service == 'runway':
            output = replicate.run(
                "runwayml/gen-4",
                input={
                    "prompt": prompt,
                    "duration": params.get('duration', 5),
                },
                api_token=user_api_key
            )
            
            video_url = output
            video_data = requests.get(video_url).content
            
            filename = f"{generation_id}_{int(time.time())}.mp4"
            filepath = os.path.join(VIDEO_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(video_data)
            
            generation.result_path = filepath
            generation.result_url = video_url
            generation.cost = 0.50
            
        elif service == 'veo3':
            genai.configure(api_key=user_api_key)
            response = genai.generate_video(
                model='veo-3.0',
                prompt=prompt,
                duration_seconds=params.get('duration', 5)
            )
            
            filename = f"{generation_id}_{int(time.time())}.mp4"
            filepath = os.path.join(VIDEO_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(response.video_data)
            
            generation.result_path = filepath
            generation.cost = 0.60
            
        elif service == 'stability-video':
            output = replicate.run(
                "stability-ai/stable-video-diffusion:3f0457e4619daac51203dedb472816fd4af51f3149fa7a9e0b5ffcf1b8172438",
                input={
                    "input_image": params.get('input_image'),
                    "cond_aug": 0.02,
                    "decoding_t": 14,
                    "video_length": "14_frames_with_svd",
                    "sizing_strategy": "maintain_aspect_ratio",
                    "motion_bucket_id": 127,
                    "frames_per_second": 6
                },
                api_token=user_api_key
            )
            
            video_url = output
            video_data = requests.get(video_url).content
            
            filename = f"{generation_id}_{int(time.time())}.mp4"
            filepath = os.path.join(VIDEO_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(video_data)
            
            generation.result_path = filepath
            generation.result_url = video_url
            generation.cost = 0.30
            
        generation.status = 'completed'
        generation.completed_at = datetime.utcnow()
        db.session.commit()
        
    except Exception as e:
        generation.status = 'failed'
        generation.error_message = str(e)
        db.session.commit()

@celery.task
def process_audio_generation(generation_id, user_api_key, prompt, service, params):
    generation = Generation.query.get(generation_id)
    generation.status = 'processing'
    db.session.commit()
    
    try:
        if service == 'elevenlabs':
            client = ElevenLabs(api_key=user_api_key)
            
            audio = client.generate(
                text=prompt,
                voice=Voice(
                    voice_id=params.get('voice_id', '21m00Tcm4TlvDq8ikWAM'),
                    settings=VoiceSettings(
                        stability=params.get('stability', 0.5),
                        similarity_boost=params.get('similarity_boost', 0.75)
                    )
                ),
                model=params.get('model', 'eleven_monolingual_v1')
            )
            
            filename = f"{generation_id}_{int(time.time())}.mp3"
            filepath = os.path.join(AUDIO_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                for chunk in audio:
                    f.write(chunk)
            
            generation.result_path = filepath
            generation.cost = 0.30
            
        elif service == 'openai-tts':
            client = OpenAI(api_key=user_api_key)
            response = client.audio.speech.create(
                model=params.get('model', 'tts-1'),
                voice=params.get('voice', 'alloy'),
                input=prompt
            )
            
            filename = f"{generation_id}_{int(time.time())}.mp3"
            filepath = os.path.join(AUDIO_FOLDER, filename)
            
            response.stream_to_file(filepath)
            
            generation.result_path = filepath
            generation.cost = 0.015
            
        elif service == 'google-tts':
            genai.configure(api_key=user_api_key)
            response = genai.text_to_speech(
                text=prompt,
                voice_name=params.get('voice', 'en-US-Neural2-A'),
                language_code=params.get('language', 'en-US')
            )
            
            filename = f"{generation_id}_{int(time.time())}.mp3"
            filepath = os.path.join(AUDIO_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(response.audio_content)
            
            generation.result_path = filepath
            generation.cost = 0.016
            
        elif service == 'musicgen':
            output = replicate.run(
                "meta/musicgen:671ac645ce5e552cc63a54a2bbff63fcf798043055d2dac5fc9e36a837eedcfb",
                input={
                    "prompt": prompt,
                    "model_version": params.get('model', 'stereo-large'),
                    "duration": params.get('duration', 8)
                },
                api_token=user_api_key
            )
            
            audio_url = output
            audio_data = requests.get(audio_url).content
            
            filename = f"{generation_id}_{int(time.time())}.wav"
            filepath = os.path.join(AUDIO_FOLDER, filename)
            
            with open(filepath, 'wb') as f:
                f.write(audio_data)
            
            generation.result_path = filepath
            generation.result_url = audio_url
            generation.cost = 0.10
            
        generation.status = 'completed'
        generation.completed_at = datetime.utcnow()
        db.session.commit()
        
    except Exception as e:
        generation.status = 'failed'
        generation.error_message = str(e)
        db.session.commit()

@celery.task
def process_text_generation(generation_id, user_api_key, prompt, service, params):
    generation = Generation.query.get(generation_id)
    generation.status = 'processing'
    db.session.commit()
    
    try:
        if service == 'claude':
            client = Anthropic(api_key=user_api_key)
            response = client.messages.create(
                model=params.get('model', 'claude-sonnet-4-5-20250929'),
                max_tokens=params.get('max_tokens', 4096),
                messages=[{"role": "user", "content": prompt}]
            )
            
            result_text = response.content[0].text
            generation.result_data = result_text
            generation.cost = (response.usage.input_tokens * 0.000003) + (response.usage.output_tokens * 0.000015)
            
        elif service == 'gpt4':
            client = OpenAI(api_key=user_api_key)
            response = client.chat.completions.create(
                model=params.get('model', 'gpt-4-turbo-preview'),
                messages=[{"role": "user", "content": prompt}],
                max_tokens=params.get('max_tokens', 4096)
            )
            
            result_text = response.choices[0].message.content
            generation.result_data = result_text
            generation.cost = (response.usage.prompt_tokens * 0.00001) + (response.usage.completion_tokens * 0.00003)
            
        elif service == 'gemini':
            genai.configure(api_key=user_api_key)
            model = genai.GenerativeModel(params.get('model', 'gemini-1.5-pro'))
            response = model.generate_content(prompt)
            
            result_text = response.text
            generation.result_data = result_text
            generation.cost = 0.02
            
        elif service == 'llama':
            output = replicate.run(
                "meta/llama-3-70b-instruct",
                input={
                    "prompt": prompt,
                    "max_tokens": params.get('max_tokens', 4096),
                    "temperature": params.get('temperature', 0.7)
                },
                api_token=user_api_key
            )
            
            result_text = "".join(output)
            generation.result_data = result_text
            generation.cost = 0.01
            
        generation.status = 'completed'
        generation.completed_at = datetime.utcnow()
        db.session.commit()
        
    except Exception as e:
        generation.status = 'failed'
        generation.error_message = str(e)
        db.session.commit()

@celery.task
def process_audio_transcription(generation_id, user_api_key, audio_file_path, service):
    generation = Generation.query.get(generation_id)
    generation.status = 'processing'
    db.session.commit()
    
    try:
        if service == 'whisper':
            client = OpenAI(api_key=user_api_key)
            with open(audio_file_path, 'rb') as audio_file:
                transcript = client.audio.transcriptions.create(
                    model="whisper-1",
                    file=audio_file
                )
            
            generation.result_data = transcript.text
            generation.cost = 0.006
            
        generation.status = 'completed'
        generation.completed_at = datetime.utcnow()
        db.session.commit()
        
    except Exception as e:
        generation.status = 'failed'
        generation.error_message = str(e)
        db.session.commit()

# ==================== GENERATION ENDPOINTS ====================

@app.route('/api/generate/image', methods=['POST'])
@jwt_required()
def generate_image():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if not check_rate_limit(user_id, limit=20, window=60):
        return jsonify({'error': 'Rate limit exceeded'}), 429
    
    if user.credits < 1:
        return jsonify({'error': 'Insufficient credits'}), 402
    
    data = request.json
    service = data['service']
    
    api_key = get_user_api_key(user_id, service if service != 'stable-diffusion' and service != 'flux' else 'replicate')
    if not api_key:
        return jsonify({'error': f'{service} API key not configured'}), 400
    
    generation = Generation(
        user_id=user_id,
        service=service,
        type='image',
        prompt=data['prompt'],
        status='pending',
        metadata=json.dumps(data.get('params', {}))
    )
    db.session.add(generation)
    db.session.commit()
    
    process_image_generation.delay(
        generation.id,
        api_key,
        data['prompt'],
        service,
        data.get('params', {})
    )
    
    user.credits -= 1
    db.session.commit()
    
    return jsonify({
        'success': True,
        'generation_id': generation.id,
        'status': 'pending'
    })

@app.route('/api/generate/video', methods=['POST'])
@jwt_required()
def generate_video():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if not check_rate_limit(user_id, limit=5, window=300):
        return jsonify({'error': 'Rate limit exceeded'}), 429
    
    if user.credits < 5:
        return jsonify({'error': 'Insufficient credits'}), 402
    
    data = request.json
    service = data['service']
    
    api_key_service = 'replicate' if service in ['runway', 'stability-video'] else service
    api_key = get_user_api_key(user_id, api_key_service)
    if not api_key:
        return jsonify({'error': f'{service} API key not configured'}), 400
    
    generation = Generation(
        user_id=user_id,
        service=service,
        type='video',
        prompt=data['prompt'],
        status='pending',
        metadata=json.dumps(data.get('params', {}))
    )
    db.session.add(generation)
    db.session.commit()
    
    process_video_generation.delay(
        generation.id,
        api_key,
        data['prompt'],
        service,
        data.get('params', {})
    )
    
    user.credits -= 5
    db.session.commit()
    
    return jsonify({
        'success': True,
        'generation_id': generation.id,
        'status': 'pending'
    })

@app.route('/api/generate/audio', methods=['POST'])
@jwt_required()
def generate_audio():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if not check_rate_limit(user_id, limit=20, window=60):
        return jsonify({'error': 'Rate limit exceeded'}), 429
    
    if user.credits < 1:
        return jsonify({'error': 'Insufficient credits'}), 402
    
    data = request.json
    service = data['service']
    
    api_key_service = 'replicate' if service == 'musicgen' else service
    api_key = get_user_api_key(user_id, api_key_service)
    if not api_key:
        return jsonify({'error': f'{service} API key not configured'}), 400
    
    generation = Generation(
        user_id=user_id,
        service=service,
        type='audio',
        prompt=data['prompt'],
        status='pending',
        metadata=json.dumps(data.get('params', {}))
    )
    db.session.add(generation)
    db.session.commit()
    
    process_audio_generation.delay(
        generation.id,
        api_key,
        data['prompt'],
        service,
        data.get('params', {})
    )
    
    user.credits -= 1
    db.session.commit()
    
    return jsonify({
        'success': True,
        'generation_id': generation.id,
        'status': 'pending'
    })

@app.route('/api/generate/text', methods=['POST'])
@jwt_required()
def generate_text():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if not check_rate_limit(user_id, limit=30, window=60):
        return jsonify({'error': 'Rate limit exceeded'}), 429
    
    if user.credits < 1:
        return jsonify({'error': 'Insufficient credits'}), 402
    
    data = request.json
    service = data['service']
    
    api_key_service = 'replicate' if service == 'llama' else service
    api_key = get_user_api_key(user_id, api_key_service)
    if not api_key:
        return jsonify({'error': f'{service} API key not configured'}), 400
    
    generation = Generation(
        user_id=user_id,
        service=service,
        type='text',
        prompt=data['prompt'],
        status='pending',
        metadata=json.dumps(data.get('params', {}))
    )
    db.session.add(generation)
    db.session.commit()
    
    process_text_generation.delay(
        generation.id,
        api_key,
        data['prompt'],
        service,
        data.get('params', {})
    )
    
    user.credits -= 1
    db.session.commit()
    
    return jsonify({
        'success': True,
        'generation_id': generation.id,
        'status': 'pending'
    })

@app.route('/api/transcribe', methods=['POST'])
@jwt_required()
def transcribe_audio():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if not check_rate_limit(user_id, limit=10, window=60):
        return jsonify({'error': 'Rate limit exceeded'}), 429
    
    if user.credits < 1:
        return jsonify({'error': 'Insufficient credits'}), 402
    
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    filename = f"{user_id}_{int(time.time())}_{file.filename}"
    filepath = os.path.join(AUDIO_FOLDER, filename)
    file.save(filepath)
    
    api_key = get_user_api_key(user_id, 'openai')
    if not api_key:
        return jsonify({'error': 'OpenAI API key not configured'}), 400
    
    generation = Generation(
        user_id=user_id,
        service='whisper',
        type='transcription',
        prompt=f"Transcribe: {filename}",
        status='pending'
    )
    db.session.add(generation)
    db.session.commit()
    
    process_audio_transcription.delay(generation.id, api_key, filepath, 'whisper')
    
    user.credits -= 1
    db.session.commit()
    
    return jsonify({
        'success': True,
        'generation_id': generation.id,
        'status': 'pending'
    })

@app.route('/api/generations/<int:generation_id>', methods=['GET'])
@jwt_required()
def get_generation(generation_id):
    user_id = get_jwt_identity()
    generation = Generation.query.filter_by(id=generation_id, user_id=user_id).first()
    
    if not generation:
        return jsonify({'error': 'Generation not found'}), 404
    
    result = {
        'id': generation.id,
        'service': generation.service,
        'type': generation.type,
        'prompt': generation.prompt,
        'status': generation.status,
        'cost': generation.cost,
        'created_at': generation.created_at.isoformat(),
        'completed_at': generation.completed_at.isoformat() if generation.completed_at else None
    }
    
    if generation.status == 'completed':
        if generation.result_data:
            result['data'] = generation.result_data
        if generation.result_path and os.path.exists(generation.result_path):
            with open(generation.result_path, 'rb') as f:
                result['file_data'] = base64.b64encode(f.read()).decode()
        if generation.result_url:
            result['url'] = generation.result_url
    
    if generation.status == 'failed':
        result['error'] = generation.error_message
    
    return jsonify(result)

@app.route('/api/generations', methods=['GET'])
@jwt_required()
def get_all_generations():
    user_id = get_jwt_identity()
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 50, type=int)
    
    generations = Generation.query.filter_by(user_id=user_id).order_by(
        Generation.created_at.desc()
    ).paginate(page=page, per_page=per_page, error_out=False)
    
    return jsonify({
        'generations': [{
            'id': g.id,
            'service': g.service,
            'type': g.type,
            'prompt': g.prompt[:100],
            'status': g.status,
            'cost': g.cost,
            'created_at': g.created_at.isoformat()
        } for g in generations.items],
        'total': generations.total,
        'pages': generations.pages,
        'current_page': page
    })

@app.route('/api/generations/<int:generation_id>/download', methods=['GET'])
@jwt_required()
def download_generation(generation_id):
    user_id = get_jwt_identity()
    generation = Generation.query.filter_by(id=generation_id, user_id=user_id).first()
    
    if not generation:
        return jsonify({'error': 'Generation not found'}), 404
    
    if not generation.result_path or not os.path.exists(generation.result_path):
        return jsonify({'error': 'File not found'}), 404
    
    return send_file(generation.result_path, as_attachment=True)

# ==================== ADMIN ENDPOINTS ====================

@app.route('/api/admin/users', methods=['GET'])
@jwt_required()
def admin_get_users():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    users = User.query.all()
    return jsonify({
        'users': [{
            'id': u.id,
            'username': u.username,
            'email': u.email,
            'role': u.role,
            'credits': u.credits,
            'is_active': u.is_active,
            'created_at': u.created_at.isoformat()
        } for u in users]
    })

@app.route('/api/admin/users/<int:target_user_id>/credits', methods=['POST'])
@jwt_required()
def admin_add_credits(target_user_id):
    admin_id = get_jwt_identity()
    admin = User.query.get(admin_id)
    
    if admin.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    user = User.query.get(target_user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    data = request.json
    user.credits += data['credits']
    db.session.commit()
    
    return jsonify({'success': True, 'new_credits': user.credits})

@app.route('/api/admin/users/<int:target_user_id>/status', methods=['POST'])
@jwt_required()
def admin_toggle_user_status(target_user_id):
    admin_id = get_jwt_identity()
    admin = User.query.get(admin_id)
    
    if admin.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    user = User.query.get(target_user_id)
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    user.is_active = not user.is_active
    db.session.commit()
    
    return jsonify({'success': True, 'is_active': user.is_active})

@app.route('/api/admin/stats', methods=['GET'])
@jwt_required()
def admin_stats():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    total_users = User.query.count()
    total_generations = Generation.query.count()
    total_cost = db.session.query(db.func.sum(Generation.cost)).scalar() or 0
    total_credits_distributed = db.session.query(db.func.sum(User.credits)).scalar() or 0
    
    # Recent activity
    today = datetime.utcnow().date()
    today_generations = Generation.query.filter(
        db.func.date(Generation.created_at) == today
    ).count()
    
    return jsonify({
        'total_users': total_users,
        'active_users': User.query.filter_by(is_active=True).count(),
        'total_generations': total_generations,
        'today_generations': today_generations,
        'total_cost': round(total_cost, 2),
        'total_credits': total_credits_distributed,
        'services': {
            'image': Generation.query.filter_by(type='image').count(),
            'video': Generation.query.filter_by(type='video').count(),
            'audio': Generation.query.filter_by(type='audio').count(),
            'text': Generation.query.filter_by(type='text').count(),
            'code': AgentSession.query.count()
        }
    })

@app.route('/api/admin/generations', methods=['GET'])
@jwt_required()
def admin_get_all_generations():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 100, type=int)
    
    generations = Generation.query.order_by(
        Generation.created_at.desc()
    ).paginate(page=page, per_page=per_page, error_out=False)
    
    return jsonify({
        'generations': [{
            'id': g.id,
            'user_id': g.user_id,
            'username': User.query.get(g.user_id).username,
            'service': g.service,
            'type': g.type,
            'prompt': g.prompt[:100],
            'status': g.status,
            'cost': g.cost,
            'created_at': g.created_at.isoformat()
        } for g in generations.items],
        'total': generations.total,
        'pages': generations.pages
    })

# ==================== ANALYTICS ====================

@app.route('/api/analytics/usage', methods=['GET'])
@jwt_required()
def get_usage_analytics():
    user_id = get_jwt_identity()
    
    thirty_days_ago = datetime.utcnow() - timedelta(days=30)
    generations = Generation.query.filter(
        Generation.user_id == user_id,
        Generation.created_at >= thirty_days_ago
    ).all()
    
    service_usage = {}
    for gen in generations:
        if gen.service not in service_usage:
            service_usage[gen.service] = {'count': 0, 'cost': 0}
        service_usage[gen.service]['count'] += 1
        service_usage[gen.service]['cost'] += gen.cost
    
    return jsonify({
        'usage_by_service': service_usage,
        'total_generations': len(generations),
        'total_cost': sum(g.cost for g in generations)
    })

@app.route('/api/analytics/history', methods=['GET'])
@jwt_required()
def get_usage_history():
    user_id = get_jwt_identity()
    days = request.args.get('days', 30, type=int)
    
    start_date = datetime.utcnow() - timedelta(days=days)
    generations = Generation.query.filter(
        Generation.user_id == user_id,
        Generation.created_at >= start_date
    ).order_by(Generation.created_at).all()
    
    daily_stats = {}
    for gen in generations:
        date_key = gen.created_at.date().isoformat()
        if date_key not in daily_stats:
            daily_stats[date_key] = {'count': 0, 'cost': 0}
        daily_stats[date_key]['count'] += 1
        daily_stats[date_key]['cost'] += gen.cost
    
    return jsonify({'daily_stats': daily_stats})

# ==================== PROJECT FILE MANAGEMENT ====================

@app.route('/api/projects/<int:project_id>/files', methods=['GET'])
@jwt_required()
def list_project_files(project_id):
    user_id = get_jwt_identity()
    project = CodeProject.query.filter_by(id=project_id, user_id=user_id).first()
    
    if not project:
        return jsonify({'error': 'Project not found'}), 404
    
    files = []
    for root, dirs, filenames in os.walk(project.project_path):
        for filename in filenames:
            filepath = os.path.join(root, filename)
            rel_path = os.path.relpath(filepath, project.project_path)
            files.append({
                'path': rel_path,
                'size': os.path.getsize(filepath),
                'modified': datetime.fromtimestamp(os.path.getmtime(filepath)).isoformat()
            })
    
    return jsonify({'files': files})

@app.route('/api/projects/<int:project_id>/files/<path:filepath>', methods=['GET'])
@jwt_required()
def get_project_file(project_id, filepath):
    user_id = get_jwt_identity()
    project = CodeProject.query.filter_by(id=project_id, user_id=user_id).first()
    
    if not project:
        return jsonify({'error': 'Project not found'}), 404
    
    full_path = os.path.join(project.project_path, filepath)
    
    if not os.path.exists(full_path):
        return jsonify({'error': 'File not found'}), 404
    
    try:
        with open(full_path, 'r') as f:
            content = f.read()
        return jsonify({'content': content})
    except:
        return send_file(full_path, as_attachment=True)

@app.route('/api/projects/<int:project_id>/files', methods=['POST'])
@jwt_required()
def upload_project_file(project_id):
    user_id = get_jwt_identity()
    project = CodeProject.query.filter_by(id=project_id, user_id=user_id).first()
    
    if not project:
        return jsonify({'error': 'Project not found'}), 404
    
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    
    file = request.files['file']
    filepath = request.form.get('path', file.filename)
    
    full_path = os.path.join(project.project_path, filepath)
    os.makedirs(os.path.dirname(full_path), exist_ok=True)
    
    file.save(full_path)
    
    return jsonify({'success': True, 'path': filepath})

@app.route('/api/projects/<int:project_id>/files/<path:filepath>', methods=['DELETE'])
@jwt_required()
def delete_project_file(project_id, filepath):
    user_id = get_jwt_identity()
    project = CodeProject.query.filter_by(id=project_id, user_id=user_id).first()
    
    if not project:
        return jsonify({'error': 'Project not found'}), 404
    
    full_path = os.path.join(project.project_path, filepath)
    
    if not os.path.exists(full_path):
        return jsonify({'error': 'File not found'}), 404
    
    os.remove(full_path)
    
    return jsonify({'success': True})

@app.route('/api/projects/<int:project_id>', methods=['DELETE'])
@jwt_required()
def delete_project(project_id):
    user_id = get_jwt_identity()
    project = CodeProject.query.filter_by(id=project_id, user_id=user_id).first()
    
    if not project:
        return jsonify({'error': 'Project not found'}), 404
    
    # Delete project directory
    if os.path.exists(project.project_path):
        shutil.rmtree(project.project_path)
    
    # Delete agent sessions
    AgentSession.query.filter_by(project_id=project_id).delete()
    
    # Delete project
    db.session.delete(project)
    db.session.commit()
    
    return jsonify({'success': True})

# ==================== HEALTH & INFO ====================

@app.route('/health', methods=['GET'])
def health():
    try:
        redis_status = 'connected' if redis_client.ping() else 'disconnected'
    except:
        redis_status = 'disconnected'
    
    return jsonify({
        'status': 'online',
        'database': 'connected',
        'redis': redis_status,
        'celery': 'running'
    })

@app.route('/api/info', methods=['GET'])
def info():
    return jsonify({
        'version': '2.0.0',
        'name': 'Complete AI Hub',
        'services': {
            'image': ['DALL-E 3', 'DALL-E 2', 'Stable Diffusion SDXL', 'Flux 1.1 Pro', 'Imagen 3'],
            'video': ['Runway Gen-4', 'Veo 3', 'Stability Video Diffusion'],
            'code': ['Claude Code Agent', 'Claude Sonnet 4.5', 'GPT-4', 'Gemini Pro', 'Llama 3'],
            'audio': ['ElevenLabs', 'OpenAI TTS', 'Google TTS', 'MusicGen'],
            'text': ['Claude Sonnet 4.5', 'GPT-4 Turbo', 'Gemini 1.5 Pro', 'Llama 3 70B'],
            'transcription': ['Whisper']
        },
        'features': [
            'User authentication & authorization',
            'Multi-service API key management',
            'Claude Code Agent integration',
            'Rate limiting & usage tracking',
            'Async task processing with Celery',
            'File storage & management',
            'Project-based code generation',
            'Admin dashboard',
            'Analytics & reporting',
            'Credit system',
            'Generation history'
        ],
        'endpoints': {
            'auth': ['/api/auth/register', '/api/auth/login', '/api/auth/me'],
            'keys': ['/api/keys'],
            'generate': ['/api/generate/image', '/api/generate/video', '/api/generate/audio', '/api/generate/text', '/api/transcribe'],
            'claude_code': ['/api/claude-code/projects', '/api/claude-code/execute', '/api/claude-code/sessions'],
            'admin': ['/api/admin/users', '/api/admin/stats', '/api/admin/generations'],
            'analytics': ['/api/analytics/usage', '/api/analytics/history']
        }
    })

@app.route('/api/services', methods=['GET'])
def get_services():
    """Get detailed information about all available services"""
    return jsonify({
        'image_generation': {
            'dalle3': {
                'name': 'DALL-E 3',
                'provider': 'OpenAI',
                'cost_per_generation': 0.04,
                'api_key_service': 'openai',
                'params': {
                    'size': ['1024x1024', '1024x1792', '1792x1024'],
                    'quality': ['standard', 'hd']
                }
            },
            'dalle2': {
                'name': 'DALL-E 2',
                'provider': 'OpenAI',
                'cost_per_generation': 0.02,
                'api_key_service': 'openai',
                'params': {
                    'size': ['256x256', '512x512', '1024x1024']
                }
            },
            'stable-diffusion': {
                'name': 'Stable Diffusion XL',
                'provider': 'Stability AI',
                'cost_per_generation': 0.01,
                'api_key_service': 'replicate',
                'params': {
                    'width': [512, 768, 1024],
                    'height': [512, 768, 1024]
                }
            },
            'flux': {
                'name': 'Flux 1.1 Pro',
                'provider': 'Black Forest Labs',
                'cost_per_generation': 0.04,
                'api_key_service': 'replicate',
                'params': {
                    'aspect_ratio': ['1:1', '16:9', '9:16', '4:3', '3:4']
                }
            },
            'imagen3': {
                'name': 'Imagen 3',
                'provider': 'Google',
                'cost_per_generation': 0.04,
                'api_key_service': 'google',
                'params': {
                    'aspect_ratio': ['1:1', '16:9', '9:16', '4:3', '3:4']
                }
            }
        },
        'video_generation': {
            'runway': {
                'name': 'Runway Gen-4',
                'provider': 'Runway',
                'cost_per_generation': 0.50,
                'api_key_service': 'replicate',
                'params': {
                    'duration': [5, 10]
                }
            },
            'veo3': {
                'name': 'Veo 3',
                'provider': 'Google',
                'cost_per_generation': 0.60,
                'api_key_service': 'google',
                'params': {
                    'duration': [5, 10, 15]
                }
            },
            'stability-video': {
                'name': 'Stable Video Diffusion',
                'provider': 'Stability AI',
                'cost_per_generation': 0.30,
                'api_key_service': 'replicate',
                'params': {
                    'requires_input_image': True
                }
            }
        },
        'audio_generation': {
            'elevenlabs': {
                'name': 'ElevenLabs',
                'provider': 'ElevenLabs',
                'cost_per_generation': 0.30,
                'api_key_service': 'elevenlabs',
                'params': {
                    'voice_id': 'various',
                    'model': ['eleven_monolingual_v1', 'eleven_multilingual_v2']
                }
            },
            'openai-tts': {
                'name': 'OpenAI TTS',
                'provider': 'OpenAI',
                'cost_per_generation': 0.015,
                'api_key_service': 'openai',
                'params': {
                    'voice': ['alloy', 'echo', 'fable', 'onyx', 'nova', 'shimmer'],
                    'model': ['tts-1', 'tts-1-hd']
                }
            },
            'google-tts': {
                'name': 'Google Text-to-Speech',
                'provider': 'Google',
                'cost_per_generation': 0.016,
                'api_key_service': 'google',
                'params': {
                    'language': ['en-US', 'es-ES', 'fr-FR', 'de-DE', 'ja-JP']
                }
            },
            'musicgen': {
                'name': 'MusicGen',
                'provider': 'Meta',
                'cost_per_generation': 0.10,
                'api_key_service': 'replicate',
                'params': {
                    'model': ['stereo-large', 'melody-large'],
                    'duration': [5, 8, 10, 15, 20, 30]
                }
            }
        },
        'text_generation': {
            'claude': {
                'name': 'Claude Sonnet 4.5',
                'provider': 'Anthropic',
                'cost_per_1k_tokens': {'input': 0.003, 'output': 0.015},
                'api_key_service': 'anthropic',
                'params': {
                    'model': ['claude-sonnet-4-5-20250929', 'claude-opus-4-1-20250514'],
                    'max_tokens': [1024, 2048, 4096, 8192]
                }
            },
            'gpt4': {
                'name': 'GPT-4 Turbo',
                'provider': 'OpenAI',
                'cost_per_1k_tokens': {'input': 0.01, 'output': 0.03},
                'api_key_service': 'openai',
                'params': {
                    'model': ['gpt-4-turbo-preview', 'gpt-4'],
                    'max_tokens': [1024, 2048, 4096, 8192]
                }
            },
            'gemini': {
                'name': 'Gemini 1.5 Pro',
                'provider': 'Google',
                'cost_per_generation': 0.02,
                'api_key_service': 'google',
                'params': {
                    'model': ['gemini-1.5-pro', 'gemini-1.5-flash']
                }
            },
            'llama': {
                'name': 'Llama 3 70B',
                'provider': 'Meta',
                'cost_per_generation': 0.01,
                'api_key_service': 'replicate',
                'params': {
                    'temperature': [0.1, 0.5, 0.7, 0.9]
                }
            }
        },
        'code_agent': {
            'claude-code': {
                'name': 'Claude Code Agent',
                'provider': 'Anthropic',
                'description': 'AI coding agent that can build features, debug, and navigate codebases',
                'api_key_service': 'anthropic',
                'capabilities': [
                    'Build features from descriptions',
                    'Debug and fix issues',
                    'Navigate and understand codebases',
                    'Create, read, update, delete files',
                    'Run terminal commands',
                    'Write and run tests',
                    'Refactor code'
                ]
            }
        },
        'transcription': {
            'whisper': {
                'name': 'Whisper',
                'provider': 'OpenAI',
                'cost_per_minute': 0.006,
                'api_key_service': 'openai',
                'supported_formats': ['mp3', 'mp4', 'mpeg', 'mpga', 'm4a', 'wav', 'webm']
            }
        }
    })

# ==================== WEBHOOK ENDPOINTS ====================

@app.route('/api/webhooks/replicate', methods=['POST'])
def replicate_webhook():
    """Handle callbacks from Replicate for long-running tasks"""
    data = request.json
    
    # Find generation by metadata
    generation_id = data.get('metadata', {}).get('generation_id')
    if not generation_id:
        return jsonify({'error': 'No generation_id in metadata'}), 400
    
    generation = Generation.query.get(generation_id)
    if not generation:
        return jsonify({'error': 'Generation not found'}), 404
    
    if data['status'] == 'succeeded':
        generation.status = 'completed'
        generation.result_url = data['output']
        generation.completed_at = datetime.utcnow()
    elif data['status'] == 'failed':
        generation.status = 'failed'
        generation.error_message = data.get('error', 'Unknown error')
    
    db.session.commit()
    return jsonify({'success': True})

# ==================== BATCH OPERATIONS ====================

@app.route('/api/batch/generate', methods=['POST'])
@jwt_required()
def batch_generate():
    """Generate multiple items in batch"""
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    data = request.json
    prompts = data['prompts']  # List of prompts
    service = data['service']
    gen_type = data['type']
    
    if len(prompts) > 50:
        return jsonify({'error': 'Maximum 50 prompts per batch'}), 400
    
    if user.credits < len(prompts):
        return jsonify({'error': 'Insufficient credits'}), 402
    
    api_key_service = service
    if service in ['stable-diffusion', 'flux', 'runway', 'stability-video', 'musicgen', 'llama']:
        api_key_service = 'replicate'
    
    api_key = get_user_api_key(user_id, api_key_service)
    if not api_key:
        return jsonify({'error': f'{service} API key not configured'}), 400
    
    generation_ids = []
    
    for prompt in prompts:
        generation = Generation(
            user_id=user_id,
            service=service,
            type=gen_type,
            prompt=prompt,
            status='pending',
            metadata=json.dumps(data.get('params', {}))
        )
        db.session.add(generation)
        db.session.commit()
        
        # Queue appropriate task
        if gen_type == 'image':
            process_image_generation.delay(generation.id, api_key, prompt, service, data.get('params', {}))
        elif gen_type == 'video':
            process_video_generation.delay(generation.id, api_key, prompt, service, data.get('params', {}))
        elif gen_type == 'audio':
            process_audio_generation.delay(generation.id, api_key, prompt, service, data.get('params', {}))
        elif gen_type == 'text':
            process_text_generation.delay(generation.id, api_key, prompt, service, data.get('params', {}))
        
        generation_ids.append(generation.id)
        user.credits -= 1
    
    db.session.commit()
    
    return jsonify({
        'success': True,
        'generation_ids': generation_ids,
        'total': len(generation_ids)
    })

@app.route('/api/batch/status', methods=['POST'])
@jwt_required()
def batch_status():
    """Check status of multiple generations"""
    user_id = get_jwt_identity()
    data = request.json
    generation_ids = data['generation_ids']
    
    generations = Generation.query.filter(
        Generation.id.in_(generation_ids),
        Generation.user_id == user_id
    ).all()
    
    return jsonify({
        'generations': [{
            'id': g.id,
            'status': g.status,
            'completed': g.status in ['completed', 'failed']
        } for g in generations]
    })

# ==================== EXPORT ENDPOINTS ====================

@app.route('/api/export/history', methods=['GET'])
@jwt_required()
def export_history():
    """Export user's generation history as JSON"""
    user_id = get_jwt_identity()
    
    generations = Generation.query.filter_by(user_id=user_id).all()
    
    export_data = {
        'user_id': user_id,
        'exported_at': datetime.utcnow().isoformat(),
        'total_generations': len(generations),
        'generations': [{
            'id': g.id,
            'service': g.service,
            'type': g.type,
            'prompt': g.prompt,
            'status': g.status,
            'cost': g.cost,
            'created_at': g.created_at.isoformat(),
            'completed_at': g.completed_at.isoformat() if g.completed_at else None
        } for g in generations]
    }
    
    return jsonify(export_data)

@app.route('/api/export/project/<int:project_id>', methods=['GET'])
@jwt_required()
def export_project(project_id):
    """Export entire code project as ZIP"""
    user_id = get_jwt_identity()
    project = CodeProject.query.filter_by(id=project_id, user_id=user_id).first()
    
    if not project:
        return jsonify({'error': 'Project not found'}), 404
    
    # Create ZIP file
    zip_filename = f"project_{project_id}_{int(time.time())}.zip"
    zip_path = os.path.join(tempfile.gettempdir(), zip_filename)
    
    shutil.make_archive(zip_path.replace('.zip', ''), 'zip', project.project_path)
    
    return send_file(zip_path, as_attachment=True, download_name=zip_filename)

# ==================== SETTINGS & PREFERENCES ====================

@app.route('/api/settings', methods=['GET'])
@jwt_required()
def get_settings():
    """Get user settings"""
    user_id = get_jwt_identity()
    
    # Load from redis cache or default
    settings_key = f'settings:{user_id}'
    settings = redis_client.get(settings_key)
    
    if settings:
        return jsonify(json.loads(settings))
    
    # Default settings
    default_settings = {
        'default_image_service': 'dalle3',
        'default_video_service': 'runway',
        'default_audio_service': 'elevenlabs',
        'default_text_service': 'claude',
        'auto_download': False,
        'notifications_enabled': True,
        'theme': 'dark'
    }
    
    return jsonify(default_settings)

@app.route('/api/settings', methods=['POST'])
@jwt_required()
def update_settings():
    """Update user settings"""
    user_id = get_jwt_identity()
    data = request.json
    
    settings_key = f'settings:{user_id}'
    redis_client.setex(settings_key, 86400 * 365, json.dumps(data))  # 1 year
    
    return jsonify({'success': True})

# ==================== FAVORITES ====================

@app.route('/api/favorites', methods=['POST'])
@jwt_required()
def add_favorite():
    """Add generation to favorites"""
    user_id = get_jwt_identity()
    data = request.json
    generation_id = data['generation_id']
    
    # Store in redis set
    favorites_key = f'favorites:{user_id}'
    redis_client.sadd(favorites_key, generation_id)
    
    return jsonify({'success': True})

@app.route('/api/favorites', methods=['GET'])
@jwt_required()
def get_favorites():
    """Get user's favorite generations"""
    user_id = get_jwt_identity()
    
    favorites_key = f'favorites:{user_id}'
    favorite_ids = redis_client.smembers(favorites_key)
    
    if not favorite_ids:
        return jsonify({'favorites': []})
    
    generations = Generation.query.filter(
        Generation.id.in_([int(fid) for fid in favorite_ids]),
        Generation.user_id == user_id
    ).all()
    
    return jsonify({
        'favorites': [{
            'id': g.id,
            'service': g.service,
            'type': g.type,
            'prompt': g.prompt[:100],
            'status': g.status,
            'created_at': g.created_at.isoformat()
        } for g in generations]
    })

@app.route('/api/favorites/<int:generation_id>', methods=['DELETE'])
@jwt_required()
def remove_favorite(generation_id):
    """Remove generation from favorites"""
    user_id = get_jwt_identity()
    
    favorites_key = f'favorites:{user_id}'
    redis_client.srem(favorites_key, generation_id)
    
    return jsonify({'success': True})

# ==================== CREDITS & BILLING ====================

@app.route('/api/credits/purchase', methods=['POST'])
@jwt_required()
def purchase_credits():
    """Purchase credits (placeholder for payment integration)"""
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    data = request.json
    
    amount = data['amount']  # Number of credits to purchase
    
    # TODO: Integrate with Stripe/PayPal
    # For now, just add credits (in production, only do this after payment confirmation)
    
    user.credits += amount
    db.session.commit()
    
    return jsonify({
        'success': True,
        'new_balance': user.credits
    })

@app.route('/api/credits/balance', methods=['GET'])
@jwt_required()
def get_credit_balance():
    """Get current credit balance"""
    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    return jsonify({
        'credits': user.credits,
        'user_id': user_id
    })

# ==================== SHARING & COLLABORATION ====================

@app.route('/api/share/<int:generation_id>', methods=['POST'])
@jwt_required()
def create_share_link(generation_id):
    """Create shareable link for a generation"""
    user_id = get_jwt_identity()
    generation = Generation.query.filter_by(id=generation_id, user_id=user_id).first()
    
    if not generation:
        return jsonify({'error': 'Generation not found'}), 404
    
    # Create share token
    share_token = base64.urlsafe_b64encode(f"{generation_id}:{int(time.time())}".encode()).decode()
    
    # Store in redis with 7 day expiry
    share_key = f'share:{share_token}'
    redis_client.setex(share_key, 86400 * 7, generation_id)
    
    return jsonify({
        'success': True,
        'share_url': f'/shared/{share_token}'
    })

@app.route('/api/shared/<share_token>', methods=['GET'])
def get_shared_generation(share_token):
    """Get shared generation (no auth required)"""
    share_key = f'share:{share_token}'
    generation_id = redis_client.get(share_key)
    
    if not generation_id:
        return jsonify({'error': 'Share link expired or invalid'}), 404
    
    generation = Generation.query.get(int(generation_id))
    if not generation or generation.status != 'completed':
        return jsonify({'error': 'Generation not found'}), 404
    
    result = {
        'id': generation.id,
        'service': generation.service,
        'type': generation.type,
        'prompt': generation.prompt,
        'created_at': generation.created_at.isoformat()
    }
    
    if generation.result_data:
        result['data'] = generation.result_data
    if generation.result_path and os.path.exists(generation.result_path):
        with open(generation.result_path, 'rb') as f:
            result['file_data'] = base64.b64encode(f.read()).decode()
    
    return jsonify(result)

# ==================== ERROR HANDLERS ====================

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return jsonify({'error': 'Internal server error'}), 500

@app.errorhandler(429)
def rate_limit_exceeded(error):
    return jsonify({'error': 'Rate limit exceeded'}), 429

# ==================== STARTUP ====================

if __name__ == '__main__':
    print("=" * 60)
    print("COMPLETE AI HUB - PRODUCTION SERVER")
    print("=" * 60)
    print("\n🚀 Starting server on http://0.0.0.0:3000")
    print("\n📋 Available Services:")
    print("   Images: DALL-E 3, DALL-E 2, Stable Diffusion, Flux, Imagen 3")
    print("   Videos: Runway Gen-4, Veo 3, Stability Video")
    print("   Audio: ElevenLabs, OpenAI TTS, Google TTS, MusicGen")
    print("   Text: Claude Sonnet 4.5, GPT-4, Gemini 1.5, Llama 3")
    print("   Code: Claude Code Agent")
    print("   Other: Whisper Transcription")
    print("\n⚙️  Features:")
    print("   - Multi-user authentication")
    print("   - API key management")
    print("   - Rate limiting")
    print("   - Async processing")
    print("   - Admin dashboard")
    print("   - Usage analytics")
    print("   - Credit system")
    print("   - Batch operations")
    print("   - Project management")
    print("   - Sharing & collaboration")
    print("\n🔧 Requirements:")
    print("   - Redis server running on localhost:6379")
    print("   - Celery worker: celery -A app.celery worker --loglevel=info")
    print("\n" + "=" * 60)
    
    app.run(host='0.0.0.0', port=3000, debug=True)
