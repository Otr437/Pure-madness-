// ai-enhanced-test-runner.js - V1
const fs = require('fs');
const path = require('path');
const { performance } = require('perf_hooks');
const http = require('http');
const https = require('https');
const crypto = require('crypto');
const { spawn, exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

// ============================================================================
// SECURITY & AUTH MANAGER
// ============================================================================
class SecurityManager {
  constructor() {
    this.admins = new Map();
    this.apiKeys = new Map();
    this.auditLog = [];
    this.sessionTokens = new Map();
    this.encryptionKey = crypto.randomBytes(32);
    this.initializeAdmins();
  }

  initializeAdmins() {
    const defaultAdmin = {
      id: 'admin-001',
      username: 'superadmin',
      apiKey: this.generateSecureApiKey(),
      role: 'SUPER_ADMIN',
      permissions: ['*'],
      createdAt: new Date().toISOString(),
      active: true
    };
    
    this.admins.set(defaultAdmin.id, defaultAdmin);
    this.apiKeys.set(defaultAdmin.apiKey, defaultAdmin.id);
    
    console.log('üîê Default Admin Created:');
    console.log(`   Username: ${defaultAdmin.username}`);
    console.log(`   API Key: ${defaultAdmin.apiKey}`);
    console.log('   ‚ö†Ô∏è  SAVE THIS API KEY - IT WILL NOT BE SHOWN AGAIN\n');
    
    this.saveAdminConfig();
  }

  generateSecureApiKey() {
    return 'ak_' + crypto.randomBytes(32).toString('hex');
  }

  generateSessionToken() {
    return 'st_' + crypto.randomBytes(48).toString('hex');
  }

  validateApiKey(apiKey) {
    if (!apiKey || !apiKey.startsWith('ak_')) {
      this.logSecurityEvent('INVALID_API_KEY_FORMAT', { apiKey: apiKey?.substring(0, 10) });
      return null;
    }

    const adminId = this.apiKeys.get(apiKey);
    if (!adminId) {
      this.logSecurityEvent('INVALID_API_KEY', { apiKey: apiKey.substring(0, 10) });
      return null;
    }

    const admin = this.admins.get(adminId);
    if (!admin || !admin.active) {
      this.logSecurityEvent('INACTIVE_ADMIN', { adminId });
      return null;
    }

    return admin;
  }

  createSession(admin) {
    const token = this.generateSessionToken();
    const session = {
      token,
      adminId: admin.id,
      createdAt: Date.now(),
      expiresAt: Date.now() + (24 * 60 * 60 * 1000), // 24 hours
      lastActivity: Date.now()
    };
    
    this.sessionTokens.set(token, session);
    this.logSecurityEvent('SESSION_CREATED', { adminId: admin.id });
    return token;
  }

  validateSession(token) {
    const session = this.sessionTokens.get(token);
    if (!session) {
      this.logSecurityEvent('INVALID_SESSION', { token: token?.substring(0, 10) });
      return null;
    }

    if (Date.now() > session.expiresAt) {
      this.sessionTokens.delete(token);
      this.logSecurityEvent('SESSION_EXPIRED', { adminId: session.adminId });
      return null;
    }

    session.lastActivity = Date.now();
    const admin = this.admins.get(session.adminId);
    return admin;
  }

  checkPermission(admin, permission) {
    if (!admin) return false;
    if (admin.permissions.includes('*')) return true;
    return admin.permissions.includes(permission);
  }

  encrypt(data) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', this.encryptionKey, iv);
    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted;
  }

  decrypt(encryptedData) {
    const parts = encryptedData.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encrypted = parts[1];
    const decipher = crypto.createDecipheriv('aes-256-cbc', this.encryptionKey, iv);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return JSON.parse(decrypted);
  }

  sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    return input
      .replace(/[<>]/g, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+=/gi, '')
      .trim();
  }

  logSecurityEvent(event, details) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      event,
      details,
      stackTrace: new Error().stack
    };
    
    this.auditLog.push(logEntry);
    
    if (this.auditLog.length > 10000) {
      this.saveAuditLog();
      this.auditLog = this.auditLog.slice(-1000);
    }
  }

  saveAuditLog() {
    const logFile = `security-audit-${Date.now()}.json`;
    fs.writeFileSync(logFile, JSON.stringify(this.auditLog, null, 2));
  }

  saveAdminConfig() {
    const configFile = '.admin-config.secure';
    const admins = Array.from(this.admins.values()).map(admin => ({
      ...admin,
      apiKey: this.encrypt(admin.apiKey)
    }));
    fs.writeFileSync(configFile, JSON.stringify(admins, null, 2));
  }

  addAdmin(creatorAdmin, newAdminData) {
    if (!this.checkPermission(creatorAdmin, 'MANAGE_ADMINS')) {
      throw new Error('Permission denied: Cannot create admins');
    }

    const newAdmin = {
      id: 'admin-' + crypto.randomBytes(8).toString('hex'),
      username: this.sanitizeInput(newAdminData.username),
      apiKey: this.generateSecureApiKey(),
      role: newAdminData.role || 'ADMIN',
      permissions: newAdminData.permissions || ['RUN_TESTS', 'VIEW_REPORTS'],
      createdAt: new Date().toISOString(),
      createdBy: creatorAdmin.id,
      active: true
    };

    this.admins.set(newAdmin.id, newAdmin);
    this.apiKeys.set(newAdmin.apiKey, newAdmin.id);
    this.saveAdminConfig();
    this.logSecurityEvent('ADMIN_CREATED', { newAdminId: newAdmin.id, createdBy: creatorAdmin.id });

    return newAdmin;
  }

  revokeAdmin(admin, targetAdminId) {
    if (!this.checkPermission(admin, 'MANAGE_ADMINS')) {
      throw new Error('Permission denied');
    }

    const targetAdmin = this.admins.get(targetAdminId);
    if (!targetAdmin) {
      throw new Error('Admin not found');
    }

    if (targetAdmin.role === 'SUPER_ADMIN') {
      throw new Error('Cannot revoke super admin');
    }

    targetAdmin.active = false;
    this.saveAdminConfig();
    this.logSecurityEvent('ADMIN_REVOKED', { targetAdminId, revokedBy: admin.id });
  }
}

// ============================================================================
// RATE LIMITER
// ============================================================================
class RateLimiter {
  constructor(options = {}) {
    this.windowMs = options.windowMs || 60000; // 1 minute
    this.maxRequests = options.maxRequests || 100;
    this.maxConcurrent = options.maxConcurrent || 5;
    this.requestCounts = new Map();
    this.concurrentRequests = new Map();
    this.blockedIPs = new Set();
    this.blockDuration = options.blockDuration || 3600000; // 1 hour
  }

  checkLimit(identifier) {
    if (this.blockedIPs.has(identifier)) {
      throw new Error('IP blocked due to rate limit violations');
    }

    const now = Date.now();
    const userRequests = this.requestCounts.get(identifier) || [];
    
    const recentRequests = userRequests.filter(time => now - time < this.windowMs);
    
    if (recentRequests.length >= this.maxRequests) {
      this.blockIP(identifier);
      throw new Error(`Rate limit exceeded: ${this.maxRequests} requests per ${this.windowMs}ms`);
    }

    recentRequests.push(now);
    this.requestCounts.set(identifier, recentRequests);

    const concurrent = this.concurrentRequests.get(identifier) || 0;
    if (concurrent >= this.maxConcurrent) {
      throw new Error(`Concurrent request limit exceeded: ${this.maxConcurrent}`);
    }

    return true;
  }

  incrementConcurrent(identifier) {
    const current = this.concurrentRequests.get(identifier) || 0;
    this.concurrentRequests.set(identifier, current + 1);
  }

  decrementConcurrent(identifier) {
    const current = this.concurrentRequests.get(identifier) || 0;
    this.concurrentRequests.set(identifier, Math.max(0, current - 1));
  }

  blockIP(identifier) {
    this.blockedIPs.add(identifier);
    setTimeout(() => {
      this.blockedIPs.delete(identifier);
    }, this.blockDuration);
  }

  cleanup() {
    const now = Date.now();
    for (const [identifier, requests] of this.requestCounts.entries()) {
      const recent = requests.filter(time => now - time < this.windowMs);
      if (recent.length === 0) {
        this.requestCounts.delete(identifier);
      } else {
        this.requestCounts.set(identifier, recent);
      }
    }
  }
}

// ============================================================================
// OLLAMA AI AUDITOR
// ============================================================================
class OllamaAIAuditor {
  constructor(config = {}) {
    this.host = config.host || 'localhost';
    this.port = config.port || 11434;
    this.model = config.model || 'codellama';
    this.enabled = config.enabled !== false;
    this.timeout = config.timeout || 120000;
    this.maxRetries = config.maxRetries || 3;
    this.requestDelay = config.requestDelay || 2000;
    this.lastRequestTime = 0;
  }

  async checkOllamaAvailable() {
    if (!this.enabled) return false;
    
    return new Promise((resolve) => {
      const req = http.get(`http://${this.host}:${this.port}/api/tags`, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          try {
            const parsed = JSON.parse(data);
            resolve(res.statusCode === 200 && parsed.models && Array.isArray(parsed.models));
          } catch {
            resolve(false);
          }
        });
      });
      req.on('error', () => resolve(false));
      req.setTimeout(5000, () => {
        req.destroy();
        resolve(false);
      });
    });
  }

  async ensureModelAvailable() {
    const available = await this.checkOllamaAvailable();
    if (!available) {
      throw new Error('Ollama service not running. Start with: ollama serve');
    }

    const hasModel = await this.checkModelExists();
    if (!hasModel) {
      console.log(`üì• Pulling model ${this.model}...`);
      await this.pullModel();
    }
    return true;
  }

  async checkModelExists() {
    return new Promise((resolve) => {
      const checkData = JSON.stringify({ name: this.model });
      const req = http.request({
        hostname: this.host,
        port: this.port,
        path: '/api/show',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(checkData)
        },
        timeout: 10000
      }, (res) => {
        resolve(res.statusCode === 200);
      });
      
      req.on('error', () => resolve(false));
      req.write(checkData);
      req.end();
    });
  }

  async pullModel() {
    return new Promise((resolve, reject) => {
      const pullData = JSON.stringify({ name: this.model, stream: true });
      const req = http.request({
        hostname: this.host,
        port: this.port,
        path: '/api/pull',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(pullData)
        },
        timeout: 600000
      }, (res) => {
        let lastStatus = '';
        res.on('data', chunk => {
          try {
            const lines = chunk.toString().split('\n').filter(l => l.trim());
            for (const line of lines) {
              const data = JSON.parse(line);
              if (data.status && data.status !== lastStatus) {
                process.stdout.write(`\r${data.status}`);
                lastStatus = data.status;
              }
            }
          } catch {}
        });
        res.on('end', () => {
          console.log('\n‚úÖ Model ready');
          resolve(true);
        });
      });
      
      req.on('error', reject);
      req.setTimeout(600000);
      req.write(pullData);
      req.end();
    });
  }

  async analyzeCode(code, filePath, retryCount = 0) {
    if (!this.enabled) {
      return { available: false, analysis: null };
    }

    try {
      await this.ensureModelAvailable();
      
      const now = Date.now();
      const timeSinceLastRequest = now - this.lastRequestTime;
      if (timeSinceLastRequest < this.requestDelay) {
        await new Promise(resolve => setTimeout(resolve, this.requestDelay - timeSinceLastRequest));
      }
      this.lastRequestTime = Date.now();

      console.log(`ü§ñ Ollama analyzing ${path.basename(filePath)}...`);

      const prompt = this.buildAnalysisPrompt(code, filePath);
      const analysis = await this.queryOllama(prompt);
      const parsed = this.parseAnalysis(analysis);

      return { available: true, analysis: parsed };

    } catch (error) {
      if (retryCount < this.maxRetries) {
        console.log(`‚ö†Ô∏è  Retry ${retryCount + 1}/${this.maxRetries}...`);
        await new Promise(resolve => setTimeout(resolve, 5000));
        return this.analyzeCode(code, filePath, retryCount + 1);
      }
      
      console.log(`‚ùå Ollama analysis failed: ${error.message}`);
      return { available: false, analysis: null, error: error.message };
    }
  }

  buildAnalysisPrompt(code, filePath) {
    const fileExt = path.extname(filePath);
    const isWeb3 = code.includes('web3') || code.includes('ethers') || code.includes('Contract');

    return `You are an expert code auditor. Analyze this ${fileExt} file for security and quality issues.

FILE: ${filePath}
TYPE: ${isWeb3 ? 'Web3/Blockchain' : 'Standard JavaScript'}

CODE:
\`\`\`javascript
${code}
\`\`\`

Provide analysis in this EXACT JSON format:
{
  "syntaxErrors": [{"line": number, "message": "string", "severity": "error|warning"}],
  "securityIssues": [{"type": "string", "line": number, "description": "string", "severity": "critical|high|medium|low", "fix": "string"}],
  "web3Issues": [{"type": "string", "line": number, "description": "string", "severity": "string", "fix": "string"}],
  "bestPractices": [{"category": "string", "issue": "string", "suggestion": "string"}],
  "performance": [{"issue": "string", "impact": "string", "fix": "string"}],
  "overallScore": number,
  "riskLevel": "CRITICAL|HIGH|MEDIUM|LOW",
  "fixedCode": "string or null"
}

Check for:
- Syntax errors, undefined variables, type errors
- SQL injection, XSS, command injection, prototype pollution
- Hardcoded secrets, weak crypto, insecure random
- Reentrancy, integer overflow, unchecked external calls (Web3)
- Gas optimization, access control, input validation (Web3)
- Missing error handling, memory leaks, blocking operations
- Code complexity, maintainability issues

Provide fixed code only if there are critical issues.`;
  }

  async queryOllama(prompt) {
    return new Promise((resolve, reject) => {
      const requestData = JSON.stringify({
        model: this.model,
        prompt: prompt,
        stream: false,
        options: {
          temperature: 0.1,
          num_predict: 4096
        }
      });

      const req = http.request({
        hostname: this.host,
        port: this.port,
        path: '/api/generate',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(requestData)
        },
        timeout: this.timeout
      }, (res) => {
        let data = '';
        
        res.on('data', chunk => {
          data += chunk.toString();
        });

        res.on('end', () => {
          try {
            const response = JSON.parse(data);
            resolve(response.response || '');
          } catch (error) {
            reject(new Error('Failed to parse Ollama response'));
          }
        });
      });

      req.on('error', reject);
      req.on('timeout', () => {
        req.destroy();
        reject(new Error('Ollama request timeout'));
      });

      req.write(requestData);
      req.end();
    });
  }

  parseAnalysis(response) {
    try {
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
    } catch {}

    return {
      syntaxErrors: [],
      securityIssues: [],
      web3Issues: [],
      bestPractices: [],
      performance: [],
      overallScore: 50,
      riskLevel: 'UNKNOWN',
      fixedCode: null,
      rawResponse: response
    };
  }

  async autoFix(code, analysis) {
    if (!analysis || !analysis.fixedCode) {
      return null;
    }

    const fixedCode = analysis.fixedCode;
    
    try {
      const testResult = await this.validateFixedCode(fixedCode);
      if (testResult.valid) {
        return fixedCode;
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è  Auto-fix validation failed: ${error.message}`);
    }

    return null;
  }

  async validateFixedCode(code) {
    return new Promise((resolve) => {
      const tempFile = path.join(__dirname, `.temp-${Date.now()}.js`);
      
      try {
        fs.writeFileSync(tempFile, code);
        
        exec(`node --check ${tempFile}`, (error, stdout, stderr) => {
          fs.unlinkSync(tempFile);
          
          if (error) {
            resolve({ valid: false, error: stderr });
          } else {
            resolve({ valid: true });
          }
        });
      } catch (error) {
        if (fs.existsSync(tempFile)) {
          fs.unlinkSync(tempFile);
        }
        resolve({ valid: false, error: error.message });
      }
    });
  }
}

// ============================================================================
// ENHANCED UNIVERSAL TESTER
// ============================================================================
class UniversalNodeJSTester {
  constructor(config = {}) {
    this.security = new SecurityManager();
    this.rateLimiter = new RateLimiter({
      windowMs: 60000,
      maxRequests: 100,
      maxConcurrent: 5
    });
    this.aiAuditor = new OllamaAIAuditor(config.ollama || {});
    
    this.metrics = {
      totalTests: 0,
      passedTests: 0,
      failedTests: 0,
      performanceMetrics: {},
      securityIssues: [],
      aiAnalysis: {},
      connectionTests: {},
      transactionTests: {},
      compilationResults: {}
    };
    
    this.debuggerEnabled = config.debug !== false;
    this.autoFix = config.autoFix === true;
    this.emergencyStop = false;
  }

  async authenticate(apiKey) {
    const admin = this.security.validateApiKey(apiKey);
    if (!admin) {
      throw new Error('Authentication failed: Invalid API key');
    }

    if (!this.security.checkPermission(admin, 'RUN_TESTS')) {
      throw new Error('Permission denied: Cannot run tests');
    }

    const sessionToken = this.security.createSession(admin);
    return { admin, sessionToken };
  }

  async runTests(testFolder, apiKey) {
    const { admin, sessionToken } = await this.authenticate(apiKey);
    const identifier = `admin:${admin.id}`;

    try {
      this.rateLimiter.checkLimit(identifier);
      this.rateLimiter.incrementConcurrent(identifier);

      console.log('üöÄ Starting AI-Enhanced Universal Test Runner\n');
      console.log(`üë§ Authenticated as: ${admin.username} (${admin.role})`);
      console.log(`üîë Session: ${sessionToken.substring(0, 20)}...\n`);

      if (!fs.existsSync(testFolder)) {
        throw new Error(`Test folder "${testFolder}" not found`);
      }

      const testFiles = this.findTestFiles(testFolder);
      this.metrics.totalTests = testFiles.length;

      console.log(`üìÇ Found ${testFiles.length} files to test\n`);

      for (const file of testFiles) {
        if (this.emergencyStop) {
          console.log('\nüõë EMERGENCY STOP ACTIVATED\n');
          break;
        }

        await this.executeTestFile(file, admin);
      }

      await this.generateReport(admin);
      this.security.logSecurityEvent('TEST_RUN_COMPLETED', { 
        adminId: admin.id,
        totalTests: this.metrics.totalTests,
        passed: this.metrics.passedTests,
        failed: this.metrics.failedTests
      });

    } finally {
      this.rateLimiter.decrementConcurrent(identifier);
    }
  }

  findTestFiles(folder) {
    const files = [];
    
    const scanDirectory = (dir) => {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        if (item.startsWith('.')) continue;
        
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          scanDirectory(fullPath);
        } else if (
          item.endsWith('.js') && 
          !item.includes('test-runner') &&
          !item.includes('demo-tester') &&
          !item.startsWith('.')
        ) {
          files.push(fullPath);
        }
      }
    };
    
    scanDirectory(folder);
    return files;
  }

  async executeTestFile(filePath, admin) {
    console.log(`\n${'='.repeat(70)}`);
    console.log(`üìÅ Testing: ${path.basename(filePath)}`);
    console.log('='.repeat(70));
    
    const startTime = performance.now();

    try {
      const code = fs.readFileSync(filePath, 'utf8');
      
      console.log('\nüîç Phase 1: Pre-deployment AI Analysis...');
      const aiResult = await this.aiAuditor.analyzeCode(code, filePath);
      
      if (aiResult.available && aiResult.analysis) {
        this.metrics.aiAnalysis[filePath] = aiResult.analysis;
        this.displayAIAnalysis(aiResult.analysis, filePath);
        
        if (aiResult.analysis.riskLevel === 'CRITICAL') {
          console.log('\nüö® CRITICAL ISSUES DETECTED - BLOCKING DEPLOYMENT');
          
          if (this.autoFix && aiResult.analysis.fixedCode) {
            console.log('\nüîß Attempting auto-fix...');
            const fixed = await this.aiAuditor.autoFix(code, aiResult.analysis);
            
            if (fixed) {
              const fixedPath = filePath.replace('.js', '.fixed.js');
              fs.writeFileSync(fixedPath, fixed);
              console.log(`‚úÖ Fixed code saved to: ${fixedPath}`);
            }
          }
          
          throw new Error('Critical security issues prevent deployment');
        }
      }

      console.log('\nüîç Phase 2: Syntax & Compilation Check...');
      await this.compilationCheck(filePath);

      console.log('\nüîç Phase 3: Security Scan...');
      const securityScore = await this.securityScan(filePath, code);

      console.log('\nüîç Phase 4: Loading Module...');
      delete require.cache[require.resolve(filePath)];
      const module = require(filePath);

      console.log('\nüîç Phase 5: Connection Tests...');
      await this.testConnections(module, filePath);

      console.log('\nüîç Phase 6: Functional Tests...');
      await this.testFunctionality(module, filePath);

      console.log('\nüîç Phase 7: Transaction Tests...');
      await this.testTransactions(module, filePath);

      console.log('\nüîç Phase 8: Web3 Security (if applicable)...');
      await this.testWeb3Security(module, filePath, code);

      const endTime = performance.now();
      const executionTime = endTime - startTime;

      this.metrics.performanceMetrics[filePath] = {
        executionTime,
        securityScore,
        timestamp: new Date().toISOString(),
        aiAnalysis: aiResult.available
      };

      this.metrics.passedTests++;
      console.log(`\n‚úÖ ${path.basename(filePath)} - ALL TESTS PASSED (${executionTime.toFixed(2)}ms)`);

    } catch (error) {
      this.metrics.failedTests++;
      console.log(`\n‚ùå ${path.basename(filePath)} - FAILED`);
      console.log(`   Error: ${error.message}`);
      this.logDebug('ERROR', error.stack);
      
      this.security.logSecurityEvent('TEST_FAILURE', {
        file: filePath,
        error: error.message,
        adminId: admin.id
      });
    }
  }

  async compilationCheck(filePath) {
    return new Promise((resolve, reject) => {
      exec(`node --check "${filePath}"`, (error, stdout, stderr) => {
        if (error) {
          this.metrics.compilationResults[filePath] = {
            success: false,
            error: stderr
          };
          console.log(`   ‚ùå Compilation failed: ${stderr}`);
          reject(new Error(`Compilation error: ${stderr}`));
        } else {
          this.metrics.compilationResults[filePath] = {
            success: true
          };
          console.log('   ‚úÖ Syntax valid');
          resolve();
        }
      });
    });
  }

  displayAIAnalysis(analysis, filePath) {
    console.log(`\n   üìä AI Analysis Results:`);
    console.log(`   Overall Score: ${analysis.overallScore}/100`);
    console.log(`   Risk Level: ${analysis.riskLevel}`);

    if (analysis.syntaxErrors && analysis.syntaxErrors.length > 0) {
      console.log(`\n   ‚ö†Ô∏è  Syntax Errors (${analysis.syntaxErrors.length}):`);
      analysis.syntaxErrors.slice(0, 5).forEach(err => {
        console.log(`      Line ${err.line}: ${err.message}`);
      });
    }

    if (analysis.securityIssues && analysis.securityIssues.length > 0) {
      console.log(`\n   üîí Security Issues (${analysis.securityIssues.length}):`);
      analysis.securityIssues.slice(0, 5).forEach(issue => {
        console.log(`      [${issue.severity.toUpperCase()}] ${issue.type}: ${issue.description}`);
        if (issue.fix) {
          console.log(`         Fix: ${issue.fix}`);
        }
      });
    }

    if (analysis.web3Issues && analysis.web3Issues.length > 0) {
      console.log(`\n   ‚õìÔ∏è  Web3 Issues (${analysis.web3Issues.length}):`);
      analysis.web3Issues.slice(0, 5).forEach(issue => {
        console.log(`      [${issue.severity.toUpperCase()}] ${issue.type}: ${issue.description}`);
      });
    }

    if (analysis.bestPractices && analysis.bestPractices.length > 0) {
      console.log(`\n   üí° Best Practice Suggestions (${analysis.bestPractices.length}):`);
      analysis.bestPractices.slice(0, 3).forEach(bp => {
        console.log(`      ${bp.category}: ${bp.suggestion}`);
      });
    }
  }

  async securityScan(filePath, code) {
    let securityScore = 100;
    const issues = [];

    const checks = [
      { pattern: /eval\s*\(/g, penalty: 25, message: 'eval() usage detected' },
      { pattern: /Function\s*\(/g, penalty: 20, message: 'Function constructor detected' },
      { pattern: /exec\s*\(/g, penalty: 20, message: 'exec() usage - potential command injection' },
      { pattern: /(password|secret|key|token|api_key)\s*=\s*['"][^'"]{8,}['"]/gi, penalty: 30, message: 'Hardcoded credentials detected' },
      { pattern: /innerHTML\s*=/g, penalty: 15, message: 'innerHTML usage - XSS risk' },
      { pattern: /dangerouslySetInnerHTML/g, penalty: 15, message: 'dangerouslySetInnerHTML detected' },
      { pattern: /Math\.random\(\)/g, penalty: 10, message: 'Insecure random number generation' },
      { pattern: /\.send\([^)]*\+/g, penalty: 15, message: 'String concatenation in queries - SQL injection risk' },
      { pattern: /process\.env\.\w+(?!\s*\|\|)/g, penalty: 10, message: 'Environment variable without fallback' },
      { pattern: /__proto__/g, penalty: 20, message: 'Prototype pollution risk' },
      { pattern: /child_process/g, penalty: 15, message: 'Child process usage requires validation' },
      { pattern: /\.call\(null/g, penalty: 10, message: 'Unsafe function call' },
      { pattern: /new Function/gi, penalty: 20, message: 'Dynamic function creation' },
      { pattern: /document\.write/g, penalty: 15, message: 'document.write usage' },
      { pattern: /\.setRequestHeader\(/g, penalty: 5, message: 'Manual header setting - verify CORS' }
    ];

    for (const check of checks) {
      const matches = code.match(check.pattern);
      if (matches) {
        securityScore -= check.penalty;
        issues.push({
          type: check.message,
          count: matches.length,
          penalty: check.penalty
        });
        console.log(`   ‚ö†Ô∏è  ${check.message} (${matches.length} instances, -${check.penalty} points)`);
      }
    }

    const privateKeyPattern = /(?:private.*key|mnemonic|seed.*phrase).*?['"]([a-fA-F0-9]{64}|[\w\s]{24,})['"]/gi;
    const privateKeyMatches = code.match(privateKeyPattern);
    if (privateKeyMatches) {
      securityScore -= 50;
      issues.push({
        type: 'CRITICAL: Private key or mnemonic exposed',
        count: privateKeyMatches.length,
        penalty: 50
      });
      console.log(`   üö® CRITICAL: Private keys/mnemonics exposed (${privateKeyMatches.length} instances)`);
    }

    if (issues.length > 0) {
      this.metrics.securityIssues.push({
        file: filePath,
        issues: issues,
        score: Math.max(0, securityScore)
      });
    }

    console.log(`   Security Score: ${Math.max(0, securityScore)}/100`);
    return Math.max(0, securityScore);
  }

  async testConnections(module, filePath) {
    const connectionMethods = [
      'connect', 'initialize', 'init', 'setup', 'createConnection',
      'connectToDatabase', 'connectToNetwork', 'establishConnection'
    ];

    let tested = 0;
    for (const method of connectionMethods) {
      if (typeof module[method] === 'function') {
        try {
          this.logDebug('CONNECTION', `Testing ${method}`);
          
          const mockConnection = {
            readyState: 1,
            connected: true,
            isConnected: () => true,
            close: () => Promise.resolve(),
            disconnect: () => Promise.resolve(),
            on: () => {},
            once: () => {},
            emit: () => {}
          };

          const timeout = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Connection timeout')), 5000)
          );

          const result = await Promise.race([
            module[method](mockConnection),
            timeout
          ]);

          this.metrics.connectionTests[`${path.basename(filePath)}.${method}`] = 'SUCCESS';
          console.log(`   ‚úÖ ${method}: PASSED`);
          tested++;
          
        } catch (error) {
          this.metrics.connectionTests[`${path.basename(filePath)}.${method}`] = 'FAILED';
          console.log(`   ‚ùå ${method}: ${error.message}`);
        }
      }
    }

    if (tested === 0) {
      console.log('   ‚ÑπÔ∏è  No connection methods found');
    }
  }

  async testFunctionality(module, filePath) {
    const testMethods = [
      'getBalance', 'getAccount', 'getTransaction', 'verifySignature',
      'encrypt', 'decrypt', 'signMessage', 'verifyMessage', 'hash',
      'validateAddress', 'estimateGas', 'getNonce', 'getBlock'
    ];

    let tested = 0;
    for (const method of testMethods) {
      if (typeof module[method] === 'function') {
        try {
          this.logDebug('FUNCTIONALITY', `Testing ${method}`);
          
          const mockData = this.generateMockData(method);
          
          const timeout = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Function timeout')), 3000)
          );

          const result = await Promise.race([
            module[method](...mockData),
            timeout
          ]);
          
          if (result === undefined && !['disconnect', 'close'].includes(method)) {
            console.log(`   ‚ö†Ô∏è  ${method}: Returned undefined`);
          } else {
            console.log(`   ‚úÖ ${method}: PASSED`);
          }
          tested++;
          
        } catch (error) {
          if (!error.message.includes('not implemented') && 
              !error.message.includes('mock')) {
            console.log(`   ‚ö†Ô∏è  ${method}: ${error.message}`);
          } else {
            console.log(`   ‚úÖ ${method}: Expected mock error`);
          }
        }
      }
    }

    if (tested === 0) {
      console.log('   ‚ÑπÔ∏è  No standard methods found');
    }
  }

  async testTransactions(module, filePath) {
    const transactionMethods = [
      'sendTransaction', 'createTransaction', 'transfer', 'swap',
      'executeTransaction', 'signTransaction', 'broadcastTransaction'
    ];

    let tested = 0;
    for (const method of transactionMethods) {
      if (typeof module[method] === 'function') {
        try {
          this.logDebug('TRANSACTION', `Testing ${method}`);
          
          const mockTx = {
            from: '0x' + '1'.repeat(40),
            to: '0x' + '2'.repeat(40),
            value: '1000000000000000000',
            amount: '0.001',
            currency: 'ETH',
            gas: 21000,
            gasPrice: '20000000000',
            nonce: 0,
            data: '0x',
            chainId: 1,
            timestamp: Date.now()
          };

          const timeout = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Transaction timeout')), 5000)
          );

          const result = await Promise.race([
            module[method](mockTx),
            timeout
          ]);
          
          if (result && (result.hash || result.transactionId || result.txHash || result.success)) {
            this.metrics.transactionTests[`${path.basename(filePath)}.${method}`] = 'SUCCESS';
            console.log(`   ‚úÖ ${method}: Transaction simulation PASSED`);
          } else {
            console.log(`   ‚ö†Ô∏è  ${method}: Unexpected response format`);
          }
          tested++;
          
        } catch (error) {
          this.metrics.transactionTests[`${path.basename(filePath)}.${method}`] = 'FAILED';
          if (error.message.includes('mock') || error.message.includes('test')) {
            console.log(`   ‚úÖ ${method}: Expected test error`);
          } else {
            console.log(`   ‚ùå ${method}: ${error.message}`);
          }
        }
      }
    }

    if (tested === 0) {
      console.log('   ‚ÑπÔ∏è  No transaction methods found');
    }
  }

  async testWeb3Security(module, filePath, code) {
    const isWeb3 = code.includes('web3') || code.includes('ethers') || 
                   code.includes('Contract') || code.includes('provider');

    if (!isWeb3) {
      console.log('   ‚ÑπÔ∏è  Not a Web3 module - skipping');
      return;
    }

    const web3Checks = [
      {
        name: 'Reentrancy Protection',
        check: () => {
          const hasReentrancy = /transfer|call|send/.test(code);
          const hasGuard = /nonReentrant|mutex|locked/.test(code);
          return hasReentrancy && !hasGuard ? 
            'Missing reentrancy protection on external calls' : null;
        }
      },
      {
        name: 'Access Control',
        check: () => {
          const hasPrivileged = /onlyOwner|onlyAdmin|require.*msg\.sender/.test(code);
          const hasFunctions = /function\s+\w+\s*\([^)]*\)\s*(public|external)/.test(code);
          return hasFunctions && !hasPrivileged ? 
            'Public functions without access control' : null;
        }
      },
      {
        name: 'Integer Overflow/Underflow',
        check: () => {
          const hasMath = /[\+\-\*\/]/.test(code);
          const hasSafeMath = /SafeMath|\.add\(|\.sub\(|\.mul\(|\.div\(/.test(code);
          return hasMath && !hasSafeMath ? 
            'Arithmetic operations without SafeMath' : null;
        }
      },
      {
        name: 'Gas Optimization',
        check: () => {
          const hasLoops = /for\s*\(|while\s*\(/.test(code);
          const hasUnbounded = hasLoops && !/\.length\s*<\s*\d+/.test(code);
          return hasUnbounded ? 
            'Unbounded loops may cause gas issues' : null;
        }
      },
      {
        name: 'External Call Safety',
        check: () => {
          const hasExternalCall = /\.call\(|\.delegatecall\(|\.send\(/.test(code);
          const hasCheck = /require\(.*\.call|if\s*\(.*\.call/.test(code);
          return hasExternalCall && !hasCheck ? 
            'Unchecked external calls detected' : null;
        }
      },
      {
        name: 'Input Validation',
        check: () => {
          const hasParams = /function\s+\w+\s*\([^)]+\)/.test(code);
          const hasValidation = /require\(|assert\(|revert\(/.test(code);
          return hasParams && !hasValidation ? 
            'Missing input validation on function parameters' : null;
        }
      }
    ];

    console.log('   üîç Running Web3 Security Checks:');
    let issues = 0;

    for (const check of web3Checks) {
      try {
        const result = check.check();
        if (result) {
          console.log(`   ‚ö†Ô∏è  ${check.name}: ${result}`);
          issues++;
        } else {
          console.log(`   ‚úÖ ${check.name}: OK`);
        }
      } catch (error) {
        console.log(`   ‚ö†Ô∏è  ${check.name}: Check failed`);
      }
    }

    if (issues === 0) {
      console.log('   ‚úÖ All Web3 security checks passed');
    } else {
      console.log(`   ‚ö†Ô∏è  Found ${issues} Web3 security concern(s)`);
    }
  }

  generateMockData(method) {
    const mockAddresses = {
      ethereum: '0x' + '7'.repeat(40),
      bitcoin: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',
      solana: '11111111111111111111111111111111'
    };

    const mockData = {
      'getBalance': [mockAddresses.ethereum],
      'getAccount': ['mock-account-123'],
      'getTransaction': ['0x' + 'a'.repeat(64)],
      'verifySignature': ['message', '0x' + 'b'.repeat(130), mockAddresses.ethereum],
      'encrypt': ['sensitive data to encrypt', 'encryption-key-12345'],
      'decrypt': ['encrypted-data-string', 'encryption-key-12345'],
      'signMessage': ['Message to sign', '0x' + 'c'.repeat(64)],
      'verifyMessage': ['Message', '0x' + 'd'.repeat(130), mockAddresses.ethereum],
      'hash': ['data to hash'],
      'validateAddress': [mockAddresses.ethereum],
      'estimateGas': [{ from: mockAddresses.ethereum, to: mockAddresses.ethereum, value: '1000' }],
      'getNonce': [mockAddresses.ethereum],
      'getBlock': ['latest']
    };

    return mockData[method] || ['mock-param'];
  }

  logDebug(type, message) {
    if (this.debuggerEnabled) {
      const timestamp = new Date().toISOString();
      console.log(`   üîç [${timestamp}] [${type}] ${message}`);
    }
  }

  async generateReport(admin) {
    console.log('\n\n' + '='.repeat(80));
    console.log('üìä UNIVERSAL AI-ENHANCED TESTER - FINAL REPORT');
    console.log('='.repeat(80));
    
    console.log(`\nReport Generated: ${new Date().toISOString()}`);
    console.log(`Test Runner: ${admin.username} (${admin.role})`);
    
    console.log(`\nüìà SUMMARY:`);
    console.log(`   Total Files Tested: ${this.metrics.totalTests}`);
    console.log(`   ‚úÖ Passed: ${this.metrics.passedTests}`);
    console.log(`   ‚ùå Failed: ${this.metrics.failedTests}`);
    const successRate = this.metrics.totalTests > 0 ? 
      ((this.metrics.passedTests / this.metrics.totalTests) * 100).toFixed(1) : 0;
    console.log(`   üìä Success Rate: ${successRate}%`);

    console.log(`\n‚ö° PERFORMANCE METRICS:`);
    const perfEntries = Object.entries(this.metrics.performanceMetrics);
    if (perfEntries.length > 0) {
      perfEntries.forEach(([file, metrics]) => {
        console.log(`   ${path.basename(file)}:`);
        console.log(`      Execution Time: ${metrics.executionTime.toFixed(2)}ms`);
        console.log(`      Security Score: ${metrics.securityScore}/100`);
        console.log(`      AI Analysis: ${metrics.aiAnalysis ? 'Yes' : 'No'}`);
      });
    } else {
      console.log('   No performance data collected');
    }

    console.log(`\nü§ñ AI ANALYSIS SUMMARY:`);
    const aiEntries = Object.entries(this.metrics.aiAnalysis);
    if (aiEntries.length > 0) {
      aiEntries.forEach(([file, analysis]) => {
        console.log(`   ${path.basename(file)}:`);
        console.log(`      Overall Score: ${analysis.overallScore}/100`);
        console.log(`      Risk Level: ${analysis.riskLevel}`);
        console.log(`      Syntax Errors: ${analysis.syntaxErrors?.length || 0}`);
        console.log(`      Security Issues: ${analysis.securityIssues?.length || 0}`);
        console.log(`      Web3 Issues: ${analysis.web3Issues?.length || 0}`);
      });
    } else {
      console.log('   No AI analysis data available');
    }

    if (this.metrics.securityIssues.length > 0) {
      console.log(`\nüîí SECURITY ISSUES FOUND:`);
      this.metrics.securityIssues.forEach(issue => {
        console.log(`   ${path.basename(issue.file)} (Score: ${issue.score}/100):`);
        issue.issues.forEach((desc, idx) => {
          console.log(`      ${idx + 1}. ${desc.type} (Count: ${desc.count}, Penalty: -${desc.penalty})`);
        });
      });
    }

    console.log(`\nüîó CONNECTION TESTS:`);
    const connEntries = Object.entries(this.metrics.connectionTests);
    if (connEntries.length > 0) {
      connEntries.forEach(([test, result]) => {
        const icon = result === 'SUCCESS' ? '‚úÖ' : '‚ùå';
        console.log(`   ${icon} ${test}: ${result}`);
      });
    } else {
      console.log('   No connection tests performed');
    }

    console.log(`\nüí∏ TRANSACTION TESTS:`);
    const txEntries = Object.entries(this.metrics.transactionTests);
    if (txEntries.length > 0) {
      txEntries.forEach(([test, result]) => {
        const icon = result === 'SUCCESS' ? '‚úÖ' : '‚ùå';
        console.log(`   ${icon} ${test}: ${result}`);
      });
    } else {
      console.log('   No transaction tests performed');
    }

    console.log(`\n‚úÖ COMPILATION RESULTS:`);
    const compEntries = Object.entries(this.metrics.compilationResults);
    if (compEntries.length > 0) {
      compEntries.forEach(([file, result]) => {
        const icon = result.success ? '‚úÖ' : '‚ùå';
        console.log(`   ${icon} ${path.basename(file)}: ${result.success ? 'Valid' : result.error}`);
      });
    } else {
      console.log('   No compilation checks performed');
    }

    await this.saveDetailedReport(admin);
    this.rateLimiter.cleanup();
  }

  async saveDetailedReport(admin) {
    const report = {
      timestamp: new Date().toISOString(),
      generatedBy: {
        admin: admin.username,
        role: admin.role,
        id: admin.id
      },
      summary: {
        total: this.metrics.totalTests,
        passed: this.metrics.passedTests,
        failed: this.metrics.failedTests,
        successRate: this.metrics.totalTests > 0 ? 
          (this.metrics.passedTests / this.metrics.totalTests) * 100 : 0
      },
      performanceMetrics: this.metrics.performanceMetrics,
      aiAnalysis: this.metrics.aiAnalysis,
      securityIssues: this.metrics.securityIssues,
      connectionTests: this.metrics.connectionTests,
      transactionTests: this.metrics.transactionTests,
      compilationResults: this.metrics.compilationResults,
      metadata: {
        nodeVersion: process.version,
        platform: process.platform,
        arch: process.arch
      }
    };

    const filename = `test-report-${Date.now()}.json`;
    fs.writeFileSync(filename, JSON.stringify(report, null, 2));
    
    console.log(`\nüíæ Detailed report saved to: ${filename}`);

    const summary = this.generateMarkdownReport(report);
    const mdFilename = `test-report-${Date.now()}.md`;
    fs.writeFileSync(mdFilename, summary);
    console.log(`üìÑ Markdown report saved to: ${mdFilename}`);

    this.security.logSecurityEvent('REPORT_GENERATED', {
      adminId: admin.id,
      reportFile: filename,
      summary: report.summary
    });
  }

  generateMarkdownReport(report) {
    return `# Test Report

**Generated:** ${report.timestamp}  
**By:** ${report.generatedBy.admin} (${report.generatedBy.role})

## Summary

- **Total Tests:** ${report.summary.total}
- **Passed:** ${report.summary.passed} ‚úÖ
- **Failed:** ${report.summary.failed} ‚ùå
- **Success Rate:** ${report.summary.successRate.toFixed(1)}%

## Performance Metrics

${Object.entries(report.performanceMetrics).map(([file, metrics]) => `
### ${path.basename(file)}
- Execution Time: ${metrics.executionTime.toFixed(2)}ms
- Security Score: ${metrics.securityScore}/100
- AI Analysis: ${metrics.aiAnalysis ? 'Yes' : 'No'}
`).join('\n')}

## AI Analysis

${Object.entries(report.aiAnalysis).map(([file, analysis]) => `
### ${path.basename(file)}
- Overall Score: ${analysis.overallScore}/100
- Risk Level: ${analysis.riskLevel}
- Syntax Errors: ${analysis.syntaxErrors?.length || 0}
- Security Issues: ${analysis.securityIssues?.length || 0}
- Web3 Issues: ${analysis.web3Issues?.length || 0}
`).join('\n')}

## Security Issues

${report.securityIssues.map(issue => `
### ${path.basename(issue.file)} (Score: ${issue.score}/100)
${issue.issues.map((i, idx) => `${idx + 1}. ${i.type} (Count: ${i.count}, Penalty: -${i.penalty})`).join('\n')}
`).join('\n')}

---
*Generated by AI-Enhanced Universal Test Runner*
`;
  }

  emergencyShutdown(admin) {
    if (!this.security.checkPermission(admin, '*')) {
      throw new Error('Permission denied: Emergency shutdown requires super admin');
    }

    this.emergencyStop = true;
    console.log('\nüö® EMERGENCY SHUTDOWN INITIATED BY ' + admin.username);
    this.security.logSecurityEvent('EMERGENCY_SHUTDOWN', { adminId: admin.id });
  }
}

// ============================================================================
// CLI INTERFACE
// ============================================================================
if (require.main === module) {
  const args = process.argv.slice(2);
  
  const config = {
    testFolder: args[0] || './demo-tests',
    apiKey: process.env.TEST_RUNNER_API_KEY || args[1],
    ollama: {
      enabled: process.env.OLLAMA_ENABLED !== 'false',
      host: process.env.OLLAMA_HOST || 'localhost',
      port: process.env.OLLAMA_PORT || 11434,
      model: process.env.OLLAMA_MODEL || 'codellama'
    },
    autoFix: process.env.AUTO_FIX === 'true',
    debug: process.env.DEBUG !== 'false'
  };

  console.log('üöÄ AI-Enhanced Universal Node.js Tester\n');
  console.log('Configuration:');
  console.log(`   Test Folder: ${config.testFolder}`);
  console.log(`   Ollama Enabled: ${config.ollama.enabled}`);
  console.log(`   Auto-fix: ${config.autoFix}`);
  console.log(`   Debug Mode: ${config.debug}\n`);

  if (!config.apiKey) {
    console.error('‚ùå ERROR: API key required');
    console.error('\nUsage:');
    console.error('   node ai-enhanced-test-runner.js <test-folder> <api-key>');
    console.error('   OR set environment variable: TEST_RUNNER_API_KEY=<your-key>');
    console.error('\n   First run will generate a default admin API key');
    process.exit(1);
  }

  const tester = new UniversalNodeJSTester(config);
  
  tester.runTests(config.testFolder, config.apiKey)
    .then(() => {
      console.log('\n‚úÖ All tests completed successfully');
      process.exit(0);
    })
    .catch(error => {
      console.error('\n‚ùå Test runner failed:', error.message);
      if (config.debug) {
        console.error(error.stack);
      }
      process.exit(1);
    });

  process.on('SIGINT', () => {
    console.log('\n\n‚ö†Ô∏è  Interrupted by user');
    process.exit(130);
  });

  process.on('uncaughtException', (error) => {
    console.error('\nüí• Uncaught Exception:', error.message);
    if (config.debug) {
      console.error(error.stack);
    }
    process.exit(1);
  });

  process.on('unhandledRejection', (reason, promise) => {
    console.error('\nüí• Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
  });
}

module.exports = { UniversalNodeJSTester, SecurityManager, RateLimiter, OllamaAIAuditor };